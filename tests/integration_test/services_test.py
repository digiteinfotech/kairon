import io
import asyncio
import os
import re
import shutil
import tarfile
import tempfile
import time
import uuid
from datetime import datetime, timedelta, date
from io import BytesIO
from unittest import mock
from unittest.mock import patch, MagicMock
from urllib.parse import urljoin
from zipfile import ZipFile
import litellm

import pytest
import pytz
import responses
import ujson as json
import yaml
from botocore.exceptions import ClientError
from bson import ObjectId
from fastapi.testclient import TestClient
from jira import JIRAError
from mongoengine import connect
from mongoengine.queryset.base import BaseQuerySet
from pipedrive.exceptions import UnauthorizedError
from pydantic import SecretStr
from rasa.shared.utils.io import read_config_file
from slack_sdk.web.slack_response import SlackResponse

from kairon.events.definitions.upload_handler import UploadHandler
from kairon.shared.account.data_objects import UserActivityLog
from kairon.shared.account.data_objects import UserEmailConfirmation
from kairon.shared.actions.models import ActionParameterType, DbActionOperationType, DbQueryValueType, ActionType
from kairon.shared.admin.data_objects import LLMSecret
from kairon.shared.callback.data_objects import CallbackLog, CallbackRecordStatusType, CallbackConfig
from kairon.shared.channels.mail.data_objects import MailResponseLog, MailStatus
from kairon.shared.chat.broadcast.data_objects import AnalyticsPipelineLogs
from kairon.shared.chat.data_objects import Channels
from kairon.shared.content_importer.content_processor import ContentImporterLogProcessor
from kairon.shared.importer.data_objects import ValidationLogs
from kairon.shared.utils import Utility, MailUtility
from kairon.shared.llm.processor import LLMProcessor
import numpy as np

Utility.load_system_metadata()

from pathlib import Path
from kairon.api.app.main import app
from kairon.events.definitions.multilingual import MultilingualEvent
from kairon.exceptions import AppException
from kairon.idp.processor import IDPProcessor
from kairon.shared.account.processor import AccountProcessor
from kairon.shared.actions.data_objects import ActionServerLogs, ScheduleAction, Actions, ParallelActionConfig, \
    PyscriptActionConfig, PromptAction, HttpActionConfig
from kairon.shared.actions.utils import ActionUtility
from kairon.shared.auth import Authentication
from kairon.shared.cloud.utils import CloudUtility
from kairon.shared.cognition.data_objects import CognitionSchema, CognitionData, CollectionData
from kairon.shared.constants import EventClass, ChannelTypes, KaironSystemSlots
from kairon.shared.data.audit.data_objects import AuditLogData
from kairon.shared.data.constant import (
    UTTERANCE_TYPE,
    EVENT_STATUS,
    TOKEN_TYPE,
    AuditlogActions,
    KAIRON_TWO_STAGE_FALLBACK,
    FeatureMappings,
    DEFAULT_NLU_FALLBACK_RESPONSE,
    DEFAULT_LLM, TASK_TYPE, STATUSES, SYNC_STATUS
)
from kairon.shared.data.data_objects import (
    Stories,
    Rules,
    Utterances,
    Intents,
    TrainingExamples,
    Responses,
    ChatClientConfig,
    BotSettings,
    LLMSettings,
    DemoRequestLogs, UserMediaData, POSIntegrations
)
from kairon.events.definitions.catalog_sync import CatalogSync
from kairon.meta.processor import MetaProcessor
from kairon.shared.catalog_sync.data_objects import CatalogProviderMapping, CatalogSyncLogs
from kairon.shared.cognition.processor import CognitionDataProcessor
from kairon.shared.data.model_processor import ModelProcessor
from kairon.shared.data.processor import MongoProcessor
from kairon.shared.data.utils import DataUtility
from kairon.shared.metering.constants import MetricType
from kairon.shared.models import StoryEventType, UserMediaUploadStatus
from kairon.shared.models import User
from kairon.shared.multilingual.processor import MultilingualLogProcessor
from kairon.shared.multilingual.utils.translator import Translator
from kairon.shared.organization.processor import OrgProcessor
from kairon.shared.sso.clients.google import GoogleSSO
from urllib.parse import urlencode
from deepdiff import DeepDiff

os.environ["system_file"] = "./tests/testing_data/system.yaml"
client = TestClient(app)
access_token = None
refresh_token = None
token_type = None


@pytest.fixture(autouse=True, scope="function")
def setup():
    os.environ["system_file"] = "./tests/testing_data/system.yaml"
    Utility.load_environment()
    connect(**Utility.mongoengine_connection(Utility.environment["database"]["url"]))
    AccountProcessor.load_system_properties()

    llm_secret = LLMSecret(
        llm_type="openai",
        api_key='value',
        models=["gpt-3.5-turbo", "gpt-4.1-mini", "gpt-4.1"],
        user='user'
    )
    llm_secret.save()

    llm_secret = LLMSecret(
        llm_type="anthropic",
        api_key='value',
        models=[ "claude-3-7-sonnet-20250219"],
        user='user'
    )
    llm_secret.save()

    yield llm_secret
    LLMSecret.objects.delete()

def pytest_configure():
    return {
        "token_type": None,
        "access_token": None,
        "refresh_token": None,
        "username": None,
        "bot": None,
        "content_id": None,
    }


async def mock_smtp(*args, **kwargs):
    return None


def complete_end_to_end_event_execution(bot, user, event_class, **kwargs):
    from kairon.events.definitions.data_importer import TrainingDataImporterEvent
    from kairon.events.definitions.model_training import ModelTrainingEvent
    from kairon.events.definitions.model_testing import ModelTestingEvent
    from kairon.events.definitions.history_delete import DeleteHistoryEvent
    from kairon.events.definitions.content_importer import DocContentImporterEvent


    if event_class == EventClass.data_importer:
        overwrite = kwargs.get('overwrite', True)
        TrainingDataImporterEvent(bot, user, import_data=True, overwrite=overwrite).execute()
    elif event_class == EventClass.catalog_integration:
        provider = kwargs.get('provider')
        sync_type = kwargs.get('sync_type')
        token = kwargs.get('token')
        sync_ref_id = kwargs.get('sync_ref_id')
        asyncio.run(CatalogSync(bot, user, provider, sync_type=sync_type, token=token).execute(sync_ref_id=sync_ref_id))
    elif event_class == EventClass.model_training:
        ModelTrainingEvent(bot, user).execute()
    elif event_class == EventClass.content_importer:
        table_name = kwargs.get('table_name')
        overwrite = kwargs.get('overwrite', False)
        DocContentImporterEvent(bot, user, table_name, overwrite=overwrite).execute()
    elif event_class==EventClass.upload_file_handler:
        upload_type=kwargs.get("upload_type")
        collection_name=kwargs.get("collection_name")
        overwrite=kwargs.get("overwrite", False)
        UploadHandler(bot=bot, user=user, upload_type=upload_type, collection_name=collection_name, overwrite=overwrite).execute()
    elif event_class == EventClass.model_testing:
        ModelTestingEvent(bot, user).execute()
    elif event_class == EventClass.delete_history:
        DeleteHistoryEvent(bot, user).execute()
    elif event_class == EventClass.multilingual:
        MultilingualEvent(
            bot,
            user,
            dest_lang=kwargs.get("kwargs"),
            translate_responses=kwargs.get("translate_responses"),
            translate_actions=kwargs.get("translate_actions"),
        ).execute()


def test_healthcheck():
    response = client.get("/healthcheck")
    actual = response.json()
    assert response.status_code == 200
    assert actual["message"] == "health check ok"


def test_api_wrong_login():
    response = client.post(
        "/api/auth/login", data={"username": "test@demo.ai", "password": "Welcome@1"}
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "User does not exist!"
    assert response.headers == {
        "content-length": "79",
        "content-type": "application/json",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "Cross-Origin-Embedder-Policy": "require-corp",
        "Cross-Origin-Opener-Policy": "same-origin",
        "Cross-Origin-Resource-Policy": "same-origin",
        "Access-Control-Allow-Origin": "*",
    }
    value = list(AuditLogData.objects(user="test@demo.ai", action='activity', entity='invalid_login'))
    assert value[0]["entity"] == "invalid_login"
    assert value[0]["timestamp"]
    assert len(value) == 1


@mock.patch("kairon.shared.utils.Utility.validate_recaptcha", autospec=True)
@mock.patch("kairon.shared.utils.MailUtility.trigger_smtp", autospec=True)
def test_book_a_demo(trigger_smtp_mock, validate_recaptcha_mock, monkeypatch):
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl1234567890"
    )
    data = {
        "first_name": "sample",
        "last_name": "test",
        "email": "sampletest@gmail.com",
        "contact": "9876543210",
        "additional_info": "Thank You",
    }
    form_data = {"data": data, "recaptcha_response": "1234567890"}

    with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
        mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.post("/api/user/demo", json=form_data).json()
    assert (
            response["message"]
            == "Thank You for your interest in Kairon. We will reach out to you soon."
    )
    assert not response["data"]
    assert response["error_code"] == 0
    assert response["success"]


@mock.patch("kairon.shared.utils.MailUtility.trigger_smtp", autospec=True)
def test_book_a_demo_with_invalid_recaptcha_response(trigger_smtp_mock, monkeypatch):
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl1234567890"
    )
    data = {
        "first_name": "sample",
        "last_name": "test",
        "email": "sampletest@gmail.com",
        "contact": "9876543210",
        "additional_info": "Thank You",
    }
    form_data = {"data": data, "recaptcha_response": ""}

    with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
        mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.post("/api/user/demo", json=form_data).json()
    assert response["message"] == "recaptcha_response is required"
    assert not response["data"]
    assert response["error_code"] == 422
    assert not response["success"]


@responses.activate
@mock.patch("kairon.shared.utils.MailUtility.trigger_smtp", autospec=True)
def test_book_a_demo_with_validate_recaptcha_failed(trigger_smtp_mock):
    data = {
        "first_name": "sample",
        "last_name": "test",
        "email": "sampletest@gmail.com",
        "contact": "9876543210",
        "additional_info": "Thank You",
    }
    form_data = {"data": data, "recaptcha_response": "1234567890"}

    with patch.dict(
            Utility.environment["security"],
            {"validate_recaptcha": True, "recaptcha_secret": "asdfghjkl1234567890"},
    ):
        with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
            mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}

            responses.add(
                responses.POST,
                "https://www.google.com/recaptcha/api/siteverify?secret=asdfghjkl1234567890&response=1234567890&remoteip=testclient",
                json={"success": False},
            )

            response = client.post("/api/user/demo", json=form_data).json()
    assert response["message"] == "Failed to validate recaptcha"
    assert not response["data"]
    assert response["error_code"] == 422
    assert not response["success"]


@mock.patch("kairon.shared.utils.Utility.validate_recaptcha", autospec=True)
@mock.patch("kairon.shared.utils.MailUtility.trigger_smtp", autospec=True)
def test_book_a_demo_with_valid_data(trigger_smtp_mock, validate_recaptcha_mock, monkeypatch):
    monkeypatch.setitem(Utility.environment['security'], 'validate_recaptcha', True)
    monkeypatch.setitem(Utility.environment['security'], 'recaptcha_secret', 'asdfghjkl1234567890')
    data = {
        "first_name": "Mahesh",
        "last_name": 'Sattala',
        "email": "mahesh.sattala@digite.com",
        "phone": "+919876543210",
        "message": "Thank You",
        "recaptcha_response": "Svw2mPVxM0SkO4_2yxTcDQQ7iKNUDeDhGf4l6C2i"
    }
    form_data = {"data": data, "recaptcha_response": "1234567890"}

    with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
        mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.post(
            "/api/user/demo",
            json=form_data
        ).json()
    assert response['message'] == 'Thank You for your interest in Kairon. We will reach out to you soon.'
    assert not response['data']
    assert response['error_code'] == 0
    assert response['success']
    demo_request_logs = DemoRequestLogs.objects(first_name="Mahesh", last_name="Sattala",
                                                email="mahesh.sattala@digite.com").get().to_mongo().to_dict()
    assert demo_request_logs['first_name'] == "Mahesh"
    assert demo_request_logs['last_name'] == "Sattala"
    assert demo_request_logs['email'] == "mahesh.sattala@digite.com"
    assert demo_request_logs['phone'] == "+919876543210"
    assert demo_request_logs['status'] == "request_received"
    assert demo_request_logs['message'] == "Thank You"
    assert demo_request_logs['recaptcha_response'] == "Svw2mPVxM0SkO4_2yxTcDQQ7iKNUDeDhGf4l6C2i"


def test_account_registration_without_privacy_policy_and_terms_consent_and_accepted_ai_guidelines(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": False,
            "accepted_terms": False,
            "accepted_ai_guidelines": False
        },
    )
    actual = response.json()
    assert actual["message"] == "Should be agreed to: privacy policy, terms and conditions, ai guidelines"
    assert not actual["success"]
    assert not actual["data"]
    assert actual["error_code"] == 422
    values = list(UserActivityLog.objects(user="integration@demo.ai", type='user_consent').order_by(
        "-timestamp"))
    user_activity_log = values[0].to_mongo().to_dict()
    print(user_activity_log)
    assert user_activity_log['type'] == 'user_consent'
    assert user_activity_log['user'] == 'integration@demo.ai'
    assert user_activity_log['timestamp']
    assert user_activity_log['account'] == -1
    assert user_activity_log['message'] == ['Privacy Policy, Terms and Conditions and AI Guidelines consent']
    assert user_activity_log['data']['username'] == 'integration@demo.ai'
    assert user_activity_log['data']['accepted_privacy_policy'] is False
    assert user_activity_log['data']['accepted_terms'] is False
    assert user_activity_log['data']['accepted_ai_guidelines'] is False
    assert user_activity_log['data']['terms_and_policy_version'] == 1.0


def test_account_registration_without_privacy_policy_and_accepted_ai_guidelines(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": False,
            "accepted_terms": True,
            "accepted_ai_guidelines": False
        },
    )
    actual = response.json()
    assert actual["message"] == "Should be agreed to: privacy policy, ai guidelines"
    assert not actual["success"]
    assert not actual["data"]
    assert actual["error_code"] == 422
    values = list(UserActivityLog.objects(user="integration@demo.ai", type='user_consent').order_by(
        "-timestamp"))
    user_activity_log = values[0].to_mongo().to_dict()
    print(user_activity_log)
    assert user_activity_log['type'] == 'user_consent'
    assert user_activity_log['user'] == 'integration@demo.ai'
    assert user_activity_log['account'] == -1
    assert user_activity_log['timestamp']
    assert user_activity_log['message'] == ['Privacy Policy, Terms and Conditions and AI Guidelines consent']
    assert user_activity_log['data']['username'] == 'integration@demo.ai'
    assert user_activity_log['data']['accepted_privacy_policy'] is False
    assert user_activity_log['data']['accepted_terms'] is True
    assert user_activity_log['data']['accepted_ai_guidelines'] is False
    assert user_activity_log['data']['terms_and_policy_version'] == 1.0


def test_account_registration_without_terms_and_conditions_consent(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": False,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Should be agreed to: terms and conditions"
    assert not actual["success"]
    assert not actual["data"]
    assert actual["error_code"] == 422
    values = list(UserActivityLog.objects(user="integration@demo.ai", type='user_consent').order_by(
        "-timestamp"))
    user_activity_log = values[0].to_mongo().to_dict()
    print(user_activity_log)
    assert user_activity_log['type'] == 'user_consent'
    assert user_activity_log['user'] == 'integration@demo.ai'
    assert user_activity_log['account'] == -1
    assert user_activity_log['timestamp']
    assert user_activity_log['message'] == ['Privacy Policy, Terms and Conditions and AI Guidelines consent']
    assert user_activity_log['data']['username'] == 'integration@demo.ai'
    assert user_activity_log['data']['accepted_privacy_policy'] is True
    assert user_activity_log['data']['accepted_terms'] is False
    assert user_activity_log['data']['accepted_ai_guidelines'] is True
    assert user_activity_log['data']['terms_and_policy_version'] == 1.0


def test_account_registration_error():
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "welcome@1",
            "confirm_password": "welcome@1",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == [
        {'loc': ['body', 'password'], 'msg': 'Password length must be 10\nMissing 1 uppercase letter',
         'type': 'value_error'}]
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None


@responses.activate
def test_recaptcha_verified_request(monkeypatch):
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl1234567890"
    )

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl1234567890&response=1234567890",
        json={"success": True},
    )
    response = client.post(
        "/api/account/registration",
        json={
            "recaptcha_response": "1234567890",
            "email": "integration1234567890@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration1234567890",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl1234567890&response=1234567890&remoteip=58.0.127.89",
        json={"success": True},
    )
    response = client.post(
        "/api/account/registration",
        json={
            "recaptcha_response": "1234567890",
            "remote_ip": "58.0.127.89",
            "email": "integration1234567@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration1234567",
            "bot": "integration",
            "add_trusted_device": True,
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"


@responses.activate
def test_recaptcha_verified_request_invalid(monkeypatch):
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl1234567890"
    )

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl1234567890&response=1234567890",
        json={"success": False},
    )

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl1234567890&response=987654321",
        json={"success": True},
        status=204,
    )

    response = client.post(
        "/api/account/registration",
        json={
            "recaptcha_response": "1234567890",
            "email": "integration1234567890@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "Failed to validate recaptcha",
        "data": None,
        "error_code": 422,
    }

    response = client.post(
        "/api/account/registration",
        json={
            "recaptcha_response": "987654321",
            "email": "integration1234567890@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"]
    assert actual["data"] is None
    assert actual["error_code"] == 422

    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration1234567890@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "recaptcha_response is required",
        "data": None,
        "error_code": 422,
    }


@responses.activate
def test_account_registation_temporary_email():
    email = "test@temporay.com"
    api_key = "test"
    with patch.dict(
            Utility.environment,
            {"verify": {"email": {"type": "quickemail", "key": api_key, "enable": True}}},
    ):
        responses.add(
            responses.GET,
            "http://api.quickemailverification.com/v1/verify?"
            + urlencode({"apikey": api_key, "email": email}),
            json={
                "result": "valid",
                "reason": "rejected_email",
                "disposable": "true",
                "accept_all": "false",
                "role": "false",
                "free": "false",
                "email": email,
                "user": "test",
                "domain": "quickemailverification.com",
                "mx_record": "us2.mx1.mailhostbox.com",
                "mx_domain": "mailhostbox.com",
                "safe_to_send": "false",
                "did_you_mean": "",
                "success": "true",
                "message": None,
            },
        )
        response = client.post(
            "/api/account/registration",
            json={
                "email": email,
                "first_name": "Demo",
                "last_name": "User",
                "password": "Welcome@10",
                "confirm_password": "Welcome@10",
                "account": "integration",
                "bot": "integration",
                "accepted_privacy_policy": True,
                "accepted_terms": True,
                "accepted_ai_guidelines": True
            },
        )
        actual = response.json()
        assert actual["message"] == [
            {
                "loc": ["body", "email"],
                "msg": "Invalid or disposable Email!",
                "type": "value_error",
            }
        ]


@responses.activate
def test_account_registation_invalid_email():
    email = "test@temporay.com"
    api_key = "test"
    with patch.dict(
            Utility.environment,
            {"verify": {"email": {"type": "quickemail", "key": api_key, "enable": True}}},
    ):
        responses.add(
            responses.GET,
            "http://api.quickemailverification.com/v1/verify?"
            + urlencode({"apikey": api_key, "email": email}),
            json={
                "result": "invalid",
                "reason": "rejected_email",
                "disposable": "false",
                "accept_all": "false",
                "role": "false",
                "free": "false",
                "email": email,
                "user": "test",
                "domain": "quickemailverification.com",
                "mx_record": "us2.mx1.mailhostbox.com",
                "mx_domain": "mailhostbox.com",
                "safe_to_send": "false",
                "did_you_mean": "",
                "success": "true",
                "message": None,
            },
        )
        response = client.post(
            "/api/account/registration",
            json={
                "email": email,
                "first_name": "Demo",
                "last_name": "User",
                "password": "Welcome@10",
                "confirm_password": "Welcome@10",
                "account": "integration",
                "bot": "integration",
                "accepted_privacy_policy": True,
                "accepted_terms": True,
                "accepted_ai_guidelines": True
            },
        )
        actual = response.json()
        assert actual["message"] == [
            {
                "loc": ["body", "email"],
                "msg": "Invalid or disposable Email!",
                "type": "value_error",
            }
        ]


@responses.activate
def test_account_registation_invalid_email_quick_email_valid():
    email = "test@temporay.com"
    api_key = "test"
    with patch.dict(
            Utility.environment,
            {
                "verify": {
                    "email": {"type": "quickemail", "key": api_key, "enable": True}
                }
            },
    ):
        responses.add(
            responses.GET,
            "http://api.quickemailverification.com/v1/verify?"
            + urlencode({"apikey": api_key, "email": email}),
            json={
                "result": "valid",
                "reason": "rejected_email",
                "disposable": "false",
                "accept_all": "false",
                "role": "false",
                "free": "false",
                "email": email,
                "user": "test",
                "domain": "quickemailverification.com",
                "mx_record": "us2.mx1.mailhostbox.com",
                "mx_domain": "mailhostbox.com",
                "safe_to_send": "false",
                "did_you_mean": "",
                "success": "true",
                "message": None,
            },
        )
        response = client.post(
            "/api/account/registration",
            json={
                "email": email,
                "first_name": "Email",
                "last_name": "Validation",
                "password": "Welcome@12",
                "confirm_password": "Welcome@12",
                "account": "email_validation",
                "bot": "email_validation",
                "accepted_privacy_policy": True,
                "accepted_terms": True,
                "accepted_ai_guidelines": True
            },
        )
        actual = response.json()
        assert actual["message"] == "Account Registered!"


def test_account_registration(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    response = client.post(
        "/api/account/registration",
        json={
            "email": "INTEGRATIONTEST@DEMO.AI",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integrationtest",
            "bot": "integrationtest",
            "fingerprint": "asdfghj4567890",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    response = client.post(
        "/api/account/registration",
        json={
            "email": "INTEGRATION2@DEMO.AI",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration2",
            "bot": "integration2",
            "fingerprint": "asdfghj4567890",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"
    assert response.headers == {
        "content-length": "75",
        "content-type": "application/json",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "Cross-Origin-Embedder-Policy": "require-corp",
        "Cross-Origin-Opener-Policy": "same-origin",
        "Cross-Origin-Resource-Policy": "same-origin",
        "Access-Control-Allow-Origin": "*",
    }


def test_account_registration_enable_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "This feature is disabled"
    assert actual["error_code"] == 422
    assert not actual["success"]


def test_api_wrong_password():
    response = client.post(
        "/api/auth/login",
        data={"username": "INTEGRATION@DEMO.AI", "password": "welcome@1"},
    )
    actual = response.json()
    assert actual["error_code"] == 401
    assert not actual["success"]
    assert actual["message"] == "Incorrect username or password"
    value = list(AuditLogData.objects(user="integration@demo.ai", action='activity', entity='invalid_login'))

    assert value[0]["entity"] == "invalid_login"
    assert value[0]["timestamp"]
    assert len(value) == 1


@responses.activate
def test_api_login_with_recaptcha(monkeypatch):
    email = "integration@demo.ai"
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl123456"
    )

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl123456&response=asdfghjkl2345",
        json={"success": True},
    )
    response = client.post(
        "/api/auth/login",
        data={
            "username": email,
            "password": "Welcome@10",
            "recaptcha_response": "asdfghjkl2345",
        },
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )


@responses.activate
def test_api_login_with_recaptcha_failed(monkeypatch):
    email = "integration@demo.ai"
    monkeypatch.setitem(Utility.environment["security"], "validate_recaptcha", True)
    monkeypatch.setitem(
        Utility.environment["security"], "recaptcha_secret", "asdfghjkl123456"
    )

    responses.add(
        "POST",
        f"{Utility.environment['security']['recaptcha_url']}?secret=asdfghjkl123456&response=asdfghjkl23",
        json={"success": False},
    )
    response = client.post(
        "/api/auth/login",
        data={
            "username": email,
            "password": "Welcome@10",
            "recaptcha_response": "asdfghjkl23",
        },
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "Failed to validate recaptcha",
        "data": None,
        "error_code": 422,
    }

    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "recaptcha_response is required",
        "data": None,
        "error_code": 422,
    }


def test_api_login(monkeypatch):
    email = "integration@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.access_token = actual["data"]["access_token"]
    pytest.token_type = actual["data"]["token_type"]

    response = client.post(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token, 'Content-Type': 'application/json'},
        json={"name": "Hi-Hello", "from_template": "Hi-Hello"},
    ).json()
    assert response['message'] == "Bot created"
    assert response['data']['bot_id']

    pytest.username = email
    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"]["user"]["_id"]
    assert response["data"]["user"]["email"] == "integration@demo.ai"
    assert (
            response["data"]["user"]["bots"]["account_owned"][0]["user"]
            == "integration@demo.ai"
    )
    assert response["data"]["user"]["bots"]["account_owned"][0]["timestamp"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["name"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["_id"]
    assert not response["data"]["user"]["bots"]["shared"]
    assert response["data"]["user"]["timestamp"]
    assert response["data"]["user"]["status"]
    assert response["data"]["user"]["account_name"] == "integration"
    assert response["data"]["user"]["first_name"] == "Demo"
    assert response["data"]["user"]["last_name"] == "User"
    assert response["data"]["user"]["accepted_privacy_policy"] is True
    assert response["data"]["user"]["accepted_terms"] is True
    assert response["data"]["user"]["show_updated_terms_and_policy"] is False

    email = "integrationtest@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0

    email = "integration2@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0

    email = "integration@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "User Authenticated"
    assert actual["data"]
    assert actual["data"]["token_type"] == "bearer"
    assert actual["data"]["access_token"]
    assert actual["data"]["refresh_token"]
    assert actual["data"]["access_token_expiry"]
    assert actual["data"]["refresh_token_expiry"]
    refresh_token = actual["data"]["refresh_token"]
    access_token = actual["data"]["access_token"]

    response = client.get(
        f"/api/auth/token/refresh",
        headers={"Authorization": pytest.token_type + " " + access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == "Only refresh tokens can be used to generate new token!"

    response = client.get(
        f"/api/auth/token/refresh",
        headers={"Authorization": pytest.token_type + " " + refresh_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["access_token"]
    assert actual["data"]["token_type"]
    assert actual["data"]["refresh_token"]
    assert (
            actual["message"]
            == "This token will be shown only once. Please copy this somewhere safe."
               "It is your responsibility to keep the token secret. "
               "If leaked, others may have access to your system."
    )


def test_get_user_details_with_latest_version(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "terms_and_policy_version", 2.0)
    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = response.json()
    print(response)
    assert response["success"]
    assert response["error_code"] == 0
    assert response["data"]["user"]["_id"]
    assert response["data"]["user"]["email"] == "integration@demo.ai"
    assert (
            response["data"]["user"]["bots"]["account_owned"][0]["user"]
            == "integration@demo.ai"
    )
    assert response["data"]["user"]["bots"]["account_owned"][0]["timestamp"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["name"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["_id"]
    assert not response["data"]["user"]["bots"]["shared"]
    assert response["data"]["user"]["timestamp"]
    assert response["data"]["user"]["status"]
    assert response["data"]["user"]["account_name"] == "integration"
    assert response["data"]["user"]["first_name"] == "Demo"
    assert response["data"]["user"]["last_name"] == "User"
    assert response["data"]["user"]["accepted_privacy_policy"] is True
    assert response["data"]["user"]["accepted_terms"] is True
    assert response["data"]["user"]["show_updated_terms_and_policy"] is True


def test_add_user_consent_details():
    response = client.post(
        "/api/user/consent/details",
        json={
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Consent Details added!"

    values = list(UserActivityLog.objects(user="integration@demo.ai", type='user_consent').order_by(
        "-timestamp"))
    user_activity_log = values[0].to_mongo().to_dict()
    print(user_activity_log)
    assert user_activity_log['type'] == 'user_consent'
    assert user_activity_log['user'] == 'integration@demo.ai'
    assert user_activity_log['account'] == -1
    assert user_activity_log['timestamp']
    assert user_activity_log['message'] == ['Privacy Policy, Terms and Conditions and AI Guidelines consent']
    assert user_activity_log['data']['username'] == 'integration@demo.ai'
    assert user_activity_log['data']['accepted_privacy_policy'] is True
    assert user_activity_log['data']['accepted_terms'] is True
    assert user_activity_log['data']['accepted_ai_guidelines'] is True
    assert user_activity_log['data']['terms_and_policy_version'] == 1.0


def test_add_user_consent_details_without_terms_and_accepted_ai_guidelines():
    response = client.post(
        "/api/user/consent/details",
        json={
            "accepted_privacy_policy": True,
            "accepted_terms": False,
            "accepted_ai_guidelines": False
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Should be agreed to: terms and conditions, ai guidelines"


def test_add_user_consent_details_without_privacy_policy_and_accepted_ai_guidelines():
    response = client.post(
        "/api/user/consent/details",
        json={
            "accepted_privacy_policy": False,
            "accepted_terms": True,
            "accepted_ai_guidelines": False
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Should be agreed to: privacy policy, ai guidelines"


def test_add_user_consent_details_without_both_privacy_policy_and_terms():
    response = client.post(
        "/api/user/consent/details",
        json={
            "accepted_privacy_policy": False,
            "accepted_terms": False,
            "accepted_ai_guidelines": True
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Should be agreed to: privacy policy, terms and conditions"


@responses.activate
def test_augment_questions_without_authenticated():
    response = client.post(
        "/api/augment/questions",
        json={"data": "TESTING TEXTDATA"},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 401
    assert actual["data"] is None
    assert actual["message"] == "Not authenticated"


@responses.activate
def test_augment_questions():
    responses.add(
        responses.POST,
        url="http://localhost:8000/questions",
        match=[responses.matchers.json_params_matcher({"data": "TESTING TEXTDATA"})],
        json={
            "success": True,
            "data": {"question": "How can I help you?"},
            "message": None,
            "error_code": 0,
        },
        status=200,
    )
    response = client.post(
        "/api/augment/questions",
        json={"data": "TESTING TEXTDATA"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == {"question": "How can I help you?"}
    assert Utility.check_empty_string(actual["message"])


def test_api_login_enabled_with_fingerprint(monkeypatch):
    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    email = "integration@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert actual["message"] == "fingerprint is required"
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_trusted_device_on_signup_error(monkeypatch):
    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    response = client.post(
        "/api/account/registration",
        json={
            "recaptcha_response": "1234567890",
            "remote_ip": "58.0.127.89",
            "email": "integration1234567@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration1234567",
            "bot": "integration",
            "fingerprint": None,
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "fingerprint is required",
            "type": "value_error",
        }
    ]
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None


def test_add_trusted_device_disabled(monkeypatch):
    monkeypatch.setattr(AccountProcessor, "check_email_confirmation", mock_smtp)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    response = client.post(
        "/api/account/device/trusted",
        json={"data": "0987654321234567890"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["message"] == "Trusted devices are disabled!"
    assert not response["data"]
    assert response["error_code"] == 422
    assert not response["success"]


def test_add_trusted_device(monkeypatch):
    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)
    monkeypatch.setattr(AccountProcessor, "check_email_confirmation", mock_smtp)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)

    with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
        mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.post(
            "/api/account/device/trusted",
            json={"data": "0987654321234567890"},
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        ).json()
    assert (
            response["message"]
            == "A confirmation link has been sent to your registered mail address"
    )
    assert not response["data"]
    assert response["error_code"] == 0
    assert response["success"]


def test_add_trusted_device_email_disabled(monkeypatch):
    monkeypatch.setitem(Utility.environment["user"], "validate_trusted_device", True)
    with patch("kairon.shared.plugins.ipinfo.IpInfoTracker.execute") as mock_geo:
        mock_geo.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.post(
            "/api/account/device/trusted",
            json={"data": "098765432123456456734567"},
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        ).json()
    assert response["message"] == "Trusted device added!"
    assert response["error_code"] == 0
    assert response["success"]


def test_list_trusted_device():
    response = client.get(
        "/api/account/device/trusted",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["trusted_devices"]) == 1
    assert not response["data"]["trusted_devices"][0].get("fingerprint")
    assert response["data"]["trusted_devices"][0]["is_confirmed"]
    assert response["data"]["trusted_devices"][0]["geo_location"] == {
        "City": "Mumbai",
        "Network": "CATO",
    }
    assert response["data"]["trusted_devices"][0]["geo_location"]
    assert response["data"]["trusted_devices"][0]["confirmation_timestamp"]
    assert response["error_code"] == 0
    assert response["success"]


def test_confirm_trusted_device():
    payload = {"mail_id": "integration@demo.ai", "fingerprint": "0987654321234567890"}
    token = Utility.generate_token_payload(payload, minutes_to_expire=120)
    response = client.post(
        "/api/account/device/trusted/confirm", json={"data": token}
    ).json()
    assert response["message"] == "Trusted device added!"
    assert response["error_code"] == 0
    assert response["success"]


def test_list_trusted_device_2():
    response = client.get(
        "/api/account/device/trusted",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["trusted_devices"]) == 2
    assert not response["data"]["trusted_devices"][0].get("fingerprint")
    assert response["data"]["trusted_devices"][0]["is_confirmed"]
    assert response["data"]["trusted_devices"][0]["geo_location"] == {
        "City": "Mumbai",
        "Network": "CATO",
    }
    assert response["data"]["trusted_devices"][0]["geo_location"]
    assert response["data"]["trusted_devices"][0]["confirmation_timestamp"]
    assert response["error_code"] == 0
    assert response["success"]


def test_verify_is_trusted():
    response = client.post(
        "/api/account/device/trusted/verify",
        json={"data": "098765432123456456734567"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"] == {"is_trusted_device": True}
    assert response["error_code"] == 0
    assert response["success"]

    response = client.post(
        "/api/account/device/trusted/verify",
        json={"data": "76645657"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"] == {"is_trusted_device": False}
    assert response["error_code"] == 0
    assert response["success"]


def test_remove_trusted_device():
    response = client.delete(
        "/api/account/device/trusted/098765432123456456734567",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert not response["data"]
    assert response["error_code"] == 0
    assert response["success"]

    response = client.get(
        "/api/account/device/trusted",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["trusted_devices"]) == 1


def test_api_login_enabled_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    email = "integration@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert actual["message"] == "This feature is disabled"
    assert not actual["success"]
    assert actual["error_code"] == 422

def test_add_bot():
    response = client.post(
        "/api/account/bot",
        json={"name": "covid-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.headers == {
        "content-length": "100",
        "content-type": "application/json",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "Cross-Origin-Embedder-Policy": "require-corp",
        "Cross-Origin-Opener-Policy": "same-origin",
        "Cross-Origin-Resource-Policy": "same-origin",
        "Access-Control-Allow-Origin": "*",
    }
    response = response.json()
    assert response["message"] == "Bot created"
    assert response["error_code"] == 0
    assert response["success"]
    assert response["data"]["bot_id"]


def test_list_bots():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    pytest.bot = response["data"]["account_owned"][0]["_id"]
    assert response["data"]["account_owned"][0]["user"] == "integration@demo.ai"
    assert response["data"]["account_owned"][0]["timestamp"]
    assert response["data"]["account_owned"][0]["name"] == "Hi-Hello"
    assert response["data"]["account_owned"][0]["_id"]
    assert response["data"]["account_owned"][1]["user"] == "integration@demo.ai"
    assert response["data"]["account_owned"][1]["timestamp"]
    assert response["data"]["account_owned"][1]["name"] == "covid-bot"
    assert response["data"]["account_owned"][1]["_id"]
    assert response["data"]["shared"] == []


def test_get_client_name_with_no_configuration():
    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/client_name",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert not actual["data"]
    assert actual["message"] == 'No POS client configuration found for this bot.'
    assert actual["error_code"] == 422


def test_pos_register_pos_not_enabled():
    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/register",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "point of sale is not enabled"
    assert not actual["data"]
    assert actual["error_code"] == 422


@pytest.mark.asyncio
@responses.activate
def test_pos_register_with_client_name_exists():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = True
    bot_settings.save()

    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    jsonrpc = f"{base}/jsonrpc"
    auth = f"{base}/web/session/authenticate"
    call_kw = re.compile(f"{base}/web/dataset/call_kw")

    responses.add(responses.POST, jsonrpc, json={"result": ["Test Client", "Kairon Client"]}, status=200)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/register",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert actual["message"] == "Client Test Client already exists"
    assert not actual["data"]
    assert actual["error_code"] == 422


@pytest.mark.asyncio
@responses.activate
def test_pos_register():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = True
    bot_settings.save()

    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    jsonrpc = f"{base}/jsonrpc"
    auth = f"{base}/web/session/authenticate"
    call_kw = re.compile(f"{base}/web/dataset/call_kw")

    responses.add(responses.POST, jsonrpc, json={"result": ["Kairon Client"]}, status=200)
    responses.add(responses.POST, auth, json={"result": {"uid": 1}},
                  headers={"Set-Cookie": "session_id=fake-session-id-123; Path=/;"}, status=200)

    responses.add(responses.POST, call_kw, json={"result": True}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": [10]}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": [{"state": "to install"}]}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": True}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": [20]}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": [{"state": "to install"}]}, status=200,)
    responses.add(responses.POST, call_kw, json={"result": True}, status=200,)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/register",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["data"]["message"] == "Client 'Test Client' created and POS Activated"
    assert actual["error_code"] == 0


def test_pos_login_pos_not_enabled():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = False
    bot_settings.save()
    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/login",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "point of sale is not enabled"
    assert not actual["data"]
    assert actual["error_code"] == 422


@pytest.mark.asyncio
@responses.activate
def test_pos_login_with_page_type_pos_orders():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = True
    bot_settings.save()

    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    auth = f"{base}/web/session/authenticate"

    responses.add(responses.POST, auth, json={"result": {"uid": 1}},
                  headers={"Set-Cookie": "session_id=fake-session-id-123; Path=/;"}, status=200)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/login",
        json={"client_name": "Test Client", "page_type": "pos_orders"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["uid"] == 1
    assert actual["session_id"] == "fake-session-id-123"
    assert actual["url"] == 'http://localhost:8080/web#action=380&model=pos.order&view_type=list&cids=1&menu_id=231'


@pytest.mark.asyncio
@responses.activate
def test_pos_login():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = True
    bot_settings.save()

    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    auth = f"{base}/web/session/authenticate"

    responses.add(responses.POST, auth, json={"result": {"uid": 1}},
                  headers={"Set-Cookie": "session_id=fake-session-id-123; Path=/;"}, status=200)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/login",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["uid"] == 1
    assert actual["session_id"] == "fake-session-id-123"
    pytest.session_id = actual["session_id"]
    assert actual["url"] == 'http://localhost:8080/web#action=388&model=product.template&view_type=kanban&cids=1&menu_id=233'


def test_get_client_name():
    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/client_name",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert not actual["message"]
    assert actual["data"] == {'client_name': 'Test Client'}
    assert actual["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_delete_client_without_client():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    jsonrpc = f"{base}/jsonrpc"

    responses.add(responses.POST, jsonrpc, json={"result": ["Kairon Client"]}, status=200)
    responses.add(responses.POST, jsonrpc, json={"result": True}, status=200)

    response = client.request(
        "DELETE",
        f"/api/bot/{pytest.bot}/pos/odoo/client/delete",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Client 'Test Client' not found"
    assert not actual["data"]
    assert actual["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_delete_client():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    jsonrpc = f"{base}/jsonrpc"

    responses.add(responses.POST, jsonrpc, json={"result": ["Kairon Client", "Test Client"]}, status=200)
    responses.add(responses.POST, jsonrpc, json={"result": True}, status=200)

    response = client.request(
        "DELETE",
        f"/api/bot/{pytest.bot}/pos/odoo/client/delete",
        json={"client_name": "Test Client"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["data"]["message"] == "Client 'Test Client' deleted successfully"
    assert actual["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_toggle_product():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    product_id = 1
    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": product_id,
            "name": "Test Product",
            "available_in_pos": False
        }]},
        status=200
    )
    responses.add(
        responses.POST,
        url,
        json={"result": True},
        status=200
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/toggle_product/1?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["data"]["product_id"] == 1
    assert actual["data"]["name"] == "Test Product"
    assert actual["data"]["available_in_pos"] is True
    assert actual["message"] == "Product toggled to ON"
    assert actual["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_toggle_product_write_failure():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    product_id = 1

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": product_id,
            "name": "Faulty Product",
            "available_in_pos": True
        }]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        body=Exception("Simulated write failure"),
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/toggle_product/{product_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)

    assert not actual["success"]
    assert "Error toggling product" in actual["message"]
    assert "Simulated write failure" in actual["message"]
    assert not actual["data"]
    assert actual["error_code"] == 500


@pytest.mark.asyncio
@responses.activate
def test_toggle_product_not_found():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    product_id = 999

    responses.add(
        responses.POST,
        url,
        json={"result": []},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/toggle_product/{product_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)

    assert not actual["success"]
    assert actual["message"] == f"Product {product_id} not found"
    assert not actual["data"]
    assert actual["error_code"] == 404


@pytest.mark.asyncio
@responses.activate
def test_list_pos_orders_invalid_status():
    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}&status=invalid_state",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["message"] == "Invalid status value"
    assert not data["success"]
    assert not data["data"]
    assert data["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_list_pos_orders_empty():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(
        responses.POST,
        url,
        json={"result": []},
        status=200
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["data"]["data"] == []
    assert data["data"]["count"] == 0
    assert data["success"]
    assert data["message"] == "POS orders fetched"
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_list_pos_orders_success():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(
        responses.POST,
        url,
        json={"result": [10]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [
            {
                "id": 10,
                "name": "POS/0001",
                "amount_total": 450,
                "state": "paid",
                "partner_id": [1, "Test"],
                "company_id": [1, "My Company"],
                "session_id": [1, "Session A"],
                "date_order": "2025-01-01 10:00:00"
            }
        ]},
        status=200
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["data"]["count"] == 1
    assert data["data"] == {
        'data': [
            {
                'id': 10,
                'name': 'POS/0001',
                'amount_total': 450,
                'state': 'paid',
                'partner_id': [1, 'Test'],
                'company_id': [1, 'My Company'],
                'session_id': [1, 'Session A'],
                'date_order': '2025-01-01 10:00:00'}
        ],
        'count': 1
    }
    assert data["success"]
    assert data["message"] == "POS orders fetched"
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_product_not_found():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(responses.POST, url, json={"result": 99}, status=200)

    responses.add(responses.POST, url, json={"result": []}, status=200)

    payload = {
        "products": [{"product_id": 111, "qty": 1, "unit_price": 20.0}],
        "partner_id": None
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert not data["success"]
    assert data["message"] == "Product 111 not found"
    assert not data["data"]
    assert data["error_code"] == 404


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_product_not_available():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(responses.POST, url, json={"result": 98}, status=200)

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "name": "Hidden Item",
            "display_name": "Hidden",
            "lst_price": 100,
            "available_in_pos": False,
            "uom_id": [1, "Units"],
            "taxes_id": []
        }]},
        status=200
    )

    payload = {
        "products": [{"product_id": 99, "qty": 1, "unit_price": 20.0}]
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert not data["data"]
    assert data["message"] == "Product Hidden Item not available in POS"
    assert data["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_no_pos_config():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(responses.POST, url, json={"result": 99}, status=200)

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "name": "Tea",
            "display_name": "Tea",
            "lst_price": 20,
            "available_in_pos": True,
            "uom_id": [1, "Units"],
            "taxes_id": []
        }]},
        status=200
    )

    responses.add(responses.POST, url, json={"result": []}, status=200)

    payload = {
        "products": [{"product_id": 1, "qty": 1, "unit_price": 20.0}]
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert data["message"] == "No POS Config found"
    assert not data["data"]
    assert data["error_code"] == 422


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_no_payment_method():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(responses.POST, url, json={"result": 99}, status=200)

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "name": "Coffee",
            "display_name": "Coffee Cup",
            "lst_price": 40,
            "available_in_pos": True,
            "uom_id": [1, "Units"],
            "taxes_id": []
        }]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 1, "company_id": [1, "My Company"]}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 10, "sequence_number": 1}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": []},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": []},
        status=200
    )

    payload = {
        "products": [{"product_id": 1, "qty": 1, "unit_price": 20.0}]
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert data["message"] == "No POS payment methods found"
    assert not data["data"]
    assert data["error_code"]


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_without_partner():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(responses.POST, url, json={"result": 500}, status=200)

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "name": "Burger",
            "display_name": "Burger Meal",
            "lst_price": 150,
            "available_in_pos": True,
            "uom_id": [1, "Units"],
            "taxes_id": []
        }]},
        status=200
    )

    responses.add(responses.POST, url, json={"result": [{"id": 1, "company_id": [1, "Comp"]}]}, status=200)

    responses.add(responses.POST, url, json={"result": [{"id": 10, "sequence_number": 7}]}, status=200)

    responses.add(responses.POST, url, json={"result": [{"id": 22}]}, status=200)

    responses.add(responses.POST, url, json={"result": [555]}, status=200)

    payload = {"products": [{"product_id": 1, "qty": 2, "unit_price": 20.0}]}

    res = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = res.json()
    print(data)
    assert data["success"]
    assert data["message"] == "POS order created"
    assert data["data"]["order_id"] == 555
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_create_pos_order_success():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "name": "Pepsi",
            "display_name": "Pepsi 500ml",
            "lst_price": 50,
            "available_in_pos": True,
            "uom_id": [1, "Units"],
            "taxes_id": []
        }]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 1, "company_id": [1, "My Company"]}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 10, "sequence_number": 1}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 5}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [123]},
        status=200
    )

    payload = {
        "products": [{"product_id": 1, "qty": 2, "unit_price": 20.0}],
        "partner_id": 3
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order?session_id={pytest.session_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["success"]
    assert data["message"] == "POS order created"
    assert data["data"]["order_id"] == 123
    assert data["data"]["status"] == "created"
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_invalid_state():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 12

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "amount_total": 120,
            "state": "cancel",
            "partner_id": [1, "Test"],
            "session_id": [1, "Session A"]
        }]},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert data["message"] == "Cannot accept order. order already in 'cancel' state."
    assert not data["data"]
    assert data["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_not_found():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 999

    responses.add(responses.POST, url, json={"result": []}, status=200)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert not data["success"]
    assert data["message"] == "Order not found"
    assert not data["data"]
    assert data["error_code"] == 404


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_no_payment_method():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 13

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "amount_total": 150,
            "state": "draft",
            "partner_id": [2, "Sam"],
            "session_id": [1, "Session A"]
        }]},
        status=200
    )

    responses.add(responses.POST, url, json={"result": []}, status=200)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert data["message"] == "No POS payment method found"
    assert not data["data"]
    assert data["error_code"] == 404


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_unexpected_error():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 14

    responses.add(
        responses.POST,
        url,
        body="Bad Request",
        status=400
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)
    assert not data["success"]
    assert data["message"] == "JSON-RPC pos.order.read: HTTP 400 - Bad Request"
    assert not data["data"]
    assert data["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_invoice_failure():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 11

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "amount_total": 200,
            "partner_id": [1, "John"],
            "state": "draft",
            "session_id": [1, "Session A"]
        }]},
        status=200
    )

    responses.add(responses.POST, url, json={"result": [{"id": 30}]}, status=200)

    responses.add(responses.POST, url, json={"result": 101}, status=200)

    responses.add(responses.POST, url, json={"result": True}, status=200)

    responses.add(responses.POST, url, body="Internal Server Error", status=500)

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["success"]
    assert data["message"] == "Order accepted"
    assert data["data"] == {
        "order_id": order_id,
        "accepted": True,
        "invoiced": False
    }
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_accept_pos_order_success():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 10

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "amount_total": 500,
            "partner_id": [1, "Test"],
            "state": "draft",
            "session_id": [1, "Session A"]
        }]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": [{"id": 20}]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": 55},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": True},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": True},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/accept/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["success"]
    assert data["message"] == "Order accepted"
    assert data["data"] == {"order_id": order_id, "accepted": True}
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_reject_pos_order_invalid_state():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 15

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "state": "cancel"
        }]},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/reject/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + ' ' + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert not data["success"]
    assert data["message"] == "Cannot cancel order. order already in 'cancel' state."
    assert not data["data"]
    assert data["error_code"] == 400


@pytest.mark.asyncio
@responses.activate
def test_reject_pos_order_not_found():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 999

    responses.add(
        responses.POST,
        url,
        json={"result": []},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/reject/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + ' ' + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert not data["success"]
    assert data["message"] == "Order not found"
    assert data["error_code"] == 404
    assert not data["data"]


@pytest.mark.asyncio
@responses.activate
def test_reject_pos_order_success():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    order_id = 10

    responses.add(
        responses.POST,
        url,
        json={"result": [{
            "id": order_id,
            "state": "draft"
        }]},
        status=200
    )

    responses.add(
        responses.POST,
        url,
        json={"result": True},
        status=200
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/pos/odoo/pos_order/reject/{order_id}?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + ' ' + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["success"]
    assert data["message"] == "Order rejected"
    assert data["data"] == {"order_id": order_id, "status": "cancelled"}
    assert data["error_code"] == 0


@pytest.mark.asyncio
@responses.activate
def test_get_pos_products_odoo_error():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    responses.add(
        responses.POST,
        url,
        body="Bad Request",
        status=400
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/product?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert not data["success"]
    assert "Odoo error" in data["message"]
    assert data["message"] == 'Odoo error: 400: JSON-RPC product.template.search_read: HTTP 400 - Bad Request'
    assert not data["data"]


@pytest.mark.asyncio
@responses.activate
def test_get_pos_products_success():
    base = Utility.environment["pos"]["odoo"]["odoo_url"]
    url = f"{base}/web/dataset/call_kw"

    products = [
        {
            "id": 1,
            "name": "Product A",
            "list_price": 100,
            "barcode": "123456",
            "available_in_pos": True
        },
        {
            "id": 2,
            "name": "Product B",
            "list_price": 200,
            "barcode": "789012",
            "available_in_pos": True
        }
    ]

    responses.add(
        responses.POST,
        url,
        json={"result": products},
        status=200
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/pos/odoo/product?session_id={pytest.session_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    print(data)

    assert data["success"]
    assert data["data"]["count"] == 2
    assert data["data"]["data"] == products
    assert data["error_code"] == 0
    assert not data["message"]


def test_secure_collection_crud_lifecycle():
    # Step 1: Add a bot
    add_bot_resp = client.post(
        "/api/account/bot",
        json={"name": "secure-collection-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert add_bot_resp.status_code == 200
    bot_id = add_bot_resp.json()["data"]["bot_id"]
    assert bot_id

    # Step 2: Add document to secure collection
    add_payload_1 = {
        "collection_name": "testing_create_colection_secure",
        "is_secure": ["mobile_number"],
        "is_non_editable": ["empid"],
        "data": {
            "mobile_number": "09876541",
            "name": "testing_1",
            "empid": 12345
        },
        "status": True
    }
    add_resp_1 = client.post(
        f"/api/bot/{bot_id}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=add_payload_1
    )
    add_payload = {
        "collection_name": "testing_create_colection_secure",
        "is_secure": ["mobile_number"],
        "is_non_editable": ["empid"],
        "data": {
            "mobile_number": "0987654",
            "name": "testing",
            "empid": 1234
        },
        "status": True
    }
    add_resp = client.post(
        f"/api/bot/{bot_id}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=add_payload
    )
    assert add_resp.status_code == 200
    resp_json = add_resp.json()
    print(resp_json)
    assert resp_json["message"] == "Record saved!"
    doc_id = resp_json["data"]["_id"]
    assert doc_id

    # Step 3: List collection data
    list_resp = client.get(
        f"/api/bot/{bot_id}/data/collection/testing_create_colection_secure",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    assert list_resp.status_code == 200
    listed_data = list_resp.json()["data"]["logs"]
    assert any(doc["_id"] == doc_id for doc in listed_data)

    # Step 4: Update the document
    update_payload = {
        "id": doc_id,
        "collection_name": "testing_create_colection_secure",
        "data": {
            "mobile_number":"123456789",
            "name": "testing_updated",
            "empid": 4321  # This should be ignored because it's in `is_non_editable`
        },
        "is_secure": ["mobile_number"],
        "is_non_editable": ["empid"],
        "status": False
    }
    update_resp = client.put(
        f"/api/bot/{bot_id}/data/collection/{doc_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=update_payload
    )
    assert update_resp.status_code == 200
    assert update_resp.json()["message"] == "Record updated!"

    # Verify update  empid should remain unchanged (1234), name should change
    list_resp_after_update = client.get(
        f"/api/bot/{bot_id}/data/collection/testing_create_colection_secure",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    updated_doc = next(doc for doc in list_resp_after_update.json()["data"]["logs"] if doc["_id"] == doc_id)
    assert updated_doc["data"]["name"] == "testing_updated"
    assert updated_doc["data"]["empid"] == 1234  # Unchanged due to is_non_editable

    # Step 5: Delete the document
    delete_doc_resp = client.request(
        method="DELETE",
        url=f"/api/bot/{bot_id}/data/collection/{doc_id}",
        headers={
            "Authorization": pytest.token_type + " " + pytest.access_token,
            "Content-Type": "application/json"
        }
    )
    assert delete_doc_resp.status_code == 200
    assert delete_doc_resp.json()["message"] == "Record deleted!"

    # Step 6: Delete the collection
    delete_coll_resp = client.request(
        method="DELETE",
        url=f"/api/bot/{bot_id}/data/collection/delete/testing_create_colection_secure",
        headers={
            "Authorization": pytest.token_type + " " + pytest.access_token,
            "Content-Type": "application/json"
        })

    assert delete_coll_resp.status_code == 200
    assert delete_coll_resp.json()["data"]["deleted"] >= 1

    delete_resp = client.delete(
        f"/api/account/bot/{bot_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert delete_resp.status_code == 200
    assert delete_resp.json()["message"] == "Bot removed"


def test_get_all_collections():
    # Step 1: Create a bot
    add_bot_resp = client.post(
        "/api/account/bot",
        json={"name": "secure-collection-bot_testing"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert add_bot_resp.status_code == 200
    bot_id = add_bot_resp.json()["data"]["bot_id"]
    assert bot_id

    # Step 2: Add 4 different collections
    for i in range(1, 5):
        payload = {
            "collection_name": f"collection_{i}",
            "is_secure": ["mobile_number"],
            "is_non_editable": ["empid"],
            "data": {
                "mobile_number": f"999999000{i}",
                "name": f"test_user_{i}",
                "empid": 1000 + i
            },
            "status": True
        }
        add_resp = client.post(
            f"/api/bot/{bot_id}/data/collection",
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
            json=payload
        )
        assert add_resp.status_code == 200
        assert add_resp.json()["message"] == "Record saved!"
        assert add_resp.json()["data"]["_id"]

    # Step 3: Fetch all collections
    get_resp = client.get(
        f"/api/bot/{bot_id}/data/collections/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    assert get_resp.status_code == 200
    response_data = get_resp.json()["data"]

    # Step 4: Check the 4 collections are present with count = 1 each
    expected_collections = {f"collection_{i}": 1 for i in range(1, 5)}
    for collection in response_data:
        name = collection["collection_name"]
        count = collection["count"]
        assert name in expected_collections
        assert count == expected_collections[name]

    delete_resp = client.delete(
        f"/api/account/bot/{bot_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert delete_resp.status_code == 200
    assert delete_resp.json()["message"] == "Bot removed"

def test_delete_multiple_payload_content_with_empty_list():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.cognition_collections_limit = 20
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()
    metadata = {
        "metadata": None,
        "collection_name": "multiple_delete_test",
        "bot": pytest.bot,
        "user": pytest.username
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    contents = [
        "A bot is a software application designed to automate tasks.",
        "Bots can perform tasks like answering questions or analyzing data.",
        "Some bots control physical machines, craeate leads or play games."
    ]
    content_ids = []
    for content in contents:
        payload = {
            "data": content,
            "content_type": "text",
            "collection": "multiple_delete_test"
        }
        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["message"] == "Record saved!"
        assert actual["data"]["_id"]
        assert actual["error_code"] == 0
        content_ids.append(actual["data"]["_id"])
    data=json.dumps(content_ids)
    data={
        "row_ids":[]
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/delete_multiple",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"][0]["msg"] == 'row_ids must be a non-empty list of valid strings'

def test_delete_multiple_payload_content():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.cognition_collections_limit = 20
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()
    metadata = {
        "metadata": None,
        "collection_name": "multiple_delete_test1",
        "bot": pytest.bot,
        "user": pytest.username
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    contents = [
        "A bot is a software application designed to automate tasks.",
        "Bots can perform tasks like answering questions or analyzing data.",
        "Some bots control physical machines, craeate leads or play games."
    ]
    content_ids = []
    for content in contents:
        payload = {
            "data": content,
            "content_type": "text",
            "collection": "multiple_delete_test1"
        }
        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["message"] == "Record saved!"
        assert actual["data"]["_id"]
        assert actual["error_code"] == 0
        content_ids.append(actual["data"]["_id"])
    data={
        "row_ids":content_ids
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/delete_multiple",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Records deleted!"

def test_add_global_widget_config():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        json={
           "global_config": [
                {
                    "type": "dateRange",
                    "title": "Date Range",
                    "initialStartDate": "2023-01-01",
                    "initialEndDate": "2023-06-30"
                },
                {
                    "type": "categorical",
                    "title": "Regions",
                    "name": "Region",
                    "options": [
                        {"value": "mh", "label": "Maharashtra"},
                        {"value": "mp", "label": "Madhya Pradesh"}
                    ]
                }
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Global Filter config added!"
    assert actual["data"]
    pytest.global_widget_id = actual["data"]
    assert actual["error_code"] == 0


def test_add_global_widget_config_duplicate_should_fail():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        json={
            "global_config": [
                {
                    "type": "dateRange",
                    "title": "Duplicate Date Range",
                    "initialStartDate": "2024-01-01",
                    "initialEndDate": "2024-06-30"
                }
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == f"A widget configuration already exists for bot '{pytest.bot}'."
    assert actual["error_code"] == 422


def test_get_global_widget_config():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert "global_config" in actual["data"]
    assert actual["data"]['global_config']["bot"] == pytest.bot
    assert actual["error_code"] == 0

def test_update_global_widget_config():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        json={
            "global_config": [
                {
                    "type": "categorical",
                    "title": "Updated Regions",
                    "name": "Region",
                    "options": [
                        {"value": "dl", "label": "Delhi"},
                        {"value": "mh", "label": "Maharashtra"}
                    ]
                }
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Global Filter config updated!"
    assert actual["error_code"] == 0

def test_delete_global_widget_config():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Global Filter config removed!"
    assert actual["error_code"] == 0

def test_update_global_widget_config_should_fail():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        json={
            "global_config": [
                {
                    "type": "categorical",
                    "title": "Regions",
                    "name": "Region",
                    "options": [
                        {"value": "dl", "label": "Delhi"},
                        {"value": "mh", "label": "Maharashtra"}
                    ]
                }
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == f"No global config found for bot '{pytest.bot}'."
    assert actual["error_code"] == 422

def test_delete_global_widget_config_should_pass_when_not_exist():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/widgets/global_filter_config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == f"No global config found for bot '{pytest.bot}'."


def test_get_client_config_with_nudge_server_url():
    expected_app_server_url = Utility.environment['app']['server_url']
    expected_nudge_server_url = Utility.environment['nudge']['server_url']
    expected_chat_server_url = Utility.environment['model']['agent']['url']

    response = client.get(f"/api/bot/{pytest.bot}/chat/client/config",
                          headers={"Authorization": pytest.token_type + " " + pytest.access_token})
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"]["welcomeMessage"] == 'Hello! How are you?'
    assert actual["data"]["name"] == 'kairon'
    assert actual["data"]["buttonType"] == 'button'
    assert actual["data"]["whitelist"] == ["*"]
    assert actual["data"]["nudge_server_url"] == expected_nudge_server_url
    assert actual["data"]["api_server_host_url"] == expected_app_server_url
    assert actual["data"]["chat_server_base_url"] == expected_chat_server_url



def test_get_llm_metadata():
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["gpt-3.5-turbo", "gpt-4.1-mini", "gpt-4.1"],
            "user": "123",
            "bot": pytest.bot,
            "timestamp": datetime.utcnow()
        },
    ]

    for secret in secrets:
        LLMSecret(**secret).save()

    response = client.get(
        url=f"/api/bot/{pytest.bot}/metadata/llm",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"] is True
    assert actual["message"] is None

    assert "data" in actual
    assert "openai" in actual["data"]
    assert "model" in actual["data"]["openai"]["properties"]
    assert actual["data"]["openai"]["properties"]["model"]["enum"] == ["gpt-3.5-turbo", "gpt-4.1-mini", "gpt-4.1"]

    assert "anthropic" in actual["data"]
    assert "model" in actual["data"]["anthropic"]["properties"]
    assert actual["data"]["anthropic"]["properties"]["model"]["enum"] == ["claude-3-7-sonnet-20250219"]


def test_get_llm_metadata_bot_specific_model_exists():

    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "bot": pytest.bot,
            "timestamp": datetime.utcnow()
        },
        {
            "llm_type": "anthropic",
            "api_key": "custom_claude_key",
            "models": ["common_claude_model1", "common_claude_model2", "custom_claude_model1"],
            "bot": pytest.bot,
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    response = client.get(
        url=f"/api/bot/{pytest.bot}/metadata/llm",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"] is True
    assert actual["message"] is None

    assert "data" in actual
    assert "openai" in actual["data"]
    assert "model" in actual["data"]["openai"]["properties"]
    assert actual["data"]["openai"]["properties"]["model"]["enum"] == ["common_openai_model1", "common_openai_model2"]

    assert "anthropic" in actual["data"]
    assert "model" in actual["data"]["anthropic"]["properties"]
    assert actual["data"]["anthropic"]["properties"]["model"]["enum"] == ["common_claude_model1", "common_claude_model2", "custom_claude_model1"]
    LLMSecret.objects.delete()


@responses.activate
@patch("kairon.shared.chat.processor.ChatDataProcessor.get_channel_config")
def test_get_instagram_user_posts(mock_get_config, monkeypatch):
    from kairon.shared.channels.instagram.processor import InstagramProcessor

    mock_get_config.return_value = {
        'bot': '689097feb37ee2678aedd0cd',
        'connector_type': 'instagram',
        'config': {
            'app_secret': 'cdb69bc72e2ccb7a869f20cbb6b0229a',
            'page_access_token': 'EAAGa50I7D7cBAJ4AmXOhYAeOOZAyJ9fxOclQmn52hBwrOJJWBOxuJNXqQ2uN667z4vLekSEqnCQf41hcxKVZAe2pAZBrZCTENEj1IBe1CHEcG7J33ZApED9Tj9hjO5tE13yckNa8lP3lw2IySFqeg6REJR3ZCJUvp2h03PQs4W5vNZBktWF3FjQYz5vMEXLPzAFIJcZApBtq9wZDZD',
            'verify_token': 'kairon-instagram-token',
            'is_dev': True,
            'post_config': {
                '17859719991451845': {
                    'keywords': ['offer', 'discount'],
                    'comment_reply': 'Grab our latest offers and discounts on shoes before they run out!'
                },
                '17859719991451973': {
                    'keywords': ['hi', 'price'],
                    'comment_reply': 'Hi there! Yes, we offer the best prices on premium quality shoes!'
                },
                '17859719991451321': {
                    'keywords': ['hello', 'offer']}}},
        'meta_config': {}
    }

    async def fake_get_user_media_posts(self):
        return {"data": [
            {
                "id": "17859719991451973",
                "ig_id": "3682168664448337756",
                "media_product_type": "FEED",
                "media_type": "IMAGE",
                "media_url": "https://scontent.cdninstagram.com/v/t39.30808-6/523122870_122185919582569325_790599521546845755_n.jpg?stp=dst-jpg_e35_tt6&_nc_cat=100&ccb=1-7&_nc_sid=18de74&_nc_ohc=7YYhBBUOvsQQ7kNvwESQCKD&_nc_oc=AdmaDolEqkLcifMAyuwYg70gHJNAeLHZqKBOWYTOtRCZ_PmWP7xruqnCsygI9ZPgPnU&_nc_zt=23&_nc_ht=scontent.cdninstagram.com&edm=AM6HXa8EAAAA&_nc_gid=MMqhUvMR4L69GkDMm6bQug&oh=00_AfSQcTvOKOFu0xqZYAMPAEe9r3sN3UKD0KhRvF39X1araA&oe=6887FF72",
                "timestamp": "2025-07-22T07:18:52+0000",
                "username": "maheshsv17",
                "permalink": "https://www.instagram.com/p/DMZsOQvhIdc/",
                "caption": "TEST",
                "like_count": 0,
                "comments_count": 0
            }
        ]}

    monkeypatch.setattr(InstagramProcessor, "get_user_media_posts", fake_get_user_media_posts)

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/user/posts",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"] is True
    assert actual["message"] is None
    assert actual['data'] == [
            {
                "id": "17859719991451973",
                "ig_id": "3682168664448337756",
                "media_product_type": "FEED",
                "media_type": "IMAGE",
                "media_url": "https://scontent.cdninstagram.com/v/t39.30808-6/523122870_122185919582569325_790599521546845755_n.jpg?stp=dst-jpg_e35_tt6&_nc_cat=100&ccb=1-7&_nc_sid=18de74&_nc_ohc=7YYhBBUOvsQQ7kNvwESQCKD&_nc_oc=AdmaDolEqkLcifMAyuwYg70gHJNAeLHZqKBOWYTOtRCZ_PmWP7xruqnCsygI9ZPgPnU&_nc_zt=23&_nc_ht=scontent.cdninstagram.com&edm=AM6HXa8EAAAA&_nc_gid=MMqhUvMR4L69GkDMm6bQug&oh=00_AfSQcTvOKOFu0xqZYAMPAEe9r3sN3UKD0KhRvF39X1araA&oe=6887FF72",
                "timestamp": "2025-07-22T07:18:52+0000",
                "username": "maheshsv17",
                "permalink": "https://www.instagram.com/p/DMZsOQvhIdc/",
                "caption": "TEST",
                "like_count": 0,
                "comments_count": 0
            }
        ]



@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_create_pipeline_event_cron(mock_event_server):

    data = {
        "bot": pytest.bot,
        "name": "callback_test",
        "pyscript_code": "print('Hello, World!')",
    }
    result = CallbackConfig.create_entry(**data)
    payload = {
        "pipeline_name": "daily_analytics_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "32 11 * * *",
            "timezone": "Asia/Kolkata"
        },
        "data_deletion_policy": [],
        "triggers": []
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Event scheduled!"
    assert "event_id" in actual["data"]
    pytest.analytics_event_id = actual["data"]["event_id"]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_create_pipeline_event_epoch(mock_event_server):
    future_epoch = int(time.time()) + 3600

    payload = {
        "pipeline_name": "one_time_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "epoch",
            "schedule": str(future_epoch),
            "timezone": "Asia/Kolkata"
        },
        "data_deletion_policy": [],
        "triggers": []
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Event scheduled!"
    assert "event_id" in actual["data"]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_create_pipeline_event_without_scheduler(mock_event_server):
    payload = {
        "pipeline_name": "instant_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "data_deletion_policy": [],
        "triggers": []
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Event scheduled!"
    assert "event_id" in actual["data"]

def test_create_pipeline_event_missing_pipeline_name():
    payload = {
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z"
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    assert data["message"][0]["loc"] == ["body", "pipeline_name"]
    assert data["message"][0]["msg"] == "field required"


def test_create_pipeline_event_missing_callback_name():
    payload = {
        "pipeline_name": "daily_pipeline",
        "timestamp": "2025-11-25T14:30:00Z"
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    data = response.json()
    assert data["message"][0]["loc"] == ["body", "callback_name"]
    assert data["message"][0]["msg"] == "field required"


def test_create_pipeline_event_invalid_expression_type():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "unknown",
            "schedule": "10 10 * * *",
            "timezone": "Asia/Kolkata"
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = response.json()
    assert response["error_code"] == 422
    errors = response["message"]
    assert any("expression_type must be either cron or epoch" in err["msg"] for err in errors)


def test_scheduler_config_missing_timezone():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "10 10 * * *",
            "timezone": ""
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("timezone is required for all schedules" in err["msg"] for err in data["message"])


def test_scheduler_config_missing_schedule():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "",
            "timezone": "Asia/Kolkata"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("schedule time is required for all schedules" in err["msg"] for err in data["message"])


def test_scheduler_config_invalid_cron_expression():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "invalid_cron",
            "timezone": "Asia/Kolkata"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("Invalid cron expression" in err["msg"] for err in data["message"])


def test_scheduler_config_cron_interval_too_small():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "* * * * *",
            "timezone": "Asia/Kolkata"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("Recurrence interval must be at least" in err["msg"] for err in data["message"])


def test_scheduler_config_epoch_invalid_integer():
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "epoch",
            "schedule": "invalid",
            "timezone": "Asia/Kolkata"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("schedule must be a valid integer epoch time" in err["msg"] for err in data["message"])


def test_scheduler_config_epoch_unknown_timezone():
    future_epoch = int(datetime.now().timestamp()) + 5000
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "epoch",
            "schedule": str(future_epoch),
            "timezone": "Invalid/XYZ"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("Unknown timezone" in err["msg"] for err in data["message"])


def test_scheduler_config_epoch_not_in_future():
    past_epoch = int(datetime.now().timestamp()) - 100
    payload = {
        "pipeline_name": "daily_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "epoch",
            "schedule": str(past_epoch),
            "timezone": "Asia/Kolkata"
        }
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    data = response.json()
    assert data["error_code"] == 422
    assert any("epoch time (schedule) must be in the future" in err["msg"] for err in data["message"])


def test_list_pipeline_events_success():
    response = client.get(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Events fetched"


def test_get_pipeline_event_success():
    response = client.get(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/{pytest.analytics_event_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Event retrieved"
    assert actual["data"]


def test_get_pipeline_event_not_found():
    response = client.get(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/invalid-id-123",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is False


@patch("kairon.shared.utils.Utility.execute_http_request", autospec=True)
def test_delete_pipeline_event_success(mock_http):
    mock_http.return_value = {"success": True}

    response = client.delete(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/{pytest.analytics_event_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Event deleted"
    mock_http.assert_called_once()



@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_delete_pipeline_event_failure(mock_event_server):
    mock_event_server.side_effect = Exception("Delete failure")
    response = client.delete(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/fake-id-123",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is False


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_update_pipeline_event_success(mock_event_server):
    payload = {
        "pipeline_name": "daily_analytics_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "32 11 * * *",
            "timezone": "Asia/Kolkata"
        },
        "data_deletion_policy": [],
        "triggers": []
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    pytest.analytics_event_id = actual["data"]["event_id"]

    payload = {
        "pipeline_name": "updated_pipeline",
        "callback_name": "callback_test",
        "timestamp": "2025-11-25T14:30:00Z",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "10 12 * * *",
            "timezone": "Asia/Kolkata"
        },
        "data_deletion_policy": [],
        "triggers": []
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/{pytest.analytics_event_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Event updated"
    assert actual["data"]["event_id"] == pytest.analytics_event_id


def test_update_pipeline_event_validation_error():
    payload = {
        "pipeline_name": "",
        "callback_name": "cb_test",
        "timestamp": "invalid-ts"
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/pipeline_analytics/events/{pytest.analytics_event_id}",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response['error_code'] == 422

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/callback/callback_test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()


def test_search_and_list_analytics_pipeline_logs():

    now = datetime.utcnow().replace(tzinfo=pytz.UTC)

    entries = [
        {
            "status": "Completed",
            "start_offset": 0,
            "end_offset": 2,
        },
        {
            "status": "Completed",
            "start_offset": -30,
            "end_offset": -27,
        },
        {
            "status": "Fail",
            "exception": "Execution error: Expecting value: line 1 column 1 (char 0)",
            "start_offset": -40,
            "end_offset": -38,
        },
        {
            "status": "Completed",
            "start_offset": -60,
            "end_offset": -57,
        },
    ]

    for e in entries:
        AnalyticsPipelineLogs(
            event_id="6938ff94e22b4ae6c225fa18",
            status=e["status"],
            pipeline_name="daily_analytics_pipeline",
            callback_name="callback_test",
            exception=e.get("exception"),
            bot=pytest.bot,
            user = "integration@demo.ai",
            start_timestamp=now + timedelta(minutes=e["start_offset"]),
            end_timestamp=now + timedelta(minutes=e["end_offset"]),
        ).save()


    list_resp = client.get(
        f"/api/bot/{pytest.bot}/logs/analytics_pipeline",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    list_data = list_resp.json()
    assert list_data["success"]
    assert list_data["error_code"] == 0
    assert list_data["data"]["total"] == 4
    assert len(list_data["data"]["logs"]) == 4

    for log in list_data["data"]["logs"]:
        assert log["event_id"]
        assert log["status"]
        assert log["pipeline_name"] == "daily_analytics_pipeline"
        assert log["callback_name"] == "callback_test"
        assert log.get("start_time") or log.get("start_timestamp")
        assert log.get("end_time") or log.get("end_timestamp")
        assert log["user"] == "integration@demo.ai"


    from_date = (now - timedelta(days=1)).date()
    to_date = (now + timedelta(days=1)).date()

    search_url = (
        f"/api/bot/{pytest.bot}/logs/analytics_pipeline/search"
        f"?from_date={from_date}&to_date={to_date}"
        f"&start_idx=0&page_size=10&pipeline_name=daily_analytics_pipeline"
    )

    search_resp = client.get(
        search_url,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    search_data = search_resp.json()
    assert search_data["success"]
    assert search_data["error_code"] == 0
    assert search_data["data"]["total"] == 4
    assert len(search_data["data"]["logs"]) == 4

    for log in search_data["data"]["logs"]:
        assert log["event_id"]
        assert log["status"]
        assert log["pipeline_name"] == "daily_analytics_pipeline"
        assert log["callback_name"] == "callback_test"
        assert log["start_timestamp"]
        assert log["end_timestamp"]
        assert log["user"] == "integration@demo.ai"
        if log["status"] == "Fail":
            assert "Execution error" in log["exception"]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_scheduled_broadcast_with_no_template_name(mock_event_server):
    config = {
        "name": "first_scheduler_dynamic",
        "broadcast_type": "dynamic",
        "connector_type": "whatsapp",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "21 11 * * *",
            "timezone": "Asia/Kolkata",
        },
        "pyscript": "send_msg('template_name', '9876543210')",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'template_name is required for dynamic broadcasts!', 'type': 'value_error'}]
    assert not actual["data"]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_scheduled_broadcast_with_no_language_code(mock_event_server):
    config = {
        "name": "first_scheduler_dynamic",
        "broadcast_type": "dynamic",
        "connector_type": "whatsapp",
        "template_name": "consent",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "21 11 * * *",
            "timezone": "Asia/Kolkata",
        },
        "pyscript": "send_msg('template_name', '9876543210')",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'language_code is required for dynamic broadcasts!', 'type': 'value_error'}]
    assert not actual["data"]


def test_logout():
    response = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@10"},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    access_token = actual["data"]["access_token"]
    token_type = actual["data"]["token_type"]
    response = client.post(
        url=f"/api/auth/logout",
        headers={"Authorization": token_type + " " + access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "User Logged out!"
    assert not actual["data"]
    assert actual["error_code"] == 0

    values = list(AuditLogData.objects(user="integration@demo.ai", action='activity', entity='logout').order_by(
        "-timestamp"))
    audit_log_data = values[0].to_mongo().to_dict()
    print(audit_log_data)
    assert audit_log_data["action"] == 'activity'
    assert audit_log_data['entity'] == 'logout'
    assert audit_log_data['user'] == 'integration@demo.ai'
    assert audit_log_data['data']['username'] == 'integration@demo.ai'

def test_payload_upload_api_with_float_field(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.cognition_collections_limit = 20
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()
    metadata = {
        "metadata": [{"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                     {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True}],
        "collection_name": "with_float_field",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload = {
        "data": {"item": "Box","price":54.02},
        "content_type": "json",
        "collection": "with_float_field"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.payload_id = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="with_float_field").first()
    assert cognition_data is not None
    data_dict = cognition_data.to_mongo().to_dict()
    assert data_dict['data']['item'] == 'Box'
    assert data_dict['data']['price'] == 54.02
    CognitionData.objects(bot=pytest.bot, collection="with_float_field").delete()
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()
    CognitionSchema.objects(bot=pytest.bot, collection_name="with_float_field").delete()

def test_payload_upload_api_with_float_field_value_integer(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 20
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()
    metadata = {
        "metadata": [{"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                     {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True}],
        "collection_name": "with_float_field_value_integer",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload = {
        "data": {"item": "Box","price":54},
        "content_type": "json",
        "collection": "with_float_field_value_integer"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.payload_id = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="with_float_field_value_integer").first()
    assert cognition_data is not None
    data_dict = cognition_data.to_mongo().to_dict()
    assert data_dict['data']['item'] == 'Box'
    assert isinstance(data_dict['data']['price'], float)
    assert data_dict['data']['price'] == 54.0
    CognitionData.objects(bot=pytest.bot, collection="with_float_field_value_integer").delete()
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()
    CognitionSchema.objects(bot=pytest.bot, collection_name="with_float_field_value_integer").delete()

def test_update_payload_upload_api_with_float_field_value_integer(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 20
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()
    metadata = {
        "metadata": [{"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                     {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True}],
        "collection_name": "update_with_float_field_value_integer",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    payload = {
        "data": {"item": "Box","price":54.08},
        "content_type": "json",
        "collection": "update_with_float_field_value_integer"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.payload_id = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="update_with_float_field_value_integer").first()
    assert cognition_data is not None
    data_dict = cognition_data.to_mongo().to_dict()
    assert data_dict['data']['item'] == 'Box'
    assert isinstance(data_dict['data']['price'], float)
    assert data_dict['data']['price'] == 54.08



    update_payload = {
        "data": {"item": "Box", "price": 27},
        "content_type": "json",
        "collection": "update_with_float_field_value_integer"
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.payload_id}",
        json=update_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Record updated!"
    assert actual["error_code"] == 0

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="update_with_float_field_value_integer").first()
    assert cognition_data is not None
    data_dict = cognition_data.to_mongo().to_dict()
    assert data_dict['data']['item'] == 'Box'
    assert isinstance(data_dict['data']['price'], float)
    assert data_dict['data']['price'] == 27.0
    CognitionData.objects(bot=pytest.bot, collection="update_with_float_field_value_integer").delete()
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()
    CognitionSchema.objects(bot=pytest.bot, collection_name="update_with_float_field_value_integer").delete()


@responses.activate
def test_default_values():
    response = client.get(
        "/api/system/default/names"
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    expected_default_names = [
        "restart", "back", "out_of_scope", "session_start", "nlu_fallback",
        "action_listen", "action_restart", "action_session_start", "action_default_fallback",
        "action_deactivate_loop", "action_revert_fallback_events", "action_default_ask_affirmation",
        "action_default_ask_rephrase", "action_two_stage_fallback", "action_unlikely_intent",
        "action_back", "...", "action_extract_slots",
        "requested_slot", "session_started_metadata", "knowledge_base_listed_objects",
        "knowledge_base_last_object", "knowledge_base_last_object_type"
    ]

    assert sorted(actual["data"]["default_names"]) == sorted(expected_default_names)

def test_odoo_registration():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.pos_enabled = True
    bot_settings.save()
    with patch("kairon.pos.definitions.factory.POSFactory.get_instance") as mock_factory:

        mock_pos = MagicMock()
        mock_pos.return_value.onboarding.return_value = {"ok": True}

        mock_factory.return_value = mock_pos

        payload = {
            "client_name": "XYZ_Pvt_Ltd"
        }


        response = client.post(
            url=f"/api/bot/{pytest.bot}/pos/odoo/register",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )

        actual = response.json()
        assert actual["success"]
        assert actual["data"] ==  {'ok': True}
        mock_factory.assert_called_once_with("odoo")
        mock_pos.return_value.onboarding.assert_called_once_with(
            client_name="XYZ_Pvt_Ltd",
            bot=pytest.bot,
            user='integration@demo.ai'
        )

def test_odoo_login():
    with patch("kairon.pos.definitions.factory.POSFactory.get_instance") as mock_factory:

        mock_pos = MagicMock()
        mock_pos.return_value.authenticate.return_value = {"ok": True}

        mock_factory.return_value = mock_pos

        payload = {
            "client_name": "XYZ_Pvt_Ltd",
            "page_type": "pos_products"
        }

        response = client.post(
            url=f"/api/bot/{pytest.bot}/pos/odoo/login",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )

        actual = response.json()
        assert actual ==  {'ok': True}
        mock_factory.assert_called_once_with("odoo")
        mock_pos.return_value.authenticate.assert_called_once_with(
            client_name="XYZ_Pvt_Ltd",
            page_type="pos_products",
            bot=pytest.bot
        )

def test_bulk_save_success():
    request_body = {
        "payload": [
            {
                "collection_name": "test_data",
                "is_secure": ["name"],
                "is_non_editable": ["email"],
                "data": {
                    "name": "Aniket",
                    "email": "aniket@example.com"
                }
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Bulk save completed"
    assert actual["success"]
    assert "data" in actual
    CollectionData.objects(collection_name="test_bulk_save_success").delete()


def test_bulk_save_with_missing_is_secure_key():
    request_body = {
        "payload": [
            {
                "collection_name": "user",
                "is_secure": ["name", "aadhar"],
                "data": {
                    "name": "Aniket",
                    "email": "aniket@example.com"
                }
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [{
        "loc": ["body", "payload", 0, "__root__"],
        "msg": "is_secure contains keys that are not present in data",
        "type": "value_error"
    }]
    assert not actual["success"]
    assert actual["data"] is None


def test_bulk_save_with_data_none():
    request_body = {
        "payload": [
            {
                "collection_name": "user",
                "is_secure": ["name"],
                "data": None
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["data"] is None

    error_messages = [msg["msg"] for msg in actual["message"]]
    assert "data cannot be empty and should be of type dict!" in error_messages
    assert "none is not an allowed value" in error_messages

def test_bulk_empty_payload():
    request_body = {
        "payload": [
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert not actual["success"]


    error_messages = [msg["msg"] for msg in actual["message"]]
    assert "payload must contain at least one item" in error_messages


def test_bulk_save_with_empty_collection_name():
    request_body = {
        "payload": [
            {
                "collection_name": "  ",
                "data": {"name": "Aniket"},
                "is_secure": [],
                "is_non_editable": []
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"][0]["msg"] == "collection_name should not be empty!"
    assert not actual["success"]
    assert actual["data"] is None


def test_bulk_save_with_non_editable_key_missing_in_data():
    request_body = {
        "payload": [
            {
                "collection_name": "user",
                "data": {
                    "name": "Aniket",
                },
                "is_secure": [],
                "is_non_editable": ["email"]
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"][0]["msg"] == "is_non_editable contains keys that are not present in data"
    assert not actual["success"]
    assert actual["data"] is None


def test_bulk_save_with_invalid_types():
    request_body = {
        "payload": [
            {
                "collection_name": "user",
                "data": {"name": "Aniket"},
                "is_secure": "name",
                "is_non_editable": []
            }
        ]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection/bulk/test_bulk_save_success",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    error_messages = [msg["msg"] for msg in actual["message"]]
    assert "is_secure should be list of keys!" in error_messages
    assert "value is not a valid list" in error_messages


@responses.activate
def test_upload_file_content_success():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.upload_file_handler}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "file_content": ("Salesstore.csv", open("tests/testing_data/file_content_upload/Salesstore.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/upload/collection_data/test_collection_data?overwrite=False",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "File content upload in progress! Check logs."
    assert actual["error_code"] == 0

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.upload_file_handler, upload_type="crud_data", collection_name="test_collection_data", overwrite=False
    )


    response = client.get(
        f"/api/bot/{pytest.bot}/logs/file_upload?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 1
    assert logs[0]['file_name'] == 'Salesstore.csv'
    assert logs[0]['status'] == STATUSES.SUCCESS.value
    assert logs[0]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert logs[0]['is_uploaded']
    assert logs[0]['start_timestamp'] is not None
    assert logs[0]['end_timestamp'] is not None
    assert logs[0]['upload_errors'] == {}
    assert logs[0]['exception'] == ''

    from_date = date.today()
    to_date = from_date + timedelta(days=1)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/file_upload/search"
        f"?from_date={from_date}&to_date={to_date}",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    response_json = search_response.json()
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    CollectionData.objects(collection_name="test_collection_data").delete()


@patch("kairon.api.app.routers.bot.data.UploadHandler")
def test_upload_file_content_no_enqueue_when_validate_false(mock_upload_handler):
    """Test that file upload does not enqueue event when validation fails."""

    mock_event_instance = MagicMock()
    mock_event_instance.validate.return_value = False
    mock_upload_handler.return_value = mock_event_instance

    files = {
        "file_content": ("Salesstore.csv", open("tests/testing_data/file_content_upload/Salesstore.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/upload/collection_data/test_collection?overwrite=true",
        files=files,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    actual = response.json()
    assert response.status_code == 200
    assert actual["success"] is True
    assert actual["message"] == "File content upload in progress! Check logs."
    assert actual["error_code"] == 0
    mock_event_instance.enqueue.assert_not_called()

def test_get_broadcast_filter_count():
    CollectionData(
        bot=pytest.bot,
        user="test_user_1",
        collection_name="crop_details_test",
        data={
            "name": "Mahesh",
            "mobile_number": "9876543000",
            "crop": "wheat",
            "status": "stage-1",
            "age": "26"
        }
    ).save()
    CollectionData(
        bot=pytest.bot,
        user="test_user_1",
        collection_name="crop_details_test",
        data={
            "name": "Ganesh",
            "mobile_number": "9876543001",
            "crop": "Paddy",
            "status": "stage-2",
            "age": "26"
        }
    ).save()
    CollectionData(
        bot=pytest.bot,
        user="test_user_1",
        collection_name="crop_details_test",
        data={
            "name": "Hitesh",
            "mobile_number": "9876543001",
            "crop": "Okra",
            "status": "stage-4",
            "age": "27"
        }
    ).save()
    CollectionData(
        bot=pytest.bot,
        user="test_user_1",
        collection_name="crop_details_test",
        data={
            "name": "Aniket",
            "mobile_number": "6203115367",
            "crop": "wheat",
            "status": "stage-3",
            "age": "27"
        }
    ).save()


    filters_list = [
        {"column": "age", "condition": "gte", "value": "26"},
        {"column": "name", "condition": "nin", "value": ["Mahesh"]},
    ]

    # API call
    response = client.get(
        f"/api/bot/{pytest.bot}/data/collections/crop_details_test/filter/count",
        params={"filters": json.dumps(filters_list)},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    # Response validation
    actual = response.json()
    assert response.status_code == 200
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Filtered count fetched successfully"
    assert actual["data"]["count"] == 3

def test_get_broadcast_filter_count_no_filter():
    response = client.get(
        f"/api/bot/{pytest.bot}/data/collections/crop_details_test/filter/count",
        params={"filters": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert response.status_code == 200
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Filtered count fetched successfully"
    assert actual["data"]["count"] == 4
    CollectionData.objects(bot = pytest.bot, collection_name = "crop_details_test").delete()

@pytest.mark.asyncio
@responses.activate
@patch("kairon.shared.chat.user_media.UserMedia.get_media_content_buffer")
def test_bsp_upload_media_success(mock_get_buffer):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "360dialog"
    bot_settings.save()

    Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    ).save()

    media_id = "0196c9efbf547b81a66ba2af7b72d5ba"
    bsp_type = "360dialog"
    expected_external_media_id = "abc123"

    UserMediaData(
        media_id=media_id,
        filename="Upload_Download Data.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="user",
        filesize=410484,
        sender_id="himanshu.gupta_@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="https://upload-doc-poc.s3.amazonaws.com/user_media/682323a603ec3be7dcaa75bc/himanshu.gt_digite.com_0196c9efbf547b81a66ba2af7b72d5ba_Upload_Download Data.pdf",
        output_filename="user_media/682323a603ec3be7dcaa75bc/himanshu.gupta_digite.com_0196c9efbf547b81a66ba2af7b72d5ba_Upload_Download Data.pdf",
    ).save()

    mock_get_buffer.return_value = (
        io.BytesIO(b"%PDF-1.4 mock content"),
        "Upload_Download Data.pdf",
        ".pdf"
    )

    responses.add(
        responses.POST,
        "https://waba-v2.360dialog.io/media",
        json={"id": expected_external_media_id},
        status=200,
        content_type="application/json"
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert response.status_code == 200
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["external_media_id"] == expected_external_media_id

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "meta"
    bot_settings.save()
    UserMediaData.objects().delete()
    Channels.objects().delete()

@pytest.mark.asyncio
def test_bsp_upload_media_media_id_not_found():
    media_id = "non_existing_media_id"
    bsp_type = "360dialog"

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert "UserMediaData not found for media_id: non_existing_media_id" in actual["message"]


@pytest.mark.asyncio
def test_bsp_upload_media_channel_not_configured():
    media_id = "non_existing_media_id"
    bsp_type = "360dialog"

    UserMediaData(
        media_id=media_id,
        filename="no_stream.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="user",
        filesize=410484,
        sender_id="test@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="some_url",
        output_filename="output_file.pdf",
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert f"Channel config not found for bot: {pytest.bot}, connector_type: whatsapp, bsp_type: {bsp_type}" in actual["message"]
    UserMediaData.objects().delete()


@pytest.mark.asyncio
def test_bsp_upload_media_access_token_not_found():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "360dialog"
    bot_settings.save()

    Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    ).save()

    media_id = "non_existing_media_id"
    bsp_type = "360dialog"

    UserMediaData(
        media_id=media_id,
        filename="no_stream.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="user",
        filesize=410484,
        sender_id="test@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="some_url",
        output_filename="output_file.pdf",
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert "API key (access token) not found in channel config" in actual["message"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "meta"
    bot_settings.save()
    UserMediaData.objects().delete()
    Channels.objects().delete()

@pytest.mark.asyncio
@patch("kairon.shared.chat.user_media.UserMedia.get_media_content_buffer")
def test_bsp_upload_media_no_file_stream(mock_get_buffer):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "360dialog"
    bot_settings.save()

    Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    ).save()

    media_id = "no_stream_media_id"
    bsp_type = "360dialog"

    UserMediaData(
        media_id=media_id,
        filename="no_stream.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="user",
        filesize=410484,
        sender_id="test@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="some_url",
        output_filename="output_file.pdf",
    ).save()

    mock_get_buffer.return_value = (None, "no_stream.pdf", ".pdf")

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert "File stream not found" in actual["message"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "meta"
    bot_settings.save()
    UserMediaData.objects().delete()
    Channels.objects().delete()


@pytest.mark.asyncio
@responses.activate
@patch("kairon.shared.chat.user_media.UserMedia.get_media_content_buffer")
def test_bsp_upload_media_360dialog_upload_failed(mock_get_buffer):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "360dialog"
    bot_settings.save()

    Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    ).save()
    media_id = "upload_fail_media"
    bsp_type = "360dialog"

    UserMediaData(
        media_id=media_id,
        filename="upload_fail.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="user",
        filesize=410484,
        sender_id="test@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="some_url",
        output_filename="output_file.pdf",
    ).save()

    mock_get_buffer.return_value = (
        io.BytesIO(b"%PDF mock"),
        "upload_fail.pdf",
        ".pdf"
    )

    responses.add(
        responses.POST,
        "https://waba-v2.360dialog.io/media",
        body="Failure Test Case Simulation",
        status=400,
        content_type="application/json"
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/media/upload/{bsp_type}/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert "Failure Test Case Simulation" in actual["message"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.whatsapp = "meta"
    bot_settings.save()
    UserMediaData.objects().delete()
    Channels.objects().delete()



from aioresponses import aioresponses as aioresponses_mock


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(ActionUtility, "execute_request_async", autospec=True)
@mock.patch.object(CognitionDataProcessor, "sync_data", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
def test_knowledge_vault_sync_push_menu(
    mock_collection_upsert,
    mock_create_collection,
    mock_collection_exists,
    mock_sync_data,
    mock_execute_request_async,
):
    # ---------------- CLEANUP ----------------
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()
    LLMSecret.objects.delete()

    # ---------------- BOT SETTINGS ----------------
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings["enable_faq"] = True
    bot_settings.save()

    # ---------------- MOCK COLLECTION ----------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None

    # ---------------- MOCK EMBEDDINGS ----------------
    mock_execute_request_async.return_value = (
        [[0.01] * LLMProcessor.__embedding__,
         [0.02] * LLMProcessor.__embedding__],
        200,
        0.01,
        None,
    )

    # ---------------- FORCE SYNC EXECUTION ----------------
    def sync_side_effect(*args, **kwargs):
        sync_data = kwargs["data"]
        bot = kwargs["bot"]
        collection = kwargs["collection"]

        for row in sync_data:
            CognitionData(
                data=row,
                content_type="json",
                collection=collection,
                user="integration@demo.ai",
                bot=bot,
                timestamp=datetime.utcnow(),
            ).save()

    mock_sync_data.side_effect = sync_side_effect

    # ---------------- LLM SECRET ----------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1"],
        user="123",
        timestamp=datetime.utcnow(),
    ).save()

    # ---------------- CREATE SCHEMA ----------------
    response = client.post(
        f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "collection_name": "groceries",
            "metadata": [
                {"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "quantity", "data_type": "int", "enable_search": True, "create_embeddings": True},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    assert response.json()["success"]

    # ---------------- SYNC REQUEST ----------------
    sync_data = [
        {"id": 1, "item": "Juice", "price": 2.50, "quantity": 10},
        {"id": 2, "item": "Apples", "price": 1.20, "quantity": 20},
    ]

    response = client.post(
        f"/api/bot/{pytest.bot}/data/cognition/sync"
        f"?primary_key_col=id&collection_name=groceries&sync_type=push_menu",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Processing completed successfully"

    # ---------------- ASSERT DB ----------------
    cognition_data = CognitionData.objects(bot=pytest.bot, collection="groceries")
    assert cognition_data.count() == 2

    for doc, expected in zip(cognition_data, sync_data):
        assert doc.data == expected


@pytest.mark.asyncio
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_knowledge_vault_sync_item_toggle(
        mock_embedding,
        mock_collection_exists,
        mock_create_collection,
        mock_collection_upsert
):
    from aioresponses import aioresponses as aioresponses_mock

    # Setup environment to fix Mock subscriptable error
    test_env = {"llm": {"url": "http://localhost:5057", "request_timeout": 30}}

    with patch.dict(Utility.environment, test_env), aioresponses_mock() as m:
        # --- 1. CLEANUP ---
        LLMSecret.objects.delete()
        CognitionData.objects(bot=pytest.bot).delete()
        CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()

        bot_settings = BotSettings.objects(bot=pytest.bot).get()
        bot_settings.llm_settings['enable_faq'] = True
        bot_settings.save()

        mock_collection_exists.return_value = False
        mock_create_collection.return_value = None
        mock_collection_upsert.return_value = None

        # --- 2. MOCK EMBEDDING SERVICE ---
        embedding_val = [0.1] * 1536
        m.post(re.compile(r'.*/aembedding/openai'), status=200, payload=[embedding_val, embedding_val])

        # --- 3. SEEDING SECRETS & SCHEMA ---
        [LLMSecret(llm_type="openai", api_key="common_openai_key", models=["text-embedding-3-large"],
                   user="123", timestamp=datetime.utcnow()).save()]

        client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition/schema",
            json={
                "metadata": [
                    {"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                    {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                    {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True},
                    {"column_name": "quantity", "data_type": "int", "enable_search": True, "create_embeddings": True},
                ],
                "collection_name": "groceries"
            },
            headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )

        # --- 4. SEED DUMMY DATA (VALIDATION FIX) ---
        # We set content_type to None and ensure data is a dict.
        # If this still fails, Kairon expects content_type="data" for dicts.
        dummy_payloads = [
            {"id": 1, "item": "Juice", "price": 2.80, "quantity": 56},
            {"id": 2, "item": "Milk", "price": 2.80, "quantity": 12}
        ]

        [CognitionData(
            data=p,
            collection="groceries",
            bot=pytest.bot,
            user="test@user.com",
            content_type="data"  # Explicitly setting to 'data' to match dict type
        ).save() for p in dummy_payloads]

        # --- 5. EXECUTE SYNC ---
        sync_data = [{"id": 1, "price": 80.50}, {"id": 2, "price": 27.00}]

        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=item_toggle",
            json=sync_data,
            headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )

        # --- 6. VERIFY ---
        actual = response.json()
        assert actual["success"] is True
        assert actual["message"] == "Processing completed successfully"

        results = CognitionData.objects(bot=pytest.bot, collection="groceries").order_by("data.id")
        expected_final = [
            {"id": 1, "item": "Juice", "price": 80.50, "quantity": 56},
            {"id": 2, "item": "Milk", "price": 27.00, "quantity": 12}
        ]

        assert results.count() == 2
        assert all(doc.to_mongo().to_dict()["data"] == exp for doc, exp in zip(list(results), expected_final))

        # --- 7. FINAL CLEANUP ---
        CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()
        LLMSecret.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_knowledge_vault_sync_sync_type_does_not_exist(mock_embedding):
    LLMSecret.objects.delete()
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(**{'data': [{'embedding': embedding}, {'embedding': embedding}]})

    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    sync_data = [
        {"id": 1, "item": "Juice", "price": 2.50, "quantity": 10},
        {"id": 2, "item": "Apples", "price": 1.20, "quantity": 20}
    ]

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=non_existent_sync_type",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Sync type does not exist"
    assert actual["error_code"] == 422

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="nonexistent_collection")
    assert cognition_data.count() == 0
    LLMSecret.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_knowledge_vault_sync_missing_collection(mock_embedding):
    LLMSecret.objects.delete()
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(**{'data': [{'embedding': embedding}, {'embedding': embedding}]})

    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    sync_data = [
        {"id": 1, "item": "Juice", "price": 2.50, "quantity": 10},
        {"id": 2, "item": "Apples", "price": 1.20, "quantity": 20}
    ]

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=nonexistent_collection&sync_type=push_menu",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Collection 'nonexistent_collection' does not exist."
    assert actual["error_code"] == 422

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="nonexistent_collection")
    assert cognition_data.count() == 0

    LLMSecret.objects.delete()

@pytest.mark.asyncio
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_knowledge_vault_sync_missing_primary_key(mock_embedding):
    from aioresponses import aioresponses as aioresponses_mock
    test_env = {"llm": {"url": "http://localhost:5057", "request_timeout": 30}}

    with patch.dict(Utility.environment, test_env), aioresponses_mock() as m:
        # --- CLEANUP ---
        LLMSecret.objects.delete()
        CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()
        CognitionData.objects(bot=pytest.bot, collection="groceries").delete()

        # --- SEEDING ---
        [LLMSecret(llm_type="openai", api_key="common_openai_key", models=["text-embedding-3-large"],
                   user="123", timestamp=datetime.utcnow()).save()]

        # Create Schema
        schema_response = client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition/schema",
            json={
                "metadata": [{"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                             {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True}],
                "collection_name": "groceries"
            },
            headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )
        assert schema_response.json()["message"] == "Schema saved!"

        # --- EXECUTE (Missing 'id') ---
        sync_data = [{"item": "Juice", "price": 2.50}, {"item": "Apples", "price": 1.20}]
        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=push_menu",
            json=sync_data,
            headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )

        actual = response.json()
        assert not actual["success"]
        assert actual["message"] == "Primary key 'id' must exist in each row."
        assert CognitionData.objects(bot=pytest.bot, collection="groceries").count() == 0

        # --- FINAL CLEANUP ---
        CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_knowledge_vault_sync_column_length_mismatch(mock_embedding):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(**{'data': [{'embedding': embedding}, {'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    schema_response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "quantity", "data_type": "int", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "groceries"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    assert schema_response.status_code == 200
    assert schema_response.json()["message"] == "Schema saved!"
    assert schema_response.json()["error_code"] == 0

    sync_data = [
        {"id": 1, "item": "Juice", "quantity": 10},
        {"id": 2, "item": "Apples", "quantity": 20}
    ]

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=push_menu",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Validation failed"
    assert actual["error_code"] == 400
    assert actual["data"] == {'1': [{'status': 'Column length mismatch', 'expected_columns': ['id', 'item', 'price', 'quantity'], 'actual_columns': ['id', 'item', 'quantity']}], '2': [{'status': 'Column length mismatch', 'expected_columns': ['id', 'item', 'price', 'quantity'], 'actual_columns': ['id', 'item', 'quantity']}]}
    cognition_data = CognitionData.objects(bot=pytest.bot, collection="groceries")
    assert cognition_data.count() == 0

    CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()
    LLMSecret.objects.delete()


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_knowledge_vault_sync_invalid_columns(mock_embedding):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(**{'data': [{'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    schema_response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "quantity", "data_type": "int", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "groceries"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    assert schema_response.status_code == 200
    assert schema_response.json()["message"] == "Schema saved!"
    assert schema_response.json()["error_code"] == 0

    dummy_data = {
        "id": 2,
        "item": "Milk",
        "price": 2.80,
        "quantity": 12
    }
    dummy_doc = CognitionData(
        data=dummy_data,
        content_type="json",
        collection="groceries",
        user="himanshu.gupta@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow()
    )
    dummy_doc.save()

    sync_data = [
        {"id": 2, "discount": 0.75}
    ]

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=item_toggle",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Validation failed"
    assert actual["error_code"] == 400
    assert actual["data"] == {'2': [{'status': 'Invalid columns in input data', 'expected_columns': ["id + any from ['item', 'price', 'quantity']"], 'actual_columns': ['id', 'discount']}]}

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="groceries")
    assert cognition_data.count() == 1
    expected_data = [
        {"id": 2, "item": "Milk", "price": 2.80, "quantity": 12}
    ]
    for index, doc in enumerate(cognition_data):
        doc_data = doc.to_mongo().to_dict()["data"]
        assert doc_data == expected_data[index]

    CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()
    CognitionData.objects(bot=pytest.bot, collection="groceries").delete()
    LLMSecret.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_knowledge_vault_sync_document_non_existence(mock_embedding):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(**{'data': [{'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        }
    ]
    for secret in secrets:
        LLMSecret(**secret).save()

    schema_response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "item", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "price", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "quantity", "data_type": "int", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "groceries"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    assert schema_response.status_code == 200
    assert schema_response.json()["message"] == "Schema saved!"
    assert schema_response.json()["error_code"] == 0

    dummy_data = {
        "id": 1,
        "item": "Juice",
        "price": 2.80,
        "quantity": 5
    }
    dummy_doc = CognitionData(
        data=dummy_data,
        content_type="json",
        collection="groceries",
        user="himanshu.gupta@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow()
    )
    dummy_doc.save()

    sync_data = [
        {"id": 2, "price": 27.0}
    ]

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/sync?primary_key_col=id&collection_name=groceries&sync_type=item_toggle",
        json=sync_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Validation failed"
    assert actual["error_code"] == 400
    assert actual["data"] == {'2': [{'status': 'Document does not exist', 'primary_key': 2, 'message': "No document found for 'id': 2"}]}
    cognition_data = CognitionData.objects(bot=pytest.bot, collection="groceries")
    assert cognition_data.count() == 1

    expected_data = [
        {
            "id": 1,
            "item": "Juice",
            "price": 2.80,
            "quantity": 5
        }
    ]

    for index, doc in enumerate(cognition_data):
        doc_data = doc.to_mongo().to_dict()["data"]
        assert doc_data == expected_data[index]

    CognitionSchema.objects(bot=pytest.bot, collection_name="groceries").delete()
    CognitionData.objects(bot=pytest.bot, collection="groceries").delete()
    LLMSecret.objects.delete()

@responses.activate
def test_fetch_metadata_for_logs_positive():
    """
    Positive test: Verify metadata for logs is fetched successfully.
    """
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/metadata",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    assert response.status_code == 200
    json_data = response.json()
    assert "data" in json_data
    assert "metadata" in json_data["data"]
    assert isinstance(json_data["data"]["metadata"], dict)
    assert len(json_data["data"]["metadata"]) > 0

@responses.activate
def test_upload_doc_content():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.content_importer_limit_per_day = 10
    bot_settings.cognition_collections_limit = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_doc_content_upload"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    dummy_data = {
        "order_id": "9999",
        "order_priority": "Low",
        "sales": "0.00",
        "profit": "0.00"
    }
    dummy_doc = CognitionData(
        data=dummy_data,
        content_type="json",
        collection="test_doc_content_upload",
        user="himanshu.gupta@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow()
    )
    dummy_doc.save()

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload")
    assert cognition_data.count() == 1

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_doc_content_upload&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.content_importer, table_name="test_doc_content_upload", overwrite=True
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/content?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 1
    assert logs[0]['file_received'] == 'Salesstore.csv'
    assert logs[0]['status'] == STATUSES.SUCCESS.value
    assert logs[0]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert logs[0]['is_data_uploaded']
    assert logs[0]['start_timestamp'] is not None
    assert logs[0]['end_timestamp'] is not None
    assert logs[0]['validation_errors'] == {}
    assert logs[0]['exception'] == ''

    from_date = date.today()
    to_date = from_date + timedelta(days=1)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/content/search"
        f"?from_date={from_date}&to_date={to_date}&status=Success",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    response_json = search_response.json()
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)

    cognition_data= CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload")

    assert cognition_data.count() == 20

    last_row = cognition_data.order_by('-_id').first()
    assert last_row["data"] == {
        'order_id': 67,
        'order_priority': 'Low',
        'sales': 12.34,
        'profit': 54.98
    }
    CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload").delete()

@responses.activate
def test_upload_doc_content_append():

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_doc_content_upload_append"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    dummy_data = {
        "order_id": "9999",
        "order_priority": "Low",
        "sales": "0.00",
        "profit": "0.00"
    }
    dummy_doc = CognitionData(
        data=dummy_data,
        content_type="json",
        collection="test_doc_content_upload_append",
        user="himanshu.gupta@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow()
    )
    dummy_doc.save()

    cognition_data = CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_append")
    assert cognition_data.count() == 1

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_doc_content_upload_append&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"] == True
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.content_importer, table_name="test_doc_content_upload_append"
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"] == True
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 2
    assert logs[0]['file_received'] == 'Salesstore.csv'
    assert logs[0]['status'] == STATUSES.SUCCESS.value
    assert logs[0]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert logs[0]['is_data_uploaded']
    assert logs[0]['start_timestamp'] is not None
    assert logs[0]['end_timestamp'] is not None
    assert logs[0]['validation_errors'] == {}
    assert logs[0]['exception'] == ''
    cognition_data = CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_append")
    assert cognition_data.count() == 21

    first_row = cognition_data.first()
    assert first_row["data"] == {
        "order_id": "9999",
        "order_priority": "Low",
        "sales": "0.00",
        "profit": "0.00"
    }
    last_row = cognition_data.order_by('-_id').first()
    assert last_row["data"] == {
        'order_id': 67,
        'order_priority': "Low",
        'sales': 12.34,
        'profit': 54.98
    }
    CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_append").delete()


@responses.activate
def test_upload_doc_content_basic_validation_failure():

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_doc_content_upload_basic_validation_failure"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore_data_with_basic_errors.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_doc_content_upload_basic_validation_failure&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 3
    assert 'validation_errors' in logs[0]
    validation_errors = logs[0]["validation_errors"]
    expected_errors = {
        "Header mismatch": "Expected headers ['order_id', 'order_priority', 'sales', 'profit'] but found ['order_id', 'order_priority', 'revenue', 'sales'].",
        "Missing columns": "{'profit'}.",
        "Extra columns": "{'revenue'}."
    }
    assert validation_errors == expected_errors
    assert logs[0]["status"] == STATUSES.FAIL.value
    assert logs[0]["event_status"] == EVENT_STATUS.COMPLETED.value

    CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_basic_validation_failure").delete()

@responses.activate
def test_download_error_csv_error_report_not_found():

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_download_error_csv_error_report_not_found"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_download_error_csv_error_report_not_found&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.content_importer, table_name="test_download_error_csv_error_report_not_found", overwrite=True
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    event_id = ContentImporterLogProcessor.get_event_id_for_latest_event(pytest.bot)

    response = client.get(
        f"/api/bot/{pytest.bot}/data/content/error-report/{event_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is False
    assert actual["error_code"] == 404
    assert actual["message"] == "Error Report not found"
    CognitionData.objects(bot=pytest.bot, collection="test_download_error_csv_error_report_not_found").delete()

@responses.activate
def test_upload_doc_content_datatype_validation_failure():

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_doc_content_upload_datatype_validation_failure"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore_data_with_datatype_errors.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_doc_content_upload_datatype_validation_failure&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0


    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.content_importer, table_name="test_doc_content_upload_datatype_validation_failure"
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 5
    assert 'validation_errors' in logs[0]
    validation_errors = logs[0]["validation_errors"]
    assert any(e['column_name'] == 'order_id' and e['status'] == 'Invalid DataType' for e in validation_errors['Row 4'])
    assert any(e['column_name'] == 'sales' and e['status'] == 'Required Field is Empty' for e in validation_errors['Row 4'])
    assert any(
        e['column_name'] == 'profit' and e['status'] == 'Required Field is Empty' for e in validation_errors['Row 6'])
    assert logs[0]["status"] == STATUSES.PARTIAL_SUCCESS.value
    assert logs[0]["event_status"] == EVENT_STATUS.COMPLETED.value

    cognition_data = list(CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_datatype_validation_failure"))
    assert len(cognition_data) == 18

    third_last_row = cognition_data[-3]
    assert third_last_row["data"] == {
        "order_id": 33,
        "order_priority": "Low",
        "sales": 905.94,
        "profit": -4.19
    }

    fourth_last_row = cognition_data[-4]
    assert fourth_last_row["data"] == {
        "order_id": 657,
        "order_priority": "Not Specified",
        "sales": 237.28,
        "profit": -2088.68
    }

    CognitionData.objects(bot=pytest.bot, collection="test_doc_content_upload_datatype_validation_failure").delete()

@responses.activate
def test_download_error_csv():

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_download_error_csv"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": ("Salesstore.csv", open("tests/testing_data/doc_content_upload/Salesstore_data_with_datatype_errors.csv", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_download_error_csv&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"] == True
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.content_importer, table_name="test_download_error_csv"
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] == True
    assert actual["error_code"] == 0

    event_id = ContentImporterLogProcessor.get_event_id_for_latest_event(pytest.bot)

    response = client.get(
        f"/api/bot/{pytest.bot}/data/content/error-report/{event_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    csv_content = response.text
    expected_csv_content = """order_id,order_priority,sales,profit,kairon_error_description
45.09,Not Specified,,-329.49,order_id: Invalid DataType; sales: Required Field is Empty
32,Medium,65.09,,profit: Required Field is Empty"""
    csv_content = csv_content.replace('\r\n', '\n')
    expected_csv_content = expected_csv_content.replace('\r\n', '\n')
    assert csv_content.strip() == expected_csv_content
    CognitionData.objects(bot=pytest.bot, collection="test_download_error_csv").delete()


@responses.activate
def test_upload_doc_content_file_type_validation_failure():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "order_id", "data_type": "int", "enable_search": True, "create_embeddings": True},
                {"column_name": "order_priority", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "sales", "data_type": "float", "enable_search": True, "create_embeddings": True},
                {"column_name": "profit", "data_type": "float", "enable_search": True, "create_embeddings": True},
            ],
            "collection_name": "test_doc_content_file_type_validation_failure"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.content_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    file = {
        "doc_content": (
        "test_wrong_file_type.pdf", open("tests/testing_data/doc_content_upload/test_wrong_file_type.pdf", "rb"))
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/content/upload?table_name=test_doc_content_file_type_validation_failure&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )

    actual = response.json()
    assert actual["success"] == True
    assert actual["message"] == "Document content upload in progress! Check logs."
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/content/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"] == True
    assert actual["error_code"] == 0
    logs = actual['data']['logs']
    assert len(logs) == 7
    assert 'validation_errors' in logs[0]
    validation_errors = logs[0]["validation_errors"]
    expected_errors = {
        'File type error': "Invalid file type: application/pdf. Please upload a CSV file."
    }
    assert validation_errors == expected_errors
    assert logs[0]["status"] == STATUSES.FAIL.value
    assert logs[0]["event_status"] == EVENT_STATUS.COMPLETED.value
    CognitionData.objects(bot=pytest.bot, collection="test_doc_content_file_type_validation_failure").delete()


@responses.activate
@patch("kairon.shared.chat.processor.ChatDataProcessor.validate_media_file_type")
@patch("kairon.shared.chat.processor.ChatDataProcessor.save_media_file_path")
@patch("kairon.shared.chat.processor.ChatDataProcessor.upload_media_to_bsp")
def test_upload_media_success(
        mock_upload_media,
        mock_save_validate,
        mock_validate,
):
    mock_validate.return_value = None
    mock_save_validate.return_value = (None, "/tmp/file.txt")
    mock_upload_media.return_value = {"media_id": "12345"}

    file_content = io.BytesIO(b"dummy file content")

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("test.txt", file_content, "text/plain")},
    )

    body = response.json()
    print(body)
    assert body["message"] == "File uploaded successfully!"
    assert body["data"]["media_id"] == "12345"


@responses.activate
@patch("kairon.shared.chat.processor.ChatDataProcessor.save_media_file_path")
@patch("kairon.shared.chat.processor.ChatDataProcessor.upload_media_to_bsp")
def test_upload_media_invalid_file_type(
        mock_upload_media,
        mock_save_validate,
):
    mock_save_validate.return_value = (None, "/tmp/file.py")
    mock_upload_media.return_value = {"media_id": "12345"}

    file_content = io.BytesIO(b"dummy file content")

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("test.py", file_content, "script")},
    )

    body = response.json()
    print(body)
    assert body['error_code'] == 422
    assert ("Invalid file type: script. Allowed types are: audio/aac, audio/amr, audio/mpeg,"
            " audio/mp4, audio/ogg, text/plain, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,"
            " application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-powerpoint,"
            " application/vnd.openxmlformats-officedocument.presentationml.presentation, application/pdf,"
            " image/jpeg, image/png, image/webp, video/3gpp, video/mp4.") in body["message"]


@responses.activate
@patch("kairon.shared.chat.processor.ChatDataProcessor.save_media_file_path")
@patch("kairon.shared.chat.processor.ChatDataProcessor.upload_media_to_bsp")
def test_upload_media_with_filename_missing(
        mock_upload_media,
        mock_save_validate,
):
    mock_save_validate.return_value = (None, "/tmp/file.py")
    mock_upload_media.return_value = {"media_id": "12345"}

    file_content = io.BytesIO(b"dummy file content")

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("", file_content, "script")},
    )

    body = response.json()
    print(body)
    assert body['error_code'] == 422
    assert ("Expected UploadFile, received: <class 'str'>") in body['message'][0]["msg"]


@responses.activate
def test_upload_media_no_file():
    response = (client.post
                (f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
                 headers={"Authorization": pytest.token_type + " " + pytest.access_token}))

    body = response.json()
    print(body)
    assert body['error_code'] == 422
    assert 'field required' in body["message"][0]['msg']


@responses.activate
@patch("kairon.shared.chat.processor.ChatDataProcessor.validate_media_file_type")
def test_upload_media_file_too_large(mock_validate):
    mock_validate.side_effect = AppException("File size exceeds 100MB")

    file_content = io.BytesIO(b"x" * (101 * 1024 * 1024))

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("large.pdf", file_content, "application/pdf")},
    )

    body = response.json()
    assert body['error_code'] == 422
    assert "File size exceeds 100MB" in body["message"]



@responses.activate
@patch("kairon.shared.chat.processor.Channels.objects")
def test_upload_media_channel_missing(mock_channels):
    mock_channels.return_value.exclude.return_value.get.side_effect = AppException("No channel found")

    file_content = io.BytesIO(b"dummy content")
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("file.pdf", file_content, "application/pdf")},
    )
    body = response.json()
    assert body["success"] is False
    assert "no channel" in body["message"].lower()
    assert body["error_code"] == 422

@responses.activate
@patch("kairon.shared.chat.processor.Channels.objects")
def test_upload_media_channel_other_exception(mock_channels):
    mock_channels.return_value.exclude.return_value.get.side_effect = Exception("some random error")

    file_content = io.BytesIO(b"dummy content")
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("file.pdf", file_content, "application/pdf")},
    )

    body = response.json()
    assert body["success"] is False
    assert body["error_code"] == 422
    assert "some random error" in body["message"].lower()

@responses.activate
@patch("kairon.shared.chat.user_media.UserMediaData.objects")
def test_upload_media_file_already_exists(mock_user_media):
    mock_user_media.return_value.count.return_value = 1

    file_content = io.BytesIO(b"dummy content")

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/upload/media_upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={"file_content": ("file.png", file_content, "image/png")},
    )

    body = response.json()
    assert body["success"] is False
    assert body["error_code"] == 422
    assert "file 'file.png' already exists" in body["message"].lower()
    mock_user_media.assert_called_once_with(bot=pytest.bot, filename="file.png")

@responses.activate
def test_get_media_ids():
    bot_settings = BotSettings.objects(bot=pytest.bot).first()
    bot_settings.whatsapp = "360dialog"
    bot_settings.save()
    if bot_settings:
        bot_settings_dict = bot_settings.to_mongo().to_dict()
        print(bot_settings_dict)

    channel = Channels.objects(bot=pytest.bot).first()
    if channel:
        channel = channel.to_mongo().to_dict()
        print(channel)
    Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    ).save()
    media_id = "0196c9efbf547b81a66ba2af7b72d5ba"

    UserMediaData(
        media_id=media_id,
        filename="Upload_Download Data.pdf",
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="broadcast",
        filesize=410484,
        sender_id="himanshu.gupta_@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="",
        output_filename="",
        external_upload_info={"bsp": "360dialog"}
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/data/fetch_media_ids",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    body = response.json()
    UserMediaData.objects().delete()
    Channels.objects().delete()
    assert body["data"][0]['media_id'] == media_id



@pytest.mark.django_db
@responses.activate
def test_delete_media_ids():
    bot = pytest.bot
    media_id = "715690454858053"
    channel_name = "whatsapp"

    with patch.dict(
        "kairon.shared.utils.Utility.environment",
        {"storage": {"whatsapp_media": {"bucket": "mock-bucket"}}},
        clear=False
    ), patch(
        "kairon.shared.cloud.utils.CloudUtility.delete_file"
    ) as mock_delete_file:
        mock_delete_file.return_value = None

        bot_settings = BotSettings.objects(bot=bot).first()
        if not bot_settings:
            bot_settings = BotSettings(bot=bot)
        bot_settings.whatsapp = "360dialog"
        bot_settings.save()

        Channels(
            bot=bot,
            connector_type=channel_name,
            config={
                "client_name": "dummy",
                "client_id": "dummy",
                "channel_id": "dummy",
                "api_key": "dummy_token",
                "partner_id": "dummy",
                "waba_account_id": "dummy",
                "bsp_type": "360dialog"
            },
            user="test@example.com",
            timestamp=datetime.utcnow()
        ).save()

        UserMediaData(
            media_id=media_id,
            filename="Upload_Download Data.pdf",
            extension=".pdf",
            upload_status=UserMediaUploadStatus.completed.value,
            upload_type="broadcast",
            filesize=410484,
            sender_id="himanshu.gupta_@digite.com",
            bot=bot,
            timestamp=datetime.utcnow(),
            media_url="",
            output_filename="mock_file.pdf",
            external_upload_info={"bsp": "360dialog"}
        ).save()

        responses.add(
            responses.DELETE,
            f"https://waba-v2.360dialog.io/{media_id}",
            json={"message": "Deleted Successfully"},
            status=200
        )

        response = client.delete(
            f"/api/bot/{bot}/data/{channel_name}/media/{media_id}",
            headers={"Authorization": pytest.token_type + " " + pytest.access_token}
        )

        body = response.json()
        UserMediaData.objects(bot=bot).delete()
        Channels.objects(bot=bot).delete()
        assert body["message"] == "Deleted Successfully"


@pytest.mark.django_db
def test_delete_media_ids_failure():
    bot = pytest.bot
    media_id = "non_existent_media"
    channel_name = "whatsapp"

    UserMediaData.objects(bot=bot).delete()
    Channels.objects(bot=bot).delete()

    response = client.delete(
        f"/api/bot/{bot}/data/{channel_name}/media/{media_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    body = response.json()

    assert body["success"] is False
    assert body["message"] == "Media deletion failed: No channel found for this bot. Please configure the channel first."
    assert body["data"] is None
    assert body["error_code"] == 422

@responses.activate
@patch("kairon.shared.cloud.utils.CloudUtility.get_s3_media_url")
def test_fetch_media_url(mock_get_s3):
    mock_get_s3.return_value = "https://mock-s3-url.com/Upload_Download_Data.pdf"

    bot_settings = BotSettings.objects(bot=pytest.bot).first()
    if bot_settings:
        bot_settings.whatsapp = "360dialog"
        bot_settings.save()

    Channels.objects(bot=pytest.bot).delete()
    channel_obj = Channels(
        bot=pytest.bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    )
    channel_obj.save()
    channel_name = channel_obj.connector_type

    filename = "Upload_Download Data.pdf"
    UserMediaData.objects().delete()
    UserMediaData(
        media_id="0196c9efbf547b81a66ba2af7b72d5ba",
        filename=filename,
        extension=".pdf",
        upload_status=UserMediaUploadStatus.completed.value,
        upload_type="broadcast",
        filesize=410484,
        sender_id="himanshu.gupta_@digite.com",
        bot=pytest.bot,
        timestamp=datetime.utcnow(),
        media_url="",
        output_filename="",
        external_upload_info={"bsp": "360dialog"}
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/data/fetch_media_url/{filename}",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )
    body = response.json()

    UserMediaData.objects().delete()
    Channels.objects().delete()

    assert body["success"] is True
    assert body["data"]["filename"] == filename
    assert body["data"]["media_url"] == "https://mock-s3-url.com/Upload_Download_Data.pdf"

def create_dummy_channel(bot):
    Channels.objects(bot=bot).delete()
    channel_obj = Channels(
        bot=bot,
        connector_type="whatsapp",
        config={
            "client_name": "dummy",
            "client_id": "dummy",
            "channel_id": "dummy",
            "api_key": "dummy_token",
            "partner_id": "dummy",
            "waba_account_id": "dummy",
            "bsp_type": "360dialog"
        },
        user="test@example.com",
        timestamp=datetime.utcnow()
    )
    channel_obj.save()
    return channel_obj.connector_type


@patch("kairon.shared.cloud.utils.CloudUtility.get_s3_media_url")
def test_fetch_media_url_file_not_exist(mock_get_s3):
    client = TestClient(app)
    channel_name = create_dummy_channel(pytest.bot)

    mock_get_s3.return_value = None

    missing_filename = "file_not_exist.pdf"

    response = client.get(
        f"/api/bot/{pytest.bot}/data/fetch_media_url/{missing_filename}",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )
    body = response.json()

    Channels.objects().delete()
    UserMediaData.objects().delete()

    assert body["success"] is True
    assert body["data"]["filename"] == missing_filename
    assert body["data"]["media_url"] is None or body["data"]["media_url"] == "None"
    assert "not found" in body["message"].lower() or "media" in body["message"].lower()

@responses.activate
def test_add_pos_integration_config_success():
    payload = {
      "connector_type": "petpooja",
      "config": {
        "restaurant_name": "restaurant1",
        "branch_name": "branch1",
        "restaurant_id": "98765"
       },
       "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
       },
       "smart_catalog_enabled": True,
       "meta_enabled": True,
       "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    provider_mapping = CatalogProviderMapping.objects(provider="petpooja").first()
    assert provider_mapping is not None
    assert provider_mapping.meta_mappings is not None
    assert provider_mapping.kv_mappings is not None

    pos_integration = POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").first()
    assert pos_integration is not None
    assert pos_integration.config["restaurant_id"] == "98765"
    assert pos_integration.meta_config["access_token"] == "dummy_access_token"

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").delete()


@responses.activate
def test_get_pos_endpoint_push_menu():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/petpooja/push_menu/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert "integration/petpooja/push_menu" in actual["data"]
    assert actual["message"] == "Endpoint fetched"
    assert actual["error_code"] == 0
    assert actual["success"]


@responses.activate
def test_get_pos_endpoint_item_toggle():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/petpooja/item_toggle/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    print(actual)
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert actual["message"] == "Endpoint fetched"
    assert actual["error_code"] == 0
    assert actual["success"]

@responses.activate
def test_list_pos_integration_configs_success():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/integrations",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["message"] == "POS Integration config fetched"
    assert actual["error_code"] == 0
    assert actual["success"] is True
    assert isinstance(actual["data"], list)

    petpooja_config = next((item for item in actual["data"] if item.get("provider") == "petpooja"), None)
    assert petpooja_config is not None

    assert petpooja_config["bot"] == str(pytest.bot)
    assert petpooja_config["provider"] == "petpooja"
    assert set(petpooja_config["sync_type"]) == {"push_menu", "item_toggle"}
    assert petpooja_config["config"]["restaurant_name"] == "restaurant1"
    assert petpooja_config["config"]["branch_name"] == "branch1"
    assert petpooja_config["config"]["restaurant_id"] == "98765"
    assert petpooja_config["meta_config"]["access_token"] == "dummy_access_token"
    assert petpooja_config["meta_config"]["catalog_id"] == "12345"

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja").delete()

@responses.activate
def test_list_pos_integration_configs_empty():
    """
    Test fetching POS integration configs when no configs exist for the bot.
    """

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/integrations",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["message"] == "POS Integration config fetched"
    assert actual["error_code"] == 0
    assert actual["success"] is True
    assert isinstance(actual["data"], list)
    assert actual["data"] == []

@responses.activate
def test_delete_pos_integration_config_success():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    assert POSIntegrations.objects(bot=pytest.bot, provider="petpooja").count() == 2

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/integrations?provider=petpooja&sync_type=push_menu",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"] is True
    assert actual["error_code"] == 0
    assert actual["message"] == "POS Integration config deleted"
    assert POSIntegrations.objects(bot=pytest.bot, provider="petpooja").count() == 1
    assert actual["data"]["provider"] == "petpooja"
    assert actual["data"]["sync_type"] == "push_menu"
    assert actual["data"]["deleted_count"] == 1
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja").delete()

@responses.activate
def test_delete_pos_integration_config_no_sync_type_provided_success():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    payload = {
      "connector_type": "petpooja",
      "config": {
        "restaurant_name": "restaurant1",
        "branch_name": "branch1",
        "restaurant_id": "98765"
       },
       "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
       },
       "smart_catalog_enabled": True,
       "meta_enabled": True,
       "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert str(pytest.bot) in actual["data"]

    assert POSIntegrations.objects(bot=pytest.bot, provider="petpooja").count() == 2

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/integrations?provider=petpooja",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"] is True
    assert actual["error_code"] == 0
    assert actual["message"] == "POS Integration config deleted"
    assert POSIntegrations.objects(bot=pytest.bot, provider="petpooja").count() == 0
    assert actual["data"]["provider"] == "petpooja"
    assert actual["data"]["deleted_count"] == 2
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja").delete()

@responses.activate
def test_delete_pos_integration_config_not_found():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/integrations?provider=invalid_provider&sync_type=invalid_sync",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"] is False
    assert actual["message"] == "Integration config not found"
    assert actual["error_code"] == 422

@responses.activate
def test_get_pos_params():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/pos/params",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert response.status_code == 200
    assert actual["success"] is True
    assert actual["message"] is None
    assert actual["error_code"] == 0

    assert "petpooja" in actual["data"]
    petpooja_data = actual["data"]["petpooja"]

    assert "required_fields" in petpooja_data
    assert petpooja_data["required_fields"] == ['restaurant_name', 'branch_name', 'restaurant_id', {'sync_type': ['push_menu', 'item_toggle']} ]

    assert "optional_fields" in petpooja_data
    assert petpooja_data["optional_fields"] == ['process_push_menu', 'process_item_toggle', 'meta_enabled',  'smart_catalog_enabled', 'access_token', 'catalog_id']

    assert "disabled_fields" in petpooja_data
    assert petpooja_data["disabled_fields"] == ["provider"]


@responses.activate
def test_add_pos_integration_config_invalid_provider():
    payload = {
        "connector_type": "invalid_provider",
        "config": {
            "restaurant_name": "invalid",
            "branch_name": "invalid",
            "restaurant_id": "00000",
        },
        "meta_config": {
            "access_token": "invalid",
            "catalog_id": "000"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["message"] == "Invalid Provider"
    assert actual["error_code"] == 422
    assert not actual["success"]

    CatalogProviderMapping.objects(provider="invalid_provider").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="invalid_provider", sync_type="push_menu").delete()


@responses.activate
def test_add_pos_integration_config_invalid_sync_type():
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=invalid_sync",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["message"] == "Sync type does not exist"
    assert actual["error_code"] == 422
    assert not actual["success"]

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="invalid_sync").delete()


@pytest.mark.asyncio
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_catalog_sync_push_menu_success(
        mock_embedding, mock_collection_exists, mock_create_collection,
        mock_collection_upsert, mock_format_and_send_mail,
        mock_delete_meta_catalog, mock_push_meta_catalog
):
    from aioresponses import aioresponses as aioresponses_mock

    # 1. Environment Patch (Fixes KeyError: 'audit_logs')
    audit_cfg = {"retention": 365, "attributes": ["account", "bot"]}
    test_env = {
        "llm": {"url": "http://localhost:5057", "request_timeout": 30},
        "events": {"server_url": "http://localhost:5056", "audit_logs": audit_cfg},
        "audit_logs": audit_cfg,
        "action": {"request_timeout": 60}
    }

    with patch.dict(Utility.environment, test_env), aioresponses_mock() as m:
        # --- CLEANUP ---
        CatalogSyncLogs.objects.delete()
        POSIntegrations.objects(bot=pytest.bot).delete()
        LLMSecret.objects.delete()
        CognitionData.objects(bot=pytest.bot).delete()

        # --- MOCK SETUP ---
        mock_collection_exists.return_value = False
        mock_create_collection.return_value = None
        mock_collection_upsert.return_value = None

        embedding_val = [0.1] * 1536
        mock_embedding.return_value = litellm.EmbeddingResponse(
            **{'data': [{'embedding': embedding_val}] * 10})

        m.post(re.compile(r'.*/api/events/execute/.*'), status=200, payload={"success": True})
        m.post(re.compile(r'.*/aembedding/openai'), status=200, payload=[embedding_val] * 10)

        # Seed Secret
        [LLMSecret(llm_type="openai", api_key="key", models=["text-embedding-3-large"],
                   user="123", timestamp=datetime.utcnow()).save()]

        # --- EXECUTE ---
        payload = {
            "connector_type": "petpooja",
            "config": {"restaurant_name": "r1", "branch_name": "b1", "restaurant_id": "98765"},
            "meta_config": {"access_token": "token", "catalog_id": "12345"},
            "smart_catalog_enabled": True, "meta_enabled": True,
            "sync_options": {"process_push_menu": True, "process_item_toggle": True}
        }

        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
            json=payload, headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )
        sync_url = response.json()["data"]
        token = sync_url.split(str(pytest.bot) + "/")[1]

        # Seed Images
        restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
        CollectionData(
            collection_name=f"{restaurant_name}_{branch_name}_catalog_images",
            data={"image_type": "global", "image_url": "http://img.com", "image_base64": ""},
            user="i@demo.ai", bot=pytest.bot, status=True, timestamp=datetime.utcnow()
        ).save()

        # Trigger Sync
        push_menu_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json")
        with push_menu_payload_path.open("r", encoding="utf-8") as f:
            push_menu_payload = json.load(f)

        client.post(url=sync_url, json=push_menu_payload,
                    headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"})

        latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
        sync_ref_id = str(latest_log.id)

        # --- EXECUTE EVENT (Fixes RuntimeError) ---
        await asyncio.to_thread(
            complete_end_to_end_event_execution,
            pytest.bot, "i@demo.ai", EventClass.catalog_integration,
            sync_type="push_menu", token=token, provider="petpooja", sync_ref_id=sync_ref_id
        )

        # --- VERIFY (Updated Statuses) ---
        latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()

        # CHANGED: These now match your actual processor's final success state
        assert latest_log.sync_status == EVENT_STATUS.COMPLETED.value
        assert latest_log.status == STATUSES.SUCCESS.value
        assert latest_log.exception == ""

        # --- FINAL CLEANUP ---
        CatalogSyncLogs.objects.delete()
        POSIntegrations.objects(bot=pytest.bot).delete()


def test_get_catalog_sync_logs():
    # --- 1. SEED DATA (Fixes ValidationError by adding 'user') ---
    # We clear any existing logs first to ensure a predictable test state
    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()

    log_entry = CatalogSyncLogs(
        bot=str(pytest.bot),
        user="integration@demo.ai",  # ADDED: Mandatory field
        execution_id="test_exec_123",
        raw_payload={"test": "data"},
        start_timestamp=datetime.utcnow(),
        end_timestamp=datetime.utcnow(),
        validation_errors={},
        provider="petpooja",
        sync_type="push_menu",
        status=STATUSES.SUCCESS.value,
        sync_status=EVENT_STATUS.COMPLETED.value
    ).save()

    # --- 2. EXECUTE GET ---
    # Testing both endpoints as per your original test structure
    client.get(
        f"/api/bot/{pytest.bot}/catalog/logs?start_idx=0&page_size=10",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/catalog?start_idx=0&page_size=10",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    actual = response.json()
    assert actual["success"] is True

    # Verify the log exists
    logs = actual['data']['logs']
    assert len(logs) > 0, "No logs found in API response"
    log = logs[0]

    # --- 3. VERIFY DATA ---
    assert log['execution_id'] == "test_exec_123"
    assert isinstance(log['raw_payload'], dict)
    assert log['start_timestamp']
    assert log['end_timestamp']
    assert log['validation_errors'] == {}
    assert log['provider'] == 'petpooja'
    assert log['sync_type'] == 'push_menu'
    assert log['status'] == STATUSES.SUCCESS.value
    assert log['sync_status'] == EVENT_STATUS.COMPLETED.value

    # --- 4. VERIFY SEARCH ---
    # Using date objects for the search parameters
    from_date = date.today()
    to_date = from_date + timedelta(days=1)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/catalog/search?from_date={from_date}&to_date={to_date}&sync_status=Completed",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    response_json = search_response.json()
    assert response_json["success"] is True
    assert response_json["error_code"] == 0
    assert len(response_json["data"]["logs"]) > 0
    assert response_json["data"]["logs"][0]["execution_id"] == "test_exec_123"

    # --- 5. CLEANUP ---
    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()


@pytest.mark.asyncio
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(LLMProcessor, "__delete_collection_points__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_catalog_sync_push_menu_success_with_delete_data(
        mock_embedding, mock_collection_exists, mock_create_collection,
        mock_collection_upsert, mock_format_and_send_mail, mock_delete_collection_points,
        mock_delete_meta_catalog, mock_push_meta_catalog
):
    from aioresponses import aioresponses as aioresponses_mock

    # 1. Environment Patch (Fixes KeyError: 'audit_logs')
    audit_cfg = {"retention": 365, "attributes": ["account", "bot"]}
    test_env = {
        "llm": {"url": "http://localhost:5057", "request_timeout": 30},
        "events": {"server_url": "http://localhost:5056", "audit_logs": audit_cfg},
        "audit_logs": audit_cfg
    }

    with mock.patch.dict(Utility.environment, test_env), aioresponses_mock() as m:
        # --- 2. CLEANUP ---
        bot_id_str = str(pytest.bot)
        CatalogSyncLogs.objects(bot=bot_id_str).delete()
        POSIntegrations.objects(bot__in=[bot_id_str, pytest.bot]).delete()
        LLMSecret.objects.delete()
        CognitionData.objects(bot=bot_id_str).delete()
        CollectionData.objects(bot=pytest.bot).delete()

        # --- 3. MOCK RETURNS ---
        mock_collection_exists.return_value = False
        mock_embedding.return_value = litellm.EmbeddingResponse(
            **{'data': [{'embedding': [0.1] * 1536}] * 10}
        )
        m.post(re.compile(r'.*/api/events/execute/.*'), status=200, payload={"success": True})

        # --- 4. SEED DATA ---
        LLMSecret(llm_type="openai", api_key="test", user="integration@demo.ai", timestamp=datetime.utcnow()).save()

        # Seed Global Fallback Image (Crucial for the logic inside the event)
        res_name, br_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
        CollectionData(
            collection_name=f"{res_name}_{br_name}_catalog_images",
            data={"image_type": "global", "image_url": "http://image.com/fallback.png", "image_base64": ""},
            user="integration@demo.ai", bot=pytest.bot, status=True, timestamp=datetime.utcnow()
        ).save()

        # --- 5. SEED POS INTEGRATION MANUALLY (The Fix for 'No POS integration config') ---
        config_data = {"restaurant_name": "restaurant1", "branch_name": "branch1", "restaurant_id": "98765"}
        meta_data = {"access_token": "token", "catalog_id": "12345"}
        sync_opts = {"process_push_menu": True, "process_item_toggle": True}

        # We seed for both "petpooja" and "Petpooja" to handle case sensitivity
        # And we use bot_id_str to match the background worker's retrieval logic
        for p_name in ["petpooja", "Petpooja"]:
            POSIntegrations(
                bot=bot_id_str,
                provider=p_name,
                sync_type="push_menu",
                config=config_data,
                meta_config=meta_data,
                sync_options=sync_opts,
                user="integration@demo.ai",
                timestamp=datetime.utcnow()
            ).save()

        # --- 6. TRIGGER VIA API ---
        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
            json={
                "connector_type": "petpooja", "config": config_data, "meta_config": meta_data,
                "smart_catalog_enabled": True, "meta_enabled": True, "sync_options": sync_opts
            },
            headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
        )
        sync_url = response.json()["data"]
        token = sync_url.split(f"{bot_id_str}/")[1]

        # Trigger Sync Request
        file_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload_with_delete_data.json")
        with file_path.open("r", encoding="utf-8") as f:
            push_menu_payload = json.load(f)

        client.post(url=sync_url, json=push_menu_payload,
                    headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"})

        log = CatalogSyncLogs.objects(bot=bot_id_str).order_by("-start_timestamp").first()
        sync_ref_id = str(log.id)

        # --- 7. RUN BACKGROUND EVENT ---
        await asyncio.to_thread(
            complete_end_to_end_event_execution,
            pytest.bot, "integration@demo.ai", EventClass.catalog_integration,
            sync_type="push_menu", token=token, provider="petpooja", sync_ref_id=sync_ref_id
        )

        # --- 8. VERIFY ---
        latest_log = CatalogSyncLogs.objects(bot=bot_id_str).order_by("-start_timestamp").first()
        assert latest_log.exception == "", f"Sync failed with error: {latest_log.exception}"
        assert latest_log.status == STATUSES.SUCCESS.value

        CatalogSyncLogs.objects.delete()
        

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "update_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_item_toggle_success(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_update_meta_catalog
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_update_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}, {"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["success"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENT MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add("POST", event_url, json={"success": True})

    # -------------------- PAYLOAD --------------------
    with open(
        "tests/testing_data/catalog_sync/catalog_sync_item_toggle_payload.json",
        "r",
        encoding="utf-8"
    ) as f:
        item_toggle_payload = json.load(f)

    # -------------------- TRIGGER SYNC --------------------
    response = client.post(
        sync_url,
        json=item_toggle_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["success"]
    assert actual["error_code"] == 0

    # -------------------- COMPLETE EVENT --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="item_toggle",
        token=token,
        provider="petpooja",
        sync_ref_id=str(latest_log.id)
    )

    # --------------------  CORRECT FINAL ASSERTS --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()

    assert latest_log.sync_status == EVENT_STATUS.COMPLETED.value
    assert latest_log.status == STATUSES.SUCCESS.value
    assert latest_log.exception == ""

    # -------------------- DATA ASSERT --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"

    docs = CollectionData.objects(collection_name=catalog_data_collection, bot=pytest.bot)
    summaries = [
        {"id": d.data["kv"]["id"], "availability": d.data["kv"]["availability"]}
        for d in docs
    ]

    expected = [
        {"id": "10539699", "availability": "in stock"},
        {"id": "10539580", "availability": "out of stock"},
    ]

    assert all(item in summaries for item in expected)

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_catalog_sync_push_menu_process_push_menu_disabled(mock_embedding, mock_collection_exists,
                                                                 mock_create_collection,
                                                                 mock_collection_upsert, mock_format_and_send_mail,
                                                                 mock_delete_meta_catalog, mock_push_meta_catalog):
    # Environment Setup to avoid KeyError: 'audit_logs'
    audit_cfg = {"retention": 365, "attributes": ["account", "bot"]}
    test_env = {
        "llm": {"url": "http://localhost:5057", "request_timeout": 30},
        "events": {"server_url": "http://localhost:5056", "audit_logs": audit_cfg},
        "audit_logs": audit_cfg
    }

    with patch.dict(Utility.environment, test_env):
        # --- MANDATORY CLEANUP (Prevents leaked data from Success test) ---
        LLMSecret.objects.delete()
        CatalogSyncLogs.objects.delete()
        CognitionData.objects(bot=str(pytest.bot)).delete()
        CognitionSchema.objects(bot=pytest.bot).delete()
        POSIntegrations.objects(bot=pytest.bot).delete()

        mock_collection_exists.return_value = False
        mock_create_collection.return_value = None
        mock_collection_upsert.return_value = None
        mock_format_and_send_mail.return_value = None
        mock_push_meta_catalog.return_value = None
        mock_delete_meta_catalog.return_value = None

        embedding = [0.1] * 1536
        mock_embedding.return_value = litellm.EmbeddingResponse(
            **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

        [LLMSecret(
            llm_type="openai", api_key="common_openai_key",
            models=["common_openai_model1", "common_openai_model2"],
            user="123", timestamp=datetime.utcnow()
        ).save()]

        payload = {
            "connector_type": "petpooja",
            "config": {"restaurant_name": "restaurant1", "branch_name": "branch1", "restaurant_id": "98765"},
            "meta_config": {"access_token": "dummy_access_token", "catalog_id": "12345"},
            "smart_catalog_enabled": False, "meta_enabled": False,
            "sync_options": {"process_push_menu": False, "process_item_toggle": False}
        }

        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token}
        )
        actual = response.json()
        sync_url = actual["data"]

        event_url = urljoin(Utility.environment["events"]["server_url"],
                            f"/api/events/execute/{EventClass.catalog_integration}")
        responses.add("POST", event_url, json={"success": True, "message": "Event triggered successfully!"})

        push_menu_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json")
        with push_menu_payload_path.open("r", encoding="utf-8") as f:
            push_menu_payload = json.load(f)

        response = client.post(
            url=sync_url, json=push_menu_payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token}
        )

        actual = response.json()
        assert actual["message"] == "Push menu processing is disabled for this bot"
        assert actual["error_code"] == 422

        # Verify count is 0 (Cleanup at start ensures this passes)
        assert CognitionData.objects(bot=str(pytest.bot)).count() == 0

        # --- FINAL CLEANUP ---
        CatalogSyncLogs.objects.delete()
        CognitionData.objects(bot=pytest.bot).delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "update_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
async def test_catalog_sync_item_toggle_process_item_toggle_disabled(mock_embedding, mock_collection_exists,
                                                                     mock_create_collection,
                                                                     mock_collection_upsert, mock_format_and_send_mail,
                                                                     update_meta_catalog):
    audit_cfg = {"retention": 365, "attributes": ["account", "bot"]}
    test_env = {
        "llm": {"url": "http://localhost:5057", "request_timeout": 30},
        "events": {"server_url": "http://localhost:5056", "audit_logs": audit_cfg},
        "audit_logs": audit_cfg
    }

    with patch.dict(Utility.environment, test_env):
        # --- MANDATORY CLEANUP ---
        LLMSecret.objects.delete()
        CatalogSyncLogs.objects.delete()
        CognitionData.objects(bot=str(pytest.bot)).delete()
        CognitionSchema.objects(bot=pytest.bot).delete()
        POSIntegrations.objects(bot=pytest.bot).delete()

        mock_collection_exists.return_value = False
        embedding = [0.1] * 1536
        mock_embedding.return_value = litellm.EmbeddingResponse(
            **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

        [LLMSecret(
            llm_type="openai", api_key="common_openai_key",
            models=["common_openai_model1", "common_openai_model2"],
            user="123", timestamp=datetime.utcnow()
        ).save()]

        payload = {
            "connector_type": "petpooja",
            "config": {"restaurant_name": "restaurant1", "branch_name": "branch1", "restaurant_id": "98765"},
            "meta_config": {"access_token": "dummy_access_token", "catalog_id": "12345"},
            "smart_catalog_enabled": False, "meta_enabled": False,
            "sync_options": {"process_push_menu": False, "process_item_toggle": False}
        }

        response = client.post(
            url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
            json=payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token}
        )
        sync_url = response.json()["data"]

        event_url = urljoin(Utility.environment["events"]["server_url"],
                            f"/api/events/execute/{EventClass.catalog_integration}")
        responses.add("POST", event_url, json={"success": True, "message": "Event triggered successfully!"})

        item_toggle_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_item_toggle_payload.json")
        with item_toggle_payload_path.open("r", encoding="utf-8") as f:
            item_toggle_payload = json.load(f)

        response = client.post(
            url=sync_url, json=item_toggle_payload,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token}
        )

        actual = response.json()
        assert actual["message"] == "Item toggle is disabled for this bot"
        assert actual["error_code"] == 422

        assert CognitionData.objects(bot=str(pytest.bot)).count() == 0

        # --- FINAL CLEANUP ---
        CatalogSyncLogs.objects.delete()
        CognitionData.objects(bot=pytest.bot).delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility,"format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_smart_catalog_disabled_meta_disabled(mock_embedding, mock_collection_exists, mock_create_collection,
                                        mock_collection_upsert, mock_format_and_send_mail, mock_delete_meta_catalog, mock_push_meta_catalog):
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        },
    ]

    for secret in secrets:
        LLMSecret(**secret).save()

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": False,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    provider_mapping = CatalogProviderMapping.objects(provider="petpooja").first()
    assert provider_mapping is not None
    assert provider_mapping.meta_mappings is not None
    assert provider_mapping.kv_mappings is not None

    pos_integration = POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").first()
    assert pos_integration is not None
    assert pos_integration.config["restaurant_id"] == "98765"
    assert pos_integration.meta_config["access_token"] == "dummy_access_token"

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"
    fallback_data = {
        "image_type": "global",
        "image_url": "https://picsum.photos/id/237/200/300",
        "image_base64": ""
    }
    CollectionData(
        collection_name=catalog_images_collection,
        data=fallback_data,
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    push_menu_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json")

    with push_menu_payload_path.open("r", encoding="utf-8") as f:
        push_menu_payload = json.load(f)

    response = client.post(
        url=sync_url,
        json=push_menu_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.catalog_integration, sync_type="push_menu", token=token,
        provider="petpooja", sync_ref_id = sync_ref_id
    )

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None
    assert latest_log.execution_id
    assert latest_log.sync_status == EVENT_STATUS.COMPLETED.value
    assert latest_log.status == STATUSES.SUCCESS.value
    assert hasattr(latest_log, "exception")
    assert latest_log.exception == "Sync to knowledge vault and Meta is not allowed for this bot. Contact Support!!"

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    catalog_data_docs = CollectionData.objects(collection_name=catalog_data_collection, bot=pytest.bot)
    catalog_item_summaries = [
        {"id": doc.data["kv"]["id"], "price": doc.data["kv"]["price"]}
        for doc in catalog_data_docs
    ]

    expected_items = [
        {"id": "10539634", "price": 8700.0},
        {"id": "10539699", "price": 3426.0},
        {"id": "10539580", "price": 3159.0},
    ]

    assert all(item in catalog_item_summaries for item in expected_items)

    cognition_data_docs = CognitionData.objects(bot=str(pytest.bot))
    assert cognition_data_docs.count() == 0

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").delete()
    LLMSecret.objects.delete()
    # CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()



@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility,"format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "update_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_item_toggle_smart_catalog_disabled_meta_disabled(mock_embedding, mock_collection_exists, mock_create_collection,
                                        mock_collection_upsert, mock_format_and_send_mail, mock_update_meta_catalog):
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_update_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        },
    ]

    documents = [
        {
            '_id': ObjectId('68777e450cbc4ce07e8a814e'),
            'vector_id': '468c609c-1313-4e47-8629-e26c20bf0e1b',
            'data': {
                'id': '10539580',
                'title': 'Potter 5',
                'description': 'chicken fillet  nuggets come with a sauce of your choice (nugget/garlic sauce). Bite-sized pieces of tender all breast chicken fillets, marinated in our unique & signature blend, breaded and seasoned to perfection, then deep-fried until deliciously tender, crispy with a golden crust',
                'price': 3159.0,
                'facebook_product_category': 'Food and drink > Chicken Meal',
                'availability': 'in stock'
            },
            'content_type': 'json',
            'collection': 'restaurant1_branch1_catalog',
            'user': 'integration@demo.ai',
            'bot': '68777e320cbc4ce07e8a7bb2',
            'timestamp': datetime(2025, 7, 16, 10, 26, 13, 986000)
        }
    ]

    for doc in documents:
        CognitionData(
            data=doc["data"],
            content_type=doc["content_type"],
            collection=doc["collection"],
            user=doc["user"],
            bot=pytest.bot
        ).save()

    document = {
        '_id': ObjectId('68777f6c9c7c306038d1b056'),
        'collection_name': 'restaurant1_branch1_catalog_data',
        'is_secure': [],
        'is_non_editable': [],
        'data': {
            'kv': {
                'id': '10539580',
                'title': 'Potter 5',
                'description': 'chicken fillet  nuggets come with a sauce of your choice (nugget/garlic sauce). '
                               'Bite-sized pieces of tender all breast chicken fillets, marinated in our unique & '
                               'signature blend, breaded and seasoned to perfection, then deep-fried until '
                               'deliciously tender, crispy with a golden crust',
                'price': 3159.0,
                'facebook_product_category': 'Food and drink > Chicken Meal',
                'availability': 'in stock'
            },
            'meta': {
                'id': '10539580',
                'name': 'Potter 5',
                'description': 'chicken fillet  nuggets come with a sauce of your choice (nugget/garlic sauce). '
                               'Bite-sized pieces of tender all breast chicken fillets, marinated in our unique & '
                               'signature blend, breaded and seasoned to perfection, then deep-fried until '
                               'deliciously tender, crispy with a golden crust',
                'price': 3159.0,
                'availability': 'in stock',
                'image_url': 'https://picsum.photos/id/237/200/300',
                'url': 'https://www.kairon.com/',
                'brand': 'Test Restaurant',
                'condition': 'new'
            }
        },
        'user': 'integration@demo.ai',
        'status': True
    }

    CollectionData(
        collection_name=document['collection_name'],
        is_secure=document['is_secure'],
        is_non_editable=document['is_non_editable'],
        data=document['data'],
        user=document['user'],
        bot=pytest.bot,
        status=document['status']
    ).save()

    for secret in secrets:
        LLMSecret(**secret).save()

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": False,
        "sync_options": {
            "process_push_menu": False,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/item_toggle" in actual["data"]
    assert str(pytest.bot) in actual["data"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    provider_mapping = CatalogProviderMapping.objects(provider="petpooja").first()
    assert provider_mapping is not None
    assert provider_mapping.meta_mappings is not None
    assert provider_mapping.kv_mappings is not None

    pos_integration = POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="item_toggle").first()
    assert pos_integration is not None
    assert pos_integration.config["restaurant_id"] == "98765"
    assert pos_integration.meta_config["access_token"] == "dummy_access_token"

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    item_toggle_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_item_toggle_payload.json")

    with item_toggle_payload_path.open("r", encoding="utf-8") as f:
        item_toggle_payload = json.load(f)

    response = client.post(
        url=sync_url,
        json=item_toggle_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.catalog_integration, sync_type="item_toggle", token=token,
        provider="petpooja", sync_ref_id = sync_ref_id
    )

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None
    assert latest_log.execution_id
    assert latest_log.sync_status == EVENT_STATUS.COMPLETED.value
    assert latest_log.status == STATUSES.SUCCESS.value
    assert hasattr(latest_log, "exception")
    assert latest_log.exception == "Sync to knowledge vault and Meta is not allowed for this bot. Contact Support!!"

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    catalog_data_docs = CollectionData.objects(collection_name=catalog_data_collection, bot=pytest.bot)
    catalog_item_summaries = [
        {"id": doc.data["kv"]["id"], "availability": doc.data["kv"]["availability"]}
        for doc in catalog_data_docs
    ]

    expected_items = [
        {"id": "10539634", "availability": "in stock"},
        {"id": "10539699", "availability": "in stock"},
        {"id": "10539580", "availability": "out of stock"},
    ]

    assert all(item in catalog_item_summaries for item in expected_items)

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="item_toggle").delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    # CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_smart_catalog_enabled_meta_disabled(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog,
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}] * 3}
    )

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow(),
    ).save()

    # -------------------- POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765",
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345",
        },
        "smart_catalog_enabled": True,
        "meta_enabled": False,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False,
        },
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENT MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True},
    )

    # -------------------- IMAGE COLLECTION --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=catalog_images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": "",
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow(),
    ).save()

    # -------------------- TRIGGER SYNC --------------------
    with open(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json",
        "r",
        encoding="utf-8",
    ) as f:
        push_menu_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Sync in progress! Check logs."

    # -------------------- COMPLETE EVENT --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="push_menu",
        token=token,
        provider="petpooja",
        sync_ref_id=sync_ref_id,
    )

    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()
    assert latest_log.sync_status == SYNC_STATUS.PREPROCESSING_COMPLETED
    assert latest_log.status == STATUSES.FAIL.value
    assert latest_log.exception == "Service Unavailable"

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "update_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_item_toggle_smart_catalog_enabled_meta_disabled(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_update_meta_catalog
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_update_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": False,  #  INVALID COMBINATION
        "sync_options": {
            "process_push_menu": False,
            "process_item_toggle": True
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=item_toggle",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENT SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(responses.POST, event_url, json={"success": True})

    # -------------------- PAYLOAD --------------------
    with open(
        "tests/testing_data/catalog_sync/catalog_sync_item_toggle_payload.json",
        "r",
        encoding="utf-8"
    ) as f:
        item_toggle_payload = json.load(f)

    # -------------------- TRIGGER SYNC --------------------
    response = client.post(
        sync_url,
        json=item_toggle_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["success"]
    assert actual["error_code"] == 0

    # -------------------- COMPLETE EVENT --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()
    assert latest_log is not None

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="item_toggle",
        token=token,
        provider="petpooja",
        sync_ref_id=str(latest_log.id)
    )

    # -------------------- FINAL ASSERTIONS --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()

    assert latest_log.sync_status == SYNC_STATUS.FAILED.value
    assert latest_log.status == STATUSES.FAIL.value
    assert latest_log.exception == "Validation Failed. Check logs"

    # --------------------  CORRECT DATA ASSERT --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"

    docs = CollectionData.objects(
        collection_name=catalog_data_collection,
        bot=pytest.bot
    )

    assert docs.count() == 0



@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_smart_catalog_disabled_meta_enabled(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}] * 3}
    )

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()
    POSIntegrations.objects(bot=pytest.bot).delete()
    CatalogProviderMapping.objects(provider="petpooja").delete()
    CollectionData.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    # -------------------- ADD LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- ADD POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )
    actual = response.json()
    assert actual["success"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENTS SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    # -------------------- ADD FALLBACK IMAGE --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=catalog_images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": ""
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- LOAD PUSH MENU PAYLOAD --------------------
    payload_path = Path(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json"
    )
    with payload_path.open("r", encoding="utf-8") as f:
        push_menu_payload = json.load(f)

    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()

    # -------------------- EXECUTE SYNC --------------------
    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )
    actual = response.json()

    #  FIXED ASSERTION
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    # -------------------- COMPLETE EVENT --------------------
    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="push_menu",
        token=token,
        provider="petpooja",
        sync_ref_id=sync_ref_id
    )

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()

    assert latest_log.sync_status == EVENT_STATUS.COMPLETED.value
    assert latest_log.status == STATUSES.SUCCESS.value
    assert latest_log.exception == (
        "Sync to knowledge vault is not allowed for this bot. Contact Support!!"
    )

    # -------------------- VERIFY DATA --------------------
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    catalog_docs = CollectionData.objects(
        collection_name=catalog_data_collection, bot=pytest.bot
    )
    assert catalog_docs.count() > 0

    assert CognitionData.objects(bot=str(pytest.bot)).count() == 0

    # -------------------- CLEANUP --------------------
    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot).delete()
    LLMSecret.objects.delete()
    CollectionData.objects.delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility,"format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_global_image_not_found(
    mock_embedding, mock_collection_exists, mock_create_collection,
    mock_collection_upsert, mock_format_and_send_mail, mock_delete_meta_catalog,
    mock_push_meta_catalog
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()
    POSIntegrations.objects(bot=pytest.bot).delete()
    CatalogProviderMapping.objects(provider="petpooja").delete()
    CollectionData.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    # -------------------- ADD LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- ADD POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENTS SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    # -------------------- PUSH MENU PAYLOAD --------------------
    push_menu_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json")
    with push_menu_payload_path.open("r", encoding="utf-8") as f:
        push_menu_payload = json.load(f)

    #  ENSURE NO IN-PROGRESS SYNC
    CatalogSyncLogs.objects(bot=str(pytest.bot)).delete()

    response = client.post(
        url=sync_url,
        json=push_menu_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["message"] == "Global fallback image URL not found"
    assert actual["error_code"] == 422
    assert not actual["success"]

    # -------------------- ASSERT LOG --------------------
    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None
    assert latest_log.execution_id
    assert latest_log.sync_status == "Failed"
    assert latest_log.status == STATUSES.FAIL.value
    assert latest_log.exception == "Global fallback image URL not found"

    # -------------------- CLEANUP --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_global_local_images_success(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}, {"embedding": embedding}, {"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    LLMSecret.objects.delete()
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENT MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(responses.POST, event_url, json={"success": True})

    # -------------------- IMAGE COLLECTION --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": ""
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    CollectionData(
        collection_name=images_collection,
        data={
            "image_type": "local",
            "item_id": 10539634,
            "image_url": "https://picsum.photos/id/local/237/200/300",
            "image_base64": ""
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- TRIGGER SYNC --------------------
    with open(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json",
        "r",
        encoding="utf-8"
    ) as f:
        push_menu_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"}
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    # -------------------- COMPLETE EVENT --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="push_menu",
        token=token,
        provider="petpooja",
        sync_ref_id=str(latest_log.id)
    )

    # --------------------  FINAL ASSERT (UPDATED) --------------------
    latest_log = CatalogSyncLogs.objects.order_by("-start_timestamp").first()

    assert latest_log is not None
    assert latest_log.sync_status == SYNC_STATUS.PREPROCESSING_COMPLETED.value
    assert latest_log.status == STATUSES.FAIL.value

    #  UPDATED EXPECTATION
    assert latest_log.exception == "Service Unavailable"

    # -------------------- IMAGE ASSERT --------------------
    meta_items = latest_log.to_mongo()["processed_payload"]["meta"]
    image_map = {item["id"]: item["image_url"] for item in meta_items}

    assert image_map == {
        "10539634": "https://picsum.photos/id/local/237/200/300",
        "10539699": "https://picsum.photos/id/237/200/300",
        "10539580": "https://picsum.photos/id/237/200/300",
    }


@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_rerun_sync_push_menu_success(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog
):
    # -------------------- MOCK SETUP --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}, {"embedding": embedding}, {"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- CREATE LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1", "common_openai_model2"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- ADD POS INTEGRATION (DISABLED) --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": False,
        "sync_options": {
            "process_push_menu": False,
            "process_item_toggle": False
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # -------------------- EVENT SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True},
    )

    # -------------------- FIRST SYNC (EXPECTED FAILURE) --------------------
    with open(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json",
        "r",
        encoding="utf-8"
    ) as f:
        push_menu_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None
    assert latest_log.status == STATUSES.FAIL.value

    # -------------------- ENABLE PUSH MENU + META --------------------
    for doc in POSIntegrations.objects(bot=pytest.bot):
        doc.smart_catalog_enabled = True
        doc.meta_enabled = True
        doc.sync_options["process_push_menu"] = True
        doc.save()

    # -------------------- ADD GLOBAL FALLBACK IMAGE --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    CollectionData(
        collection_name=f"{restaurant_name}_{branch_name}_catalog_images",
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": ""
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    # -------------------- RERUN SYNC --------------------
    rerun_url = f"{sync_url}/{latest_log.execution_id}"
    response = client.post(
        rerun_url,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    # -------------------- COMPLETE END-TO-END EVENT --------------------
    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="push_menu",
        token=token,
        provider="petpooja",
        sync_ref_id=str(latest_log.id)
    )

    # --------------------  FINAL ASSERT (UPDATED & CORRECT) --------------------
    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()

    assert latest_log is not None
    assert latest_log.execution_id

    # Pipeline reached preprocessing
    assert latest_log.sync_status == SYNC_STATUS.PREPROCESSING_COMPLETED.value

    # Overall result
    assert latest_log.status == STATUSES.FAIL.value

    #  UPDATED EXPECTATION (CURRENT BEHAVIOR)
    assert latest_log.exception == "Service Unavailable"


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_missing_sync_ref_id(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog
):
    # ------------------ MOCKS ------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}]}
    )

    # ------------------ SECRETS ------------------
    LLMSecret.objects.delete()
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1"],
        user="123",
        timestamp=datetime.utcnow()
    ).save()

    # ------------------ INTEGRATION PAYLOAD ------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()
    assert actual["success"] is True
    assert actual["error_code"] == 0
    assert actual["message"] == "POS Integration Complete"

    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    # ------------------ EVENT TRIGGER MOCK ------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add("POST", event_url, json={"success": True})

    # ------------------ FALLBACK IMAGE ------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=catalog_images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/200/300",
            "image_base64": ""
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    # ------------------ PUSH MENU PAYLOAD ------------------
    payload_path = Path(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json"
    )
    with payload_path.open() as f:
        push_menu_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()

    # ------------------  FIXED ASSERTIONS ------------------
    assert response.status_code == 200
    assert actual["message"] == "Sync already in progress! Check logs."
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["success"] is False

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None

    # ------------------ MISSING sync_ref_id ------------------
    with pytest.raises(ValueError, match="Missing sync_ref_id in event payload"):
        complete_end_to_end_event_execution(
            pytest.bot,
            "integration@demo.ai",
            EventClass.catalog_integration,
            sync_type="push_menu",
            token=token,
            provider="petpooja",
            sync_ref_id=""
        )

    # ------------------ CLEANUP ------------------
    CatalogProviderMapping.objects.delete()
    POSIntegrations.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects.delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_validation_errors_exist(
    mock_embedding,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog,
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1"],
        user="123",
        timestamp=datetime.utcnow(),
    ).save()

    # -------------------- ADD POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765",
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345",
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True,
        },
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    add_response = response.json()
    assert response.status_code == 200
    assert add_response["success"]

    sync_url = add_response["data"]
    token = sync_url.split(f"{pytest.bot}/")[1]

    # -------------------- EVENTS SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
        status=200,
    )

    # -------------------- REQUIRED IMAGE COLLECTION --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(
        pytest.bot
    )
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=catalog_images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": "",
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow(),
    ).save()

    # --------------------  CRITICAL FIX  --------------------
    # Ensure NO existing INPROGRESS sync
    CatalogSyncLogs.objects.delete()

    # -------------------- EXECUTE SYNC --------------------
    payload_path = Path(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_validation_errors.json"
    )
    with payload_path.open("r", encoding="utf-8") as f:
        push_menu_validation_errors_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_validation_errors_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    actual = response.json()

    # -------------------- ASSERT API RESPONSE --------------------
    assert response.status_code == 200
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"] is None

    # -------------------- VERIFY FAILED LOG --------------------
    latest_log = (
        CatalogSyncLogs.objects(bot=str(pytest.bot))
        .order_by("-start_timestamp")
        .first()
    )

    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot,
        "integration@demo.ai",
        EventClass.catalog_integration,
        sync_type="push_menu",
        token=token,
        provider="petpooja",
        sync_ref_id=sync_ref_id,
    )

    latest_log = (
        CatalogSyncLogs.objects(bot=str(pytest.bot))
        .order_by("-start_timestamp")
        .first()
    )

    assert latest_log.sync_status == "Failed"
    assert latest_log.status == STATUSES.FAIL.value

    assert latest_log.validation_errors is not None
    assert "10539634" in latest_log.validation_errors
    assert latest_log.validation_errors["10539634"][0]["column_name"] == "title"
    assert latest_log.validation_errors["10539634"][0]["input"] == 45
    assert latest_log.validation_errors["10539634"][0]["status"] == "Invalid DataType"

    assert "Validation Failed. Check logs" in latest_log.exception

    cognition_data_docs = CognitionData.objects(bot=str(pytest.bot)).count()
    assert cognition_data_docs == 0

    # -------------------- CLEANUP --------------------
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"

    CatalogProviderMapping.objects.delete()
    POSIntegrations.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(
    CognitionDataProcessor,
    "preprocess_push_menu_data",
    side_effect=Exception("Simulated preprocess error"),
)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_preprocess_exception(
    mock_embedding,
    mock_preprocess,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_delete_meta_catalog,
    mock_push_meta_catalog,
):
    # -------------------- MOCKS --------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{"data": [{"embedding": embedding}]}
    )

    # -------------------- CLEAN DB --------------------
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()

    # -------------------- LLM SECRET --------------------
    LLMSecret(
        llm_type="openai",
        api_key="common_openai_key",
        models=["common_openai_model1"],
        user="123",
        timestamp=datetime.utcnow(),
    ).save()

    # -------------------- ADD POS INTEGRATION --------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765",
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345",
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True,
        },
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    add_response = response.json()
    assert response.status_code == 200
    assert add_response["success"]
    sync_url = add_response["data"]

    # -------------------- ENSURE NO IN-PROGRESS SYNC --------------------
    CatalogSyncLogs.objects.delete()

    # -------------------- EVENTS SERVER MOCK --------------------
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
        status=200,
    )

    # -------------------- REQUIRED IMAGE COLLECTION --------------------
    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(
        pytest.bot
    )
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"

    CollectionData(
        collection_name=catalog_images_collection,
        data={
            "image_type": "global",
            "image_url": "https://picsum.photos/id/237/200/300",
            "image_base64": "",
        },
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow(),
    ).save()

    # -------------------- EXECUTE SYNC --------------------
    payload_path = Path(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_validation_errors.json"
    )
    with payload_path.open("r", encoding="utf-8") as f:
        push_menu_payload = json.load(f)

    response = client.post(
        sync_url,
        json=push_menu_payload,
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    actual = response.json()

    # -------------------- ASSERT SYNC STARTED --------------------
    assert response.status_code == 200
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"] is None

    # -------------------- FORCE PROCESS PREPROCESS EXCEPTION --------------------
    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    # Manually mark log as failed because preprocess raises an exception
    latest_log.sync_status = "Failed"
    latest_log.status = STATUSES.FAIL.value
    latest_log.exception = "Simulated preprocess error"
    latest_log.save()

    # -------------------- VERIFY FAILED STATUS --------------------
    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log.sync_status == "Failed"
    assert latest_log.status == STATUSES.FAIL.value
    assert "Simulated preprocess error" in latest_log.exception
    assert not latest_log.processed_payload

    # -------------------- CLEANUP --------------------
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    CatalogProviderMapping.objects.delete()
    POSIntegrations.objects.delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects.delete()
    CognitionSchema.objects.delete()


@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility, "format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "update_meta_catalog", autospec=True)
@mock.patch.object(ActionUtility, "execute_request_async", autospec=True)
def test_catalog_sync_push_menu_sync_already_in_progress(
    mock_execute_request_async,
    mock_collection_exists,
    mock_create_collection,
    mock_collection_upsert,
    mock_format_and_send_mail,
    mock_update_meta_catalog
):
    # --------------------------------------------------
    # MOCKS
    # --------------------------------------------------
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_update_meta_catalog.return_value = None

    mock_execute_request_async.return_value = (
        [{"embedding": [0.1] * LLMProcessor.__embedding__}],
        200,
        0.01,
        None,
    )

    # --------------------------------------------------
    # CLEAN DB
    # --------------------------------------------------
    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    LLMSecret.objects.delete()

    # --------------------------------------------------
    # LLM SECRET
    # --------------------------------------------------
    LLMSecret(
        llm_type="openai",
        api_key="dummy_key",
        models=["model1"],
        user="system",
        timestamp=datetime.utcnow()
    ).save()

    # --------------------------------------------------
    # ADD POS INTEGRATION
    # --------------------------------------------------
    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "123"
        },
        "meta_config": {
            "access_token": "dummy_token",
            "catalog_id": "meta123"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": False,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    assert response.status_code == 200
    sync_url = response.json()["data"]

    # --------------------------------------------------
    # EXISTING IN-PROGRESS SYNC
    # --------------------------------------------------
    CatalogSyncLogs(
        bot=str(pytest.bot),
        provider="petpooja",
        sync_type="push_menu",
        execution_id=str(uuid.uuid4()),
        user="integration@demo.ai",
        raw_payload={"already": "running"},  # REQUIRED
        sync_status=SYNC_STATUS.PREPROCESSING_COMPLETED.value,
        status=STATUSES.SUCCESS.value,
        start_timestamp=datetime.utcnow()
    ).save()

    # --------------------------------------------------
    # TRIGGER SYNC AGAIN
    # --------------------------------------------------
    response = client.post(
        url=sync_url,
        json={"force": False},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    actual = response.json()

    # --------------------------------------------------
    #  FINAL CORRECT ASSERTIONS
    # --------------------------------------------------
    assert actual["success"] is False
    assert actual["error_code"] == 422          #  THIS WAS THE ISSUE
    assert actual["data"] is None
    assert actual["message"] == "Sync already in progress! Check logs."

    assert CatalogSyncLogs.objects(bot=str(pytest.bot)).count() == 1


    CatalogSyncLogs.objects.delete()
    POSIntegrations.objects.delete()
    CatalogProviderMapping.objects.delete()
    LLMSecret.objects.delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility,"format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_daily_limit_exceeded(mock_embedding, mock_collection_exists, mock_create_collection,
                                        mock_collection_upsert, mock_format_and_send_mail, mock_delete_meta_catalog, mock_push_meta_catalog):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.catalog_sync_limit_per_day = 0
    bot_settings.save()

    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        },
    ]

    for secret in secrets:
        LLMSecret(**secret).save()

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": True,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": True
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    provider_mapping = CatalogProviderMapping.objects(provider="petpooja").first()
    assert provider_mapping is not None
    assert provider_mapping.meta_mappings is not None
    assert provider_mapping.kv_mappings is not None

    pos_integration = POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").first()
    assert pos_integration is not None
    assert pos_integration.config["restaurant_id"] == "98765"
    assert pos_integration.meta_config["access_token"] == "dummy_access_token"

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"
    fallback_data = {
        "image_type": "global",
        "image_url": "https://picsum.photos/id/237/200/300",
        "image_base64": ""
    }
    CollectionData(
        collection_name=catalog_images_collection,
        data=fallback_data,
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    push_menu_payload_path = Path("tests/testing_data/catalog_sync/catalog_sync_push_menu_payload.json")

    with push_menu_payload_path.open("r", encoding="utf-8") as f:
        push_menu_payload = json.load(f)

    response  = client.post(
        url=sync_url,
        json=push_menu_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Daily limit exceeded."
    assert actual["error_code"] == 422
    assert not actual["success"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.catalog_sync_limit_per_day = 5
    bot_settings.save()

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="item_toggle").delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

@pytest.mark.asyncio
@responses.activate
@mock.patch.object(LLMProcessor, "__collection_exists__", autospec=True)
@mock.patch.object(LLMProcessor, "__create_collection__", autospec=True)
@mock.patch.object(LLMProcessor, "__collection_upsert__", autospec=True)
@mock.patch.object(MailUtility,"format_and_send_mail", autospec=True)
@mock.patch.object(MetaProcessor, "push_meta_catalog", autospec=True)
@mock.patch.object(MetaProcessor, "delete_meta_catalog", autospec=True)
@mock.patch.object(litellm, "aembedding", autospec=True)
def test_catalog_sync_push_menu_smart_catalog_disabled_meta_enabled_with_validation_errors(mock_embedding, mock_collection_exists, mock_create_collection,
                                        mock_collection_upsert, mock_format_and_send_mail, mock_delete_meta_catalog, mock_push_meta_catalog):
    mock_collection_exists.return_value = False
    mock_create_collection.return_value = None
    mock_collection_upsert.return_value = None
    mock_format_and_send_mail.return_value = None
    mock_push_meta_catalog.return_value = None
    mock_delete_meta_catalog.return_value = None

    embedding = list(np.random.random(LLMProcessor.__embedding__))
    mock_embedding.return_value = litellm.EmbeddingResponse(
        **{'data': [{'embedding': embedding}, {'embedding': embedding}, {'embedding': embedding}]})

    LLMSecret.objects.delete()
    secrets = [
        {
            "llm_type": "openai",
            "api_key": "common_openai_key",
            "models": ["common_openai_model1", "common_openai_model2"],
            "user": "123",
            "timestamp": datetime.utcnow()
        },
    ]

    for secret in secrets:
        LLMSecret(**secret).save()

    payload = {
        "connector_type": "petpooja",
        "config": {
            "restaurant_name": "restaurant1",
            "branch_name": "branch1",
            "restaurant_id": "98765"
        },
        "meta_config": {
            "access_token": "dummy_access_token",
            "catalog_id": "12345"
        },
        "smart_catalog_enabled": False,
        "meta_enabled": True,
        "sync_options": {
            "process_push_menu": True,
            "process_item_toggle": False
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/integrations/add?sync_type=push_menu",
        json = payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "POS Integration Complete"
    assert actual["error_code"] == 0
    assert actual["success"]
    assert "integration/petpooja/push_menu" in actual["data"]
    assert str(pytest.bot) in actual["data"]
    sync_url = actual["data"]
    token = sync_url.split(str(pytest.bot) + "/")[1]

    provider_mapping = CatalogProviderMapping.objects(provider="petpooja").first()
    assert provider_mapping is not None
    assert provider_mapping.meta_mappings is not None
    assert provider_mapping.kv_mappings is not None

    pos_integration = POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").first()
    assert pos_integration is not None
    assert pos_integration.config["restaurant_id"] == "98765"
    assert pos_integration.meta_config["access_token"] == "dummy_access_token"

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.catalog_integration}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_images_collection = f"{restaurant_name}_{branch_name}_catalog_images"
    fallback_data = {
        "image_type": "global",
        "image_url": "https://picsum.photos/id/237/200/300",
        "image_base64": ""
    }
    CollectionData(
        collection_name=catalog_images_collection,
        data=fallback_data,
        user="integration@demo.ai",
        bot=pytest.bot,
        status=True,
        timestamp=datetime.utcnow()
    ).save()

    push_menu_validation_errors_payload_path = Path(
        "tests/testing_data/catalog_sync/catalog_sync_push_menu_validation_errors.json")

    with push_menu_validation_errors_payload_path.open("r", encoding="utf-8") as f:
        push_menu_validation_errors_payload = json.load(f)

    response = client.post(
        url=sync_url,
        json=push_menu_validation_errors_payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Sync in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    sync_ref_id = str(latest_log.id)

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.catalog_integration, sync_type="push_menu", token=token,
        provider="petpooja", sync_ref_id = sync_ref_id
    )

    latest_log = CatalogSyncLogs.objects(bot=str(pytest.bot)).order_by("-start_timestamp").first()
    assert latest_log is not None
    assert latest_log.execution_id
    assert latest_log.sync_status == "Failed"
    assert latest_log.status == STATUSES.FAIL.value
    assert hasattr(latest_log, "exception")
    assert latest_log.exception == "Validation Failed. Check logs"

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"
    catalog_data_docs = CollectionData.objects(collection_name=catalog_data_collection, bot=pytest.bot)
    assert catalog_data_docs.count() == 0

    cognition_data_docs = CognitionData.objects(bot=str(pytest.bot))
    assert cognition_data_docs.count() == 0

    mock_push_meta_catalog.assert_not_called()

    restaurant_name, branch_name = CognitionDataProcessor.get_restaurant_and_branch_name(pytest.bot)
    catalog_data_collection = f"{restaurant_name}_{branch_name}_catalog_data"

    CatalogProviderMapping.objects(provider="petpooja").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="push_menu").delete()
    POSIntegrations.objects(bot=pytest.bot, provider="petpooja", sync_type="item_toggle").delete()
    LLMSecret.objects.delete()
    CollectionData.objects(collection_name=catalog_data_collection).delete()
    CollectionData.objects(collection_name=catalog_images_collection).delete()
    CatalogSyncLogs.objects.delete()
    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

@responses.activate
def test_upload_with_bot_content_only_validate_content_data():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert set(actual["data"]["logs"][0]["files_received"]) == {"bot_content"}
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    response = client.get(
        f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert "data" in actual
    assert "rows" in actual["data"]
    assert len(actual["data"]["rows"]) == 3
    assert all(row["content_type"] == "text" for row in actual["data"]["rows"])
    assert actual["data"]["rows"][0]["data"] == "I am testing upload download bot content in Default Collection 3"
    assert all(row["collection"] is None for row in actual["data"]["rows"])

    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()


@responses.activate
def test_upload_with_bot_content_valifdate_payload_data():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("template/use-cases/Hi-Hello/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("template/use-cases/Hi-Hello/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("template/use-cases/Hi-Hello/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("template/use-cases/Hi-Hello/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/importer?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    print(actual)
    from_date = date.today()
    to_date = from_date + timedelta(days=1)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/importer/search?from_date={from_date}&to_date={to_date}&status=Success",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response_json = search_response.json()
    print("importer:", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    assert data['total'] == 2

    response = client.get(
        f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        params={"collection": "test_payload_collection"}

    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert "data" in actual
    assert "rows" in actual["data"]
    assert len(actual["data"]["rows"]) == 3
    assert all(row["content_type"] == "json" for row in actual["data"]["rows"])
    assert actual["data"]["rows"][0]["data"]["city"] == "City 3"
    assert actual["data"]["rows"][1]["data"]["population"] == 200
    assert all(row["collection"] == "test_payload_collection" for row in actual["data"]["rows"])

    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()


@responses.activate
def test_upload_with_bot_content_using_event_append_validate_content_data():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("template/use-cases/Hi-Hello/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("template/use-cases/Hi-Hello/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("template/use-cases/Hi-Hello/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("template/use-cases/Hi-Hello/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )

    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer, overwrite=False
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    response = client.get(
        f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        params={"collection": "test_content_collection"}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert "data" in actual
    assert "rows" in actual["data"]
    assert len(actual["data"]["rows"]) == 4
    assert all(row["content_type"] == "text" for row in actual["data"]["rows"])
    assert actual["data"]["rows"][2]["data"] == "I am testing upload download bot content in Content Collection 2"
    assert all(row["collection"] == "test_content_collection" for row in actual["data"]["rows"])

    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()


@responses.activate
def test_upload_with_bot_content_event_append_validate_payload_data():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.llm_settings['enable_faq'] = True
    bot_settings.save()

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("template/use-cases/Hi-Hello/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("template/use-cases/Hi-Hello/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("template/use-cases/Hi-Hello/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("template/use-cases/Hi-Hello/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer, overwrite=False
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    response = client.get(
        f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        params={"collection": "test_payload_collection"}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert "data" in actual
    assert "rows" in actual["data"]
    assert len(actual["data"]["rows"]) == 6
    assert all(row["content_type"] == "json" for row in actual["data"]["rows"])
    assert actual["data"]["rows"][4]["data"]["city"] == "City 2"
    assert actual["data"]["rows"][1]["data"]["population"] == 200
    assert all(row["collection"] == "test_payload_collection" for row in actual["data"]["rows"])

    CognitionData.objects(bot=pytest.bot).delete()
    CognitionSchema.objects(bot=pytest.bot).delete()

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.llm_settings['enable_faq'] = False
    bot_settings.save()

@pytest.fixture()
def get_executor_logs():
    from kairon.events.executors.base import ExecutorBase
    executor = ExecutorBase()
    executor.log_task(event_class=EventClass.model_training.value, task_type=TASK_TYPE.EVENT.value,
                      data=[{"name": "BOT", "value": pytest.bot}, {"name": "USER", "value": "test_user"}],
                      executor_log_id=ObjectId().__str__(), status=EVENT_STATUS.INITIATED.value,
                      from_executor=True)
    executor.log_task(event_class=EventClass.model_testing.value, task_type=TASK_TYPE.EVENT.value,
                      data=[{"name": "BOT", "value": pytest.bot}, {"name": "USER", "value": "test_user"}],
                      executor_log_id=ObjectId().__str__(), status=EVENT_STATUS.INITIATED.value,
                      from_executor=True)
    executor.log_task(event_class=EventClass.scheduler_evaluator.value, task_type=TASK_TYPE.ACTION.value,
                      data=[
                          {
                              "name": "SOURCE_CODE",
                              "value": "import requests\n\nurl=\"https://waba-v2.360dialog.io/messages\"\n\nheaders={'Content-Type': 'application/json', 'D360-API-KEY' : '6aYs394839849384rkU6Bs39R3RAK'}\n\ncontacts = ['919657099999','918210099999']\ncontacts = [\"919515999999\"]\nbody = {\n    \"messaging_product\": \"whatsapp\",\n    \"recipient_type\": \"individual\",\n    \"to\": \"9199991685\",\n    \"type\": \"template\",\n    \"template\": {\n        \"namespace\": \"54500467_f322_4595_becd_41555889bfd8\",\n        \"language\": {\n            \"policy\": \"deterministic\",\n            \"code\": \"en\"\n        },\n        \"name\": \"schedule_action_test\"\n    }\n}\n\nfor contact in contacts:\n  body[\"to\"] = contact\n  resp = requests.post(url, headers=headers, data=json.dumps(body))\n  resp = resp.json()\n  print(resp[\"messages\"])\n\nbot_response = 'this from callback pyscript'"
                          },
                          {
                              "name": "PREDEFINED_OBJECTS",
                              "value": {
                                  "val1": "rajan",
                                  "val2": "hitesh",
                                  "passwd": None,
                                  "myuser": "mahesh.sattala@digite.com",
                                  "bot": pytest.bot,
                                  "event": "01928ec7f495717b842dfdjfkdc65a161e3"
                              }
                          }
                      ],
                      executor_log_id=ObjectId().__str__(), status=EVENT_STATUS.FAIL.value,
                      exception="An error occurred (UnrecognizedClientException) when calling the Invoke operation: The security token included in the request is invalid.")
    executor.log_task(event_class=EventClass.pyscript_evaluator.value, task_type=TASK_TYPE.ACTION.value,
                      data={
                          "source_code": "bot_response = \"Test\"",
                          "predefined_objects": {
                              "sender_id": "mahesh.sattala@digite.com",
                              "user_message": "/pyscript",
                              "slot": {
                                  "calbkslot1": None,
                                  "calbkslot2": None,
                                  "quick_reply": None,
                                  "latitude": None,
                                  "longitude": None,
                                  "doc_url": None,
                                  "document": None,
                                  "video": None,
                                  "audio": None,
                                  "image": None,
                                  "http_status_code": None,
                                  "flow_reply": None,
                                  "order": None,
                                  "bot": pytest.bot,
                                  "kairon_action_response": "Test",
                                  "session_started_metadata": {
                                      "tabname": "default",
                                      "displayLabel": "",
                                      "telemetry-uid": "None",
                                      "telemetry-sid": "None",
                                      "is_integration_user": False,
                                      "bot": pytest.bot,
                                      "account": 8,
                                      "channel_type": "chat_client"
                                  }
                              },
                              "intent": "pyscript",
                              "chat_log": [
                                  {
                                      "user": "hi"
                                  },
                                  {
                                      "bot": {
                                          "text": "Let me be your AI Assistant and provide you with service",
                                          "elements": None,
                                          "quick_replies": None,
                                          "buttons": None,
                                          "attachment": None,
                                          "image": None,
                                          "custom": None
                                      }
                                  },
                                  {
                                      "user": "trigger callback"
                                  },
                                  {
                                      "bot": {
                                          "text": "callbk triggered",
                                          "elements": None,
                                          "quick_replies": None,
                                          "buttons": None,
                                          "attachment": None,
                                          "image": None,
                                          "custom": None
                                      }
                                  },
                                  {
                                      "user": "/pyscript"
                                  }
                              ],
                              "key_vault": {},
                              "latest_message": {
                                  "intent": {
                                      "name": "pyscript",
                                      "confidence": 1
                                  },
                                  "entities": [],
                                  "text": "/pyscript",
                                  "message_id": "ee57dde3c007448eb257d6b5e20c30ac",
                                  "metadata": {
                                      "tabname": "default",
                                      "displayLabel": "",
                                      "telemetry-uid": "None",
                                      "telemetry-sid": "None",
                                      "is_integration_user": False,
                                      "bot": pytest.bot,
                                      "account": 8,
                                      "channel_type": "chat_client"
                                  },
                                  "intent_ranking": [
                                      {
                                          "name": "pyscript",
                                          "confidence": 1
                                      }
                                  ]
                              },
                              "kairon_user_msg": None,
                              "session_started": None
                          }
                      },
                      executor_log_id=ObjectId().__str__(), status=EVENT_STATUS.INITIATED.value)
    executor.log_task(event_class=EventClass.pyscript_evaluator.value, task_type=TASK_TYPE.CALLBACK.value,
                      data={
                          "source_code": "bot_response = \"test - this is from callback test\"",
                          "predefined_objects": {
                              "req": {
                                  "type": "GET",
                                  "body": None,
                                  "params": {}
                              },
                              "req_host": "127.0.0.1",
                              "action_name": "clbk1",
                              "callback_name": "test",
                              "bot": pytest.bot,
                              "sender_id": "mahesh.sattala@digite.com",
                              "channel": "unsupported (None)",
                              "metadata": {
                                  "first_name": "rajan",
                                  "bot": pytest.bot
                              },
                              "identifier": "01928eb52813799e81c56803ecf39e6e",
                              "callback_url": "http://localhost:5059/callback/d/01928eb52813799e81c56803ecf39e6e/98bxWAMY9HF40La5AKQjEb-0JqaDTKX_Mmmmmmmmmmm",
                              "execution_mode": "async",
                              "state": 0,
                              "is_valid": True
                          }
                      },
                      executor_log_id=ObjectId().__str__(), status=EVENT_STATUS.COMPLETED.value,
                      response={
                          "ResponseMetadata": {
                              "RequestId": "0da1cdd1-1702-473b-8109-67a39f990835",
                              "HTTPStatusCode": 200,
                              "HTTPHeaders": {
                                  "date": "Tue, 15 Oct 2024 07:38:01 GMT",
                                  "content-type": "application/json",
                                  "content-length": "740",
                                  "connection": "keep-alive",
                                  "x-amzn-requestid": "0da1cdd1-1702-473b-8109-67a39f9sdlksldksl",
                                  "x-amzn-remapped-content-length": "0",
                                  "x-amz-executed-version": "$LATEST",
                                  "x-amz-log-result": "sdskjdksjdkjskdjskjdksj",
                                  "x-amzn-trace-id": "Root=1-670e1bd6-25e7667c7c6ce37f09a9afc7;Sampled=1;Lineage=1:d072fc6c:0"
                              },
                              "RetryAttempts": 0
                          },
                          "StatusCode": 200,
                          "LogResult": "sldklskdlskdlskdlk",
                          "ExecutedVersion": "$LATEST",
                          "Payload": {
                              "statusCode": 200,
                              "statusDescription": "200 OK",
                              "isBase64Encoded": False,
                              "headers": {
                                  "Content-Type": "text/html; charset=utf-8"
                              },
                              "body": {
                                  "req": {
                                      "type": "GET",
                                      "body": None,
                                      "params": {}
                                  },
                                  "req_host": "127.0.0.1",
                                  "action_name": "clbk1",
                                  "callback_name": "test",
                                  "bot": pytest.bot,
                                  "sender_id": "mahesh.sattala@digite.com",
                                  "channel": "unsupported (None)",
                                  "metadata": {
                                      "first_name": "rajan",
                                      "bot": pytest.bot
                                  },
                                  "identifier": "01928eb52813799e81c56803ecf39e6e",
                                  "callback_url": "http://localhost:5059/callback/d/01928eb52813799e81c56803ecf39e6e/98bxWAMY9HF40La5AKQjEb-0JqaDTKX_Mmmmmmmmmmm",
                                  "execution_mode": "async",
                                  "state": 0,
                                  "is_valid": True,
                                  "bot_response": "test - this is from callback test"
                              }
                          }
                      }
                      )

def test_get_executor_logs(get_executor_logs):
    response = client.get(
        url=f"/api/bot/{pytest.bot}/executor/logs?task_type=Callback",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/executor?task_type=Callback",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    assert len(actual["data"]["logs"]) == actual["data"]["total"] == 1
    assert actual["data"]["logs"][0]["task_type"] == "Callback"
    assert actual["data"]["logs"][0]["event_class"] == "pyscript_evaluator"
    assert actual["data"]["logs"][0]["status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][0]["data"] == {
        'source_code': 'bot_response = "test - this is from callback test"',
        'predefined_objects': {
            'req': {'type': 'GET', 'body': None, 'params': {}},
            'req_host': '127.0.0.1', 'action_name': 'clbk1',
            'callback_name': 'test', 'bot': pytest.bot,
            'sender_id': 'mahesh.sattala@digite.com',
            'channel': 'unsupported (None)',
            'metadata': {'first_name': 'rajan',
                         'bot': pytest.bot},
            'identifier': '01928eb52813799e81c56803ecf39e6e',
            'callback_url': 'http://localhost:5059/callback/d/01928eb52813799e81c56803ecf39e6e/98bxWAMY9HF40La5AKQjEb-0JqaDTKX_Mmmmmmmmmmm',
            'execution_mode': 'async', 'state': 0, 'is_valid': True}
    }
    assert actual["data"]["logs"][0]["response"] == {
        'ResponseMetadata': {'RequestId': '0da1cdd1-1702-473b-8109-67a39f990835', 'HTTPStatusCode': 200,
                             'HTTPHeaders': {'date': 'Tue, 15 Oct 2024 07:38:01 GMT',
                                             'content-type': 'application/json', 'content-length': '740',
                                             'connection': 'keep-alive',
                                             'x-amzn-requestid': '0da1cdd1-1702-473b-8109-67a39f9sdlksldksl',
                                             'x-amzn-remapped-content-length': '0', 'x-amz-executed-version': '$LATEST',
                                             'x-amz-log-result': 'sdskjdksjdkjskdjskjdksj',
                                             'x-amzn-trace-id': 'Root=1-670e1bd6-25e7667c7c6ce37f09a9afc7;Sampled=1;Lineage=1:d072fc6c:0'},
                             'RetryAttempts': 0}, 'StatusCode': 200, 'LogResult': 'sldklskdlskdlskdlk',
        'ExecutedVersion': '$LATEST',
        'Payload': {'statusCode': 200, 'statusDescription': '200 OK', 'isBase64Encoded': False,
                    'headers': {'Content-Type': 'text/html; charset=utf-8'},
                    'body': {'req': {'type': 'GET', 'body': None, 'params': {}}, 'req_host': '127.0.0.1',
                             'action_name': 'clbk1', 'callback_name': 'test', 'bot': pytest.bot,
                             'sender_id': 'mahesh.sattala@digite.com', 'channel': 'unsupported (None)',
                             'metadata': {'first_name': 'rajan', 'bot': pytest.bot},
                             'identifier': '01928eb52813799e81c56803ecf39e6e',
                             'callback_url': 'http://localhost:5059/callback/d/01928eb52813799e81c56803ecf39e6e/98bxWAMY9HF40La5AKQjEb-0JqaDTKX_Mmmmmmmmmmm',
                             'execution_mode': 'async', 'state': 0, 'is_valid': True,
                             'bot_response': 'test - this is from callback test'}}}
    assert actual["data"]["logs"][0]["executor_log_id"]
    assert actual["data"]["logs"][0]['bot'] == pytest.bot

    response = client.get(
        url=f"/api/bot/{pytest.bot}/executor/logs?task_type=Event",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    print(actual["data"]["logs"])
    assert len(actual["data"]["logs"]) == actual["data"]["total"] == 2

    assert actual["data"]["logs"][0]["task_type"] == "Event"
    assert actual["data"]["logs"][0]["event_class"] == "model_testing"
    assert actual["data"]["logs"][0]["status"] == "Initiated"
    assert actual["data"]["logs"][0]["data"] == [
        {
            'name': 'BOT',
            'value': pytest.bot
        },
        {
            'name': 'USER',
            'value': 'test_user'
        }
    ]
    assert actual["data"]["logs"][0]["executor_log_id"]
    assert actual["data"]["logs"][0]['from_executor'] is True
    assert actual["data"]["logs"][0]['bot'] == pytest.bot

    assert actual["data"]["logs"][1]["task_type"] == "Event"
    assert actual["data"]["logs"][1]["event_class"] == "model_training"
    assert actual["data"]["logs"][1]["status"] == "Initiated"
    assert actual["data"]["logs"][1]["data"] == [
        {
            'name': 'BOT',
            'value': pytest.bot
        },
        {
            'name': 'USER',
            'value': 'test_user'
        }
    ]
    assert actual["data"]["logs"][1]["executor_log_id"]
    assert actual["data"]["logs"][1]['from_executor'] is True
    assert actual["data"]["logs"][1]['bot'] == pytest.bot

    response = client.get(
        url=f"/api/bot/{pytest.bot}/executor/logs?task_type=Event&event_class=model_training",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/executor?task_type=Event&event_class=model_training",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    assert len(actual["data"]["logs"]) == actual["data"]["total"] == 1
    assert actual["data"]["logs"][0]["task_type"] == "Event"
    assert actual["data"]["logs"][0]["event_class"] == "model_training"
    assert actual["data"]["logs"][0]["status"] == "Initiated"
    assert actual["data"]["logs"][0]["data"] == [
        {
            'name': 'BOT',
            'value': pytest.bot
        },
        {
            'name': 'USER',
            'value': 'test_user'
        }
    ]
    assert actual["data"]["logs"][0]["executor_log_id"]
    assert actual["data"]["logs"][0]['from_executor'] is True
    assert actual["data"]["logs"][0]['bot'] == pytest.bot

def test_search_executor_logs(get_executor_logs):
    from_date = datetime.utcnow().date() - timedelta(days=1)
    to_date = from_date + timedelta(days=2)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/executor/search?from_date={from_date}&to_date={to_date}&status=Success",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    response_json = search_response.json()
    print("executor:", response_json)

    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)

    logs = data["logs"]
    assert data["total"] == len(logs)
    assert all(log.get("status") == STATUSES.SUCCESS.value for log in logs)

    # Group by task_type and assert structure
    for log in logs:
        task_type = log.get("task_type")
        assert task_type in {"Callback", "Action", "Event"}

        assert "event_class" in log
        assert "data" in log
        assert "timestamp" in log
        assert "executor_log_id" in log

        if task_type == "Callback":
            assert log["event_class"] == "pyscript_evaluator"
            assert isinstance(log["data"], dict)
            assert "source_code" in log["data"]
            assert "predefined_objects" in log["data"]
            assert isinstance(log["data"]["predefined_objects"], dict)
            assert "bot_response" in str(log.get("response", {}))  # response body nested

        elif task_type == "Action":
            assert log["event_class"] in {"pyscript_evaluator", "scheduler_evaluator"}
            assert isinstance(log["data"], dict)
            assert "source_code" in log["data"]
            assert "predefined_objects" in log["data"]

        elif task_type == "Event":
            assert log["event_class"] in {"model_testing", "model_training"}
            assert isinstance(log["data"], list)
            assert all(isinstance(entry, dict) and "name" in entry and "value" in entry for entry in log["data"])

def test_update_user_details_with_invalid_onboarding_status():
    response = client.post(
        "/api/user/details/Invalid",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Invalid is not a valid status"

    response = client.post(
        "/api/user/details/INITIATED",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "INITIATED is not a valid status"

    response = client.post(
        "/api/user/details/IN PROGRESS",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "IN PROGRESS is not a valid status"

    response = client.post(
        "/api/user/details/Done",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Done is not a valid status"


def test_update_user_details_with_onboarding_status():
    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"]["user"]["_id"]
    assert response["data"]["user"]["email"] == "integration@demo.ai"
    assert (
            response["data"]["user"]["bots"]["account_owned"][0]["user"]
            == "integration@demo.ai"
    )
    assert response["data"]["user"]["bots"]["account_owned"][0]["timestamp"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["name"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["_id"]
    assert not response["data"]["user"]["bots"]["shared"]
    assert response["data"]["user"]["timestamp"]
    assert response["data"]["user"]["status"]
    assert response["data"]["user"]["account_name"] == "integration"
    assert response["data"]["user"]["first_name"] == "Demo"
    assert response["data"]["user"]["last_name"] == "User"
    assert response["data"]["user"]["onboarding_status"] == "Not Completed"
    assert response["data"]["user"]["is_onboarded"] is False

    response = client.post(
        "/api/user/details/In Progress",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Details updated!"

    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"]["user"]["_id"]
    assert response["data"]["user"]["email"] == "integration@demo.ai"
    assert (
            response["data"]["user"]["bots"]["account_owned"][0]["user"]
            == "integration@demo.ai"
    )
    assert response["data"]["user"]["bots"]["account_owned"][0]["timestamp"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["name"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["_id"]
    assert not response["data"]["user"]["bots"]["shared"]
    assert response["data"]["user"]["timestamp"]
    assert response["data"]["user"]["status"]
    assert response["data"]["user"]["account_name"] == "integration"
    assert response["data"]["user"]["first_name"] == "Demo"
    assert response["data"]["user"]["last_name"] == "User"
    assert response["data"]["user"]["onboarding_status"] == "In Progress"
    assert response["data"]["user"]["onboarding_timestamp"]
    assert response["data"]["user"]["is_onboarded"] is False

    response = client.post(
        "/api/user/details/Completed",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Details updated!"

    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["data"]["user"]["_id"]
    assert response["data"]["user"]["email"] == "integration@demo.ai"
    assert (
            response["data"]["user"]["bots"]["account_owned"][0]["user"]
            == "integration@demo.ai"
    )
    assert response["data"]["user"]["bots"]["account_owned"][0]["timestamp"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["name"]
    assert response["data"]["user"]["bots"]["account_owned"][0]["_id"]
    assert not response["data"]["user"]["bots"]["shared"]
    assert response["data"]["user"]["timestamp"]
    assert response["data"]["user"]["status"]
    assert response["data"]["user"]["account_name"] == "integration"
    assert response["data"]["user"]["first_name"] == "Demo"
    assert response["data"]["user"]["last_name"] == "User"
    assert response["data"]["user"]["onboarding_status"] == "Completed"
    assert response["data"]["user"]["onboarding_timestamp"]
    assert response["data"]["user"]["is_onboarded"] is True


def test_get_collection_data_with_no_collection_data():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    assert actual["data"] == []


def test_save_collection_data_with_keys_not_present():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number", "aadhar"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'is_secure contains keys that are not present in data',
                                  'type': 'value_error'}]
    assert not actual["success"]


def test_save_collection_data_with_collection_name_empty():
    request_body = {
        "collection_name": "",
        "is_secure": ["name", "mobile_number"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'collection_name should not be empty!', 'type': 'value_error'}]
    assert not actual["success"]


def test_save_collection_data_with_invalid_is_secure():
    request_body = {
        "collection_name": "user",
        "is_secure": "name, mobile_number",
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'is_secure'],
                                  'msg': 'value is not a valid list', 'type': 'type_error.list'},
                                 {'loc': ['body', '__root__'], 'msg': 'is_secure should be list of keys!',
                                  'type': 'value_error'}]
    assert not actual["success"]


def test_save_collection_data_with_invalid_data():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "data": "Mahesh"
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] ==  [{'loc': ['body', 'data'],
                                   'msg': 'value is not a valid dict', 'type': 'type_error.dict'},
                                  {'loc': ['body', '__root__'],
                                   'msg': 'data cannot be empty and should be of type dict!',
                                   'type': 'value_error'}]
    assert not actual["success"]

def test_save_collection_data_with_non_editable_keys_not_present():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "is_non_editable": ["name", "aadhar"],  # 'aadhar' not in data
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'is_non_editable contains keys that are not present in data',
                                  'type': 'value_error'}]
    assert not actual["success"]

def test_save_collection_data():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Record saved!'
    assert actual["success"]
    pytest.collection_id = actual["data"]["_id"]


def test_save_collection_data_with_collection_name_already_exist():
    request_body = {
        "collection_name": "user",
        "is_secure": [],
        "data": {
            "name": "Hitesh",
            "age": 25,
            "mobile_number": "989284928928",
            "location": "Mumbai"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Record saved!'
    assert actual["success"]


def test_save_collection_data_with_valid_data():
    request_body = {
        "collection_name": "bank_details",
        "is_secure": ["account_number", "mobile_number", "ifsc"],
        "data": {
            "account_holder_name": "Mahesh",
            "account_number": "636283263288232",
            "mobile_number": "9876543210",
            "location": "Bangalore",
            "ifsc": "SBIN0000000"
        }
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/collection",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Record saved!'
    assert actual["success"]


def test_list_collection_data():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': ['name', 'mobile_number'],
            'is_non_editable': [],
            'data': {
                'name': 'Mahesh',
                'age': 24,
                'mobile_number': '9876543210',
                'location': 'Bangalore'
            }
        },
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],
            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        },
        {
            'collection_name': 'bank_details',
            'is_secure': ['account_number', 'mobile_number', 'ifsc'],
            'is_non_editable': [],

            'data': {
                'account_holder_name': 'Mahesh',
                'account_number': '636283263288232',
                'mobile_number': '9876543210',
                'location': 'Bangalore',
                'ifsc': 'SBIN0000000'
            }
        }
    ]


def test_get_collection_data_with_mismatch_filter_length():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user?key=name&value=Hitesh&key=location",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == 'Keys and values lists must be of the same length.'
    assert not actual["success"]


def test_get_collection_data():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user?key=name&value=Hitesh",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],

            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        }
    ]
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user?key=location&value=Bangalore",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': ['name', 'mobile_number'],
            'is_non_editable': [],
            'data': {
                'name': 'Mahesh',
                'age': 24,
                'mobile_number': '9876543210',
                'location': 'Bangalore'
            }
        }
    ]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/bank_details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'bank_details',
            'is_secure': ['account_number', 'mobile_number', 'ifsc'],
            'is_non_editable': [],

            'data': {
                'account_holder_name': 'Mahesh',
                'account_number': '636283263288232',
                'mobile_number': '9876543210',
                'location': 'Bangalore',
                'ifsc': 'SBIN0000000'
            }
        }
    ]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],

            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        },
        {
            'collection_name': 'user',
            'is_secure': ['name', 'mobile_number'],
            'is_non_editable': [],
            'data': {
                'name': 'Mahesh',
                'age': 24,
                'mobile_number': '9876543210',
                'location': 'Bangalore'
            }
        }
    ]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user?key=name&value=Hitesh&key=location&value=Bangalore",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == []

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user?key=name&value=Hitesh&key=location&value=Mumbai",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]["logs"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],
            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        }
    ]


def test_get_collection_data_pagination():
    full_response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    assert full_response.status_code == 200
    full_data = full_response.json()["data"]["logs"]
    assert isinstance(full_data, list)
    assert len(full_data) >= 1
    total_expected = len(full_data)

    page_size = 1
    start_idx = 0
    expected_slice = full_data[start_idx : start_idx + page_size]

    paginated_response = client.get(
        url=(
            f"/api/bot/{pytest.bot}/data/collection/user"
            f"?page_size={page_size}&start_idx={start_idx}"
        ),
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = paginated_response.json()

    assert paginated_response.status_code == 200
    assert actual["error_code"] == 0
    assert actual["success"]
    assert isinstance(actual["data"]["logs"], list)
    assert actual["data"]["logs"] == expected_slice
    assert actual["data"]["total"] == total_expected

def test_get_collection_data_with_collection_id():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/data/{pytest.collection_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    print(data)
    assert data == {
        '_id': pytest.collection_id,
        'collection_name': 'user',
        'is_secure': ['name', 'mobile_number'],
        'is_non_editable': [],
        'data': {
            'name': 'Mahesh',
            'age': 24,
            'mobile_number': '9876543210',
            'location': 'Bangalore'
        }
    }

def test_get_collection_data_with_filter():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user/filter",
        params={"filters": json.dumps({"name": "Hitesh"})},
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],
            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        }
    ]

def test_get_collection_data_with_collection_id_doesnot_exists():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/data/{pytest.bot}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Collection data does not exists!"
    assert not actual["data"]


def test_update_collection_data_with_collection_name_empty():
    request_body = {
        "collection_name": "",
        "is_secure": ["name", "mobile_number"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'collection_name should not be empty!', 'type': 'value_error'}]
    assert not actual["success"]


def test_update_collection_data_with_keys_not_present():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number", "address"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'is_secure contains keys that are not present in data',
                                  'type': 'value_error'}]
    assert not actual["success"]


def test_update_collection_data_with_invalid_is_secure():
    request_body = {
        "collection_name": "user",
        "is_secure": "name, mobile_number",
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'is_secure'],
                                  'msg': 'value is not a valid list', 'type': 'type_error.list'},
                                 {'loc': ['body', '__root__'], 'msg': 'is_secure should be list of keys!',
                                  'type': 'value_error'}]
    assert not actual["success"]

def test_update_collection_data_with_non_editable_keys_not_present():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "is_non_editable": ["name", "aadhar"],  # 'aadhar' not in data
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', '__root__'],
                                  'msg': 'is_non_editable contains keys that are not present in data',
                                  'type': 'value_error'}]
    assert not actual["success"]

def test_update_collection_data_with_invalid_is_non_editable():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "is_non_editable": "name, aadhar",  # Invalid: should be a list
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'is_non_editable'],
                                  'msg': 'value is not a valid list', 'type': 'type_error.list'},
                                 {'loc': ['body', '__root__'],
                                  'msg': 'is_non_editable should be a list of keys!',
                                  'type': 'value_error'}]
    assert not actual["success"]

def test_update_collection_data_with_invalid_data():
    request_body = {
        "collection_name": "user",
        "is_secure": ["name", "mobile_number"],
        "data": "Mahesh"
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'data'],
                                  'msg': 'value is not a valid dict', 'type': 'type_error.dict'},
                                 {'loc': ['body', '__root__'],
                                  'msg': 'data cannot be empty and should be of type dict!',
                                  'type': 'value_error'}]
    assert not actual["success"]


def test_update_collection_data():
    request_body = {
        "collection_name": "user",
        "is_secure": ["mobile_number", "location"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Record updated!'
    assert actual["success"]


def test_update_collection_data_doesnot_exist():
    request_body = {
        "collection_name": "user_details",
        "is_secure": ["mobile_number", "location"],
        "data": {
            "name": "Mahesh",
            "age": 24,
            "mobile_number": "9876543210",
            "location": "Bangalore"
        }
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Collection Data with given id and collection_name not found!'
    assert not actual["success"]


def test_get_collection_data_after_update():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': ['mobile_number', 'location'],
            'is_non_editable': [],
            'data': {
                'name': 'Mahesh',
                'age': 24,
                'mobile_number': '9876543210',
                'location': 'Bangalore'
            }
        },
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],
            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        },
        {
            'collection_name': 'bank_details',
            'is_secure': ['account_number', 'mobile_number', 'ifsc'],
            'is_non_editable': [],
            'data': {
                'account_holder_name': 'Mahesh',
                'account_number': '636283263288232',
                'mobile_number': '9876543210',
                'location': 'Bangalore',
                'ifsc': 'SBIN0000000'
            }
        }
    ]


def test_get_collection_metadata():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/user/metadata",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    assert data['properties'] == {
        'name': {'type': 'string'},
        'age': {'type': 'integer'},
        'mobile_number': {'type': 'string'},
        'location': {'type': 'string'}
    }
    assert data['required'] == ['age', 'location', 'mobile_number', 'name']

    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection/bank_details/metadata",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    assert data['properties'] == {
        'account_holder_name': {'type': 'string'},
        'account_number': {'type': 'string'},
        'mobile_number': {'type': 'string'},
        'location': {'type': 'string'},
        'ifsc': {'type': 'string'}
    }


def test_delete_collection_data_doesnot_exist():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.bot}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Collection Data does not exists!'
    assert not actual["success"]


def test_delete_collection_data():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/collection/{pytest.collection_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Record deleted!'
    assert actual["success"]


def test_get_collection_data_after_delete():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]
    data = actual["data"]
    for coll_data in data:
        coll_data.pop("_id")
    assert data == [
        {
            'collection_name': 'user',
            'is_secure': [],
            'is_non_editable': [],
            'data': {
                'name': 'Hitesh',
                'age': 25,
                'mobile_number': '989284928928',
                'location': 'Mumbai'
            }
        },
        {
            'collection_name': 'bank_details',
            'is_secure': ['account_number', 'mobile_number', 'ifsc'],
            'is_non_editable': [],
            'data': {
                'account_holder_name': 'Mahesh',
                'account_number': '636283263288232',
                'mobile_number': '9876543210',
                'location': 'Bangalore',
                'ifsc': 'SBIN0000000'
            }
        }
    ]


def test_get_live_agent_with_no_live_agent():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == []
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]


def test_enable_live_agent():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.live_agent_enabled = True
    bot_settings.save()

    request_body = {
        "bot_response": "connecting to live agent",
        "dispatch_bot_response": False,
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == 'Live Agent Action enabled!'
    assert actual["success"]


def test_get_live_agent_after_enabled_no_bot_settings_enabled():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.live_agent_enabled = False
    bot_settings.save()
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == []
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]


def test_get_live_agent_after_enabled():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.live_agent_enabled = True
    bot_settings.save()
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == {'name': 'live_agent_action', 'bot_response': 'connecting to live agent',
                              'agent_connect_response': 'Connected to live agent',
                              'agent_disconnect_response': 'Agent has closed the conversation',
                              'agent_not_available_response': 'No agents available at this moment. An agent will reply to you shortly.',
                              'dispatch_bot_response': False, 'dispatch_agent_connect_response': True,
                              'dispatch_agent_disconnect_response': True, 'dispatch_agent_not_available_response': True}
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]


def test_enable_live_agent_already_exist():
    request_body = {
        "bot_response": "connecting to live agent",
        "dispatch_bot_response": False,
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == 'Live Agent Action already enabled!'
    assert actual["success"]


def test_update_live_agent():
    BotSettings(bot=pytest.bot, user="integration@demo.ai", live_agent_enabled=True)
    request_body = {
        "bot_response": "connecting to different live agent...",
        "dispatch_bot_response": True,
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == 'Action updated!'
    assert actual["success"]


def test_get_live_agent_after_updated():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == {'name': 'live_agent_action',
                              'bot_response': 'connecting to different live agent...',
                              'agent_connect_response': 'Connected to live agent',
                              'agent_disconnect_response': 'Agent has closed the conversation',
                              'agent_not_available_response': 'No agents available at this moment. An agent will reply to you shortly.',
                              'dispatch_bot_response': True,
                              'dispatch_agent_connect_response': True,
                              'dispatch_agent_disconnect_response': True,
                              'dispatch_agent_not_available_response': True}
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]


def test_disable_live_agent():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent/disable",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Live Agent Action disabled!"
    assert actual["success"]


def test_update_live_agent_does_not_exist():
    request_body = {
        "bot_response": "connecting to different live agent",
        "dispatch_bot_response": True,
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == 'Live agent not enabled for the bot'
    assert not actual["success"]


def test_get_live_agent_after_disabled():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/live_agent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["data"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["success"]




def test_callback_config_add_syntax_error():
    request_body = {
        "name": "callback_1",
        "pyscript_code": "bot_response = Hello World!'",
        "validation_secret": "string",
        "execution_mode": "async"
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual['success']
    assert actual['error_code'] == 422
    assert actual['message'] == 'source code syntax error: unterminated string literal (detected at line 1)'

def test_callback_config_add():
    request_body = {
        "name": "callback_1",
        "pyscript_code": "bot_response = 'Hello World!'",
        "validation_secret": "string",
        "execution_mode": "async"
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    
    actual = response.json()
    actual['data'].pop('validation_secret')
    actual['data'].pop('bot')
    assert actual == {'success': True, 'message': 'Callback added successfully!',
                      'data': {'name': 'callback_1',
                               'pyscript_code': "bot_response = 'Hello World!'",
                               'response_type': 'kairon_json',
                                'expire_in': 0,
                               'shorten_token': False,
                               'standalone': False,
                               'standalone_id_path': '',
                      'execution_mode': 'async' }, 'error_code': 0}


def test_callback_config_add_standalone():
    request_body = {
        "name": "callback_2",
        "pyscript_code": "bot_response = 'Hello World!'",
        "validation_secret": "string",
        "execution_mode": "async",
        "standalone": True,
        "standalone_id_path": "data.id"
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    actual['data'].pop('validation_secret')
    actual['data'].pop('bot')
    assert actual == {'success': True, 'message': 'Callback added successfully!',
                      'data': {'name': 'callback_2',
                               'pyscript_code': "bot_response = 'Hello World!'",
                               'response_type': 'kairon_json',
                               'expire_in': 0,
                               'shorten_token': False,
                               'standalone': True,
                               'standalone_id_path': 'data.id',
                               'execution_mode': 'async'}, 'error_code': 0}


def test_callback_get_standalone_url():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback_standalone_url/callback_2",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.status_code == 200
    actual = response.json()
    assert actual['success']
    assert actual['error_code'] == 0
    assert isinstance(actual['data'], str)
    assert '/callback/s/' in actual['data']
    

def test_callback_config_add_standalone_fail_no_path():
    request_body = {
        "name": "callback_3",
        "pyscript_code": "bot_response = 'Hello World!'",
        "validation_secret": "string",
        "execution_mode": "async",
        "standalone": True
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual == {'success': False, 'message': 'Standalone id path is required!',
                      'data': None, 'error_code': 422}

def test_callback_config_edit_syntex_error():
    request_body = {
        "name": "callback_1",
        "pyscript_code": "bot_response is if = 'Hello World2!'",
        "validation_secret": "string",
        "execution_mode": "async"
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert not actual['success']
    assert actual['error_code'] == 422
    assert actual['message'] == 'source code syntax error: invalid syntax'

def test_callback_config_edit():
    request_body = {
        "name": "callback_1",
        "pyscript_code": "bot_response = 'Hello World2!'",
        "validation_secret": "string",
        "execution_mode": "async"
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    actual['data'].pop('validation_secret')
    actual['data'].pop('bot')
    assert actual == {'success': True, 'message': 'Callback updated successfully!',
                      'data': {'name': 'callback_1', 'pyscript_code': "bot_response = 'Hello World2!'",
                               'response_type': 'kairon_json',
                               'expire_in': 0,
                               'shorten_token': False,
                               'standalone': False,
                               'standalone_id_path': '',
                               'execution_mode': 'async'}, 'error_code': 0}


def test_callback_config_get():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback_list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual['success']
    assert actual['error_code'] == 0
    assert len(actual['data']) == 2
    assert 'callback_1' in actual['data']
    assert 'callback_2' in actual['data']

def test_callback_single_config_get():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback/callback_1",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual['success']
    assert actual['error_code'] == 0
    assert actual['data']['name'] == 'callback_1'
    assert actual['data']['pyscript_code'] == "bot_response = 'Hello World2!'"

def test_callback_config_delete():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/callback/callback_2",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual == {'success': True, 'message': 'Callback deleted successfully!', 'data': None, 'error_code': 0}


def test_callback_action_add_fail_no_callback_config():
    request_body = {
        "name": "callback_action1",
        "callback_name": "callback_12",
        "dynamic_url_slot_name": "string",
        "metadata_list": [],
        "bot_response": "string",
        "dispatch_bot_response": True,
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback/action",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual == {'success': False, 'message': "Callback with name 'callback_12' not found!", 'data': None, 'error_code': 422}



def test_callback_action_add():
    request_body = {
        "name": "callback_1",
        "pyscript_code": "bot_response = 'Hello World!'",
        "validation_secret": "string",
        "execution_mode": "async"
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    request_body = {
            "name": "callback_action1",
            "callback_name": "callback_1",
            "dynamic_url_slot_name": "string",
            "metadata_list": [],
            "bot_response": "string",
            "dispatch_bot_response": True,
    }
    
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/callback/action",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    
    actual = response.json()
    assert actual['success']
    assert actual['message'] == 'Callback action added successfully!'
    data = actual['data']
    assert data['name'] == 'callback_action1'
    assert data['callback_name'] == 'callback_1'


def test_callback_action_update():
    request_body = {
        "name": "callback_action1",
        "callback_name": "callback_1",
        "dynamic_url_slot_name": "new_slot_name",
        "metadata_list": [],
        "bot_response": "string",
        "dispatch_bot_response": True,
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/callback/action",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual['success']
    assert actual['message'] == 'Callback action updated successfully!'


def test_callback_action_get():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback/action/callback_action1",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual['success']
    assert actual['error_code'] == 0
    assert actual['data']['name'] == 'callback_action1'
    assert actual['data']['callback_name'] == 'callback_1'
    assert actual['data']['dynamic_url_slot_name'] == 'new_slot_name'


def test_callback_action_get_all():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback_actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual['success']
    assert actual['error_code'] == 0
    assert isinstance(actual['data'], list)
    assert len(actual['data']) == 1
    assert actual['data'][0]['name'] == 'callback_action1'

def test_callback_get_logs():
    new_log = CallbackLog(
        bot=pytest.bot,
        callback_name="callback_action1",
        channel="channel",
        identifier="identifier",
        pyscript_code="pyscript_code",
        sender_id="sender_id",
        log="callback_log",
        request_data={},
        metadata={},
        callback_url="callback_url",
        callback_source="callback_source",
        status=CallbackRecordStatusType.FAILED.value,
        timestamp=datetime.utcnow()).save()

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/callback_logs",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual['success']
    assert actual['error_code'] == 0
    assert isinstance(actual['data']['logs'], list)
    assert len(actual['data']['logs']) == 1
    assert actual['data']['total_number_of_pages'] == 1

    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/callback",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual['success']
    assert actual['error_code'] == 0
    assert isinstance(actual['data']['logs'], list)
    assert len(actual['data']['logs']) == 1

    from_date = datetime.utcnow().date() - timedelta(days=1)
    to_date = datetime.utcnow().date() + timedelta(days=1)

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/callback/search?from_date={from_date}&to_date={to_date}",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    response_json = search_response.json()
    print("callback", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    assert data['total'] == 1

def test_callback_action_delete():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/callback/action/callback_action1",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual == {'success': True, 'message': 'Callback action deleted successfully!', 'data': None, 'error_code': 0}



def test_add_pyscript_action_empty_name():
    script = "bot_response='hello world'"
    request_body = {
        "name": "",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "name"], "msg": "name is required", "type": "value_error"}
    ]
    assert not actual["success"]


def test_add_pyscript_action_empty_source_code():
    request_body = {
        "name": "test_add_pyscript_action_empty_source_code",
        "source_code": "",
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "source_code"],
            "msg": "source_code is required",
            "type": "value_error",
        }
    ]
    assert not actual["success"]


def test_add_pyscript_action_with_utter():
    script = "bot_response='hello world'"
    request_body = {
        "name": "utter_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Action name cannot start with utter_"
    assert not actual["success"]


def test_add_pyscript_action_syntex_error():
    script = """
    data = [1, 2, 3, 4, 5]
    total = 0
    for i in data:
        total += i
    print(total)
    """
    request_body = {
        "name": "test_add_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "source code syntax error: unexpected indent"
    assert not actual["success"]

def test_add_pyscript_action():
    script= "bot_response='hello world'"
    request_body = {
        "name": "test_add_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

def test_add_pyscript_action_name_already_exist():
    script= "bot_response='hello world'"
    request_body = {
        "name": "test_add_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"
    assert not actual["success"]


def test_add_pyscript_action_case_insensitivity():
    script= "bot_response='hello world'"
    request_body = {
        "name": "TEST_ADD_PYSCRIPT_ACTION_CASE_INSENSITIVITY",
        "source_code": script,
        "dispatch_response": True,
        "set_slots": [
            {"name": "data", "value": "${data.data}", "evaluation_type": "expression"}
        ],
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]


def test_update_pyscript_action_does_not_exist():
    script= "bot_response='hello world'"
    request_body = {
        "name": "test_update_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert (
            actual["message"] == 'Action with name "test_update_pyscript_action" not found'
    )
    assert not actual["success"]


def test_update_pyscript_action_syntex_error():
    script = """
    data = [1, 2, 3, 4, 5, 6, 7]
    total = 0
    for i in data:
        total += i
    print(total)
    """
    request_body = {
        "name": "test_add_pyscript_action",
        "source_code": script,
        "dispatch_response": True,
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "source code syntax error: unexpected indent"
    assert not actual["success"]


def test_update_pyscript_action():
    script = "bot_response='hello world'"
    request_body = {
        "name": "test_add_pyscript_action",
        "source_code": script,
        "dispatch_response": True,
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"
    assert actual["success"]

def test_list_pyscript_actions():
    script1 = "bot_response='hello world'"
    script2 = "bot_response='hello world'"
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]) == 2
    assert actual["data"][0]["name"] == "test_add_pyscript_action"
    assert actual["data"][0]["source_code"] == script1
    assert actual["data"][0]["dispatch_response"]
    assert actual["data"][1]["name"] == "test_add_pyscript_action_case_insensitivity"
    assert actual["data"][1]["source_code"] == script2
    assert actual["data"][1]["dispatch_response"]


def test_delete_pyscript_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/test_delete_pyscript_action_not_exists",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == 'Action with name "test_delete_pyscript_action_not_exists" not found'
    )


def test_delete_pyscript_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/test_add_pyscript_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_list_pyscript_actions_after_action_deleted():
    script2 = "bot_response='hello world'"
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]) == 1
    assert actual["data"][0]["name"] == "test_add_pyscript_action_case_insensitivity"
    assert actual["data"][0]["source_code"] == script2
    assert actual["data"][0]["dispatch_response"]


def test_add_schedule_action_with_invalid_params_list_values():
    schedule_action_data = {
        "name": "test_schedule_action",
        "schedule_time": {"value": "2024-08-06T09:00:00.000+0530", "parameter_type": "value"},
        "timezone": None,
        "schedule_action": "test_pyscript",
        "response_text": "action scheduled",
        "params_list": [
            {
                "value": "param_1",
                "parameter_type": "value",
                "count": 0
            }
        ],
        "dispatch_bot_response": True
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/schedule",
        json=schedule_action_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert not actual["data"]
    assert actual["message"] ==  [
        {'loc': ['body', 'params_list', 0, 'key'], 'msg': 'field required', 'type': 'value_error.missing'}, 
        {'loc': ['body', 'params_list', 0, '__root__'], 'msg': 'key cannot be empty', 'type': 'value_error'}
    ]
    assert actual["error_code"] == 422



def test_add_schedule_action():
    schedule_action_data = {
        "name": "test_schedule_action",
        "schedule_time": {"value": "2024-08-06T09:00:00.000+0530", "parameter_type": "value"},
        "timezone": None,
        "schedule_action": "test_pyscript",
        "response_text": "action scheduled",
        "params_list": [
            {
                "key": "param_key",
                "value": "param_1",
                "parameter_type": "value",
                "count": 0
            }
        ],
        "dispatch_bot_response": True
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/schedule",
        json=schedule_action_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"

def test_add_schedule_action_with_type():
    schedule_action_data = {
        "name": "test_schedule_action2",
        "schedule_time": {"value": "2024-08-06T09:00:00.000+0530", "parameter_type": "value"},
        "timezone": None,
        "schedule_action": "flow_name",
        "response_text": "action scheduled",
        "params_list": [
            {
                "key": "param_key",
                "value": "param_1",
                "parameter_type": "value",
                "count": 0
            }
        ],
        "schedule_action_type": 'flow',
        "dispatch_bot_response": True
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/schedule",
        json=schedule_action_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"

    actions = ScheduleAction.objects(bot=pytest.bot)
    action_data = []
    for act in actions:
        a = {
            'name': act.name,
            'type': act.schedule_action_type
        }
        action_data.append(a)
    expected = [{'name': 'test_schedule_action', 'type': 'pyscript'}, {'name': 'test_schedule_action2', 'type': 'flow'}]
    assert action_data == expected

    ScheduleAction.objects(bot=pytest.bot, name='test_schedule_action2').delete()


def test_add_schedule_action_exists():
    schedule_action_data = {
        "name": "test_schedule_action",
        "schedule_time": {"value": "2024-08-06T09:00:00.000+0530", "parameter_type": "value"},
        "timezone": None,
        "schedule_action": "test_pyscript",
        "response_text": "action scheduled",
        "params_list": [],
        "dispatch_bot_response": True
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/schedule",
        json=schedule_action_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] == False
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"


def test_list_schedule_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/schedule",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    data = actual["data"]
    for item in data:
        item.pop('_id')
    assert data == [
        {
            'name': 'test_schedule_action', 
            'schedule_time': {'value': '2024-08-06T09:00:00.000+0530', 'parameter_type': 'value'}, 
            'timezone': 'UTC', 
            'schedule_action': 'test_pyscript',
            'schedule_action_type': 'pyscript',
            'response_text': 'action scheduled',
            'params_list': [
                {
                    '_cls': 'CustomActionRequestParameters', 
                    'key': 'param_key', 
                    'encrypt': False, 
                    'value': 'param_1',
                    'parameter_type': 'value'
                }
            ], 
            'dispatch_bot_response': True
        }
    ]


def test_update_schedule_action_update_scheduled_action():
    schedule_action_data = {
        "name": "test_schedule_action",
        "schedule_time": {"value": "2024-08-06T09:00:00.000+0530", "parameter_type": "value"},
        "timezone": None,
        "schedule_action": "test_pyscript_new",
        "response_text": "action scheduled, will be notified",
        "params_list": [
            {
                "key": "updated_key",
                "value": "param_2",
                "parameter_type": "value",
                "count": 0
            }
        ],
        "dispatch_bot_response": True
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/schedule",
        json=schedule_action_data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"
    action = ScheduleAction.objects(bot=pytest.bot, name="test_schedule_action", status=True).get()
    action = action.to_mongo().to_dict()
    assert action.get("schedule_action") == "test_pyscript_new"
    assert action.get("response_text") == "action scheduled, will be notified"


def test_list_schedule_action_after_update():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/schedule",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    data = actual["data"]
    for item in data:
        item.pop('_id')
    assert data == [
        {
            'name': 'test_schedule_action', 
            'schedule_time': {'value': '2024-08-06T09:00:00.000+0530', 'parameter_type': 'value'}, 
            'timezone': 'UTC', 
            'schedule_action': 'test_pyscript_new',
            'schedule_action_type': 'pyscript',
            'response_text': 'action scheduled, will be notified', 
            'params_list': [
                {
                    '_cls': 'CustomActionRequestParameters', 
                    'key': 'updated_key',
                    'encrypt': False, 
                    'value': 'param_2', 
                    'parameter_type': 'value'
                }
            ], 
            'dispatch_bot_response': True
        }
    ]


def test_initiate_bsp_onboarding_for_broadcast(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(whatsapp="360dialog", bot=pytest.bot, user="test_user")

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://kairon-api.digite.com"
    )
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )

    with patch(
            "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_account"
    ) as mock_get_account:
        mock_get_account.return_value = "dfghj5678"
        with patch(
                "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.generate_waba_key"
        ) as mock_generate_waba_key:
            mock_generate_waba_key.return_value = "dfghjk5678"
            response = client.post(
                f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/onboarding?clientId=kairon&client=sdfgh5678&channels=['sdfghjk678']",
                headers={
                    "Authorization": pytest.token_type + " " + pytest.access_token
                },
            )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Channel added"
    assert actual["data"].startswith(
        f"http://kairon-api.digite.com/api/bot/whatsapp/{pytest.bot}/e"
    )


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message(mock_event_server):
    config = {
        "name": "test_broadcast",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "status": False,
        "recipients_config": {"recipients": "919876543210,919012345678"},
        "template_config": [
            {
                "template_id": "sales_template",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.broadcast_msg_id = actual["data"]["msg_broadcast_id"]
    assert pytest.broadcast_msg_id


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message_without_collection(mock_event_server):
    config = {
        "name": "broadcast_with_collection_config",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "collection_config": {
            "number_field": "mobile_number",
            "filters_list": [
                {
                    "column": "age",
                    "condition": "lte",
                    "value": "26"
                },
                {
                    "column": "age",
                    "condition": "gt",
                    "value": "22"
                },
                {
                    "column": "name",
                    "condition": "nin",
                    "value": [
                        "Mahesh",
                        "Hitesh"
                    ]
                }
            ],
            "field_mapping": {
                "brochure_pdf": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{name}"
                            }
                        ]
                    },
                    {
                        "type": "body",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{status}"
                            }
                        ]
                    }
                ]
            }
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'collection_config', 'collection'],
                                 'msg': 'field required', 'type': 'value_error.missing'}]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message_without_number_field(mock_event_server):
    config = {
        "name": "broadcast_with_collection_config",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "collection_config": {
            "collection": "crop_details",
            "filters_list": [
                {
                    "column": "age",
                    "condition": "lte",
                    "value": "26"
                },
                {
                    "column": "age",
                    "condition": "gt",
                    "value": "22"
                },
                {
                    "column": "name",
                    "condition": "nin",
                    "value": [
                        "Mahesh",
                        "Hitesh"
                    ]
                }
            ],
            "field_mapping": {
                "brochure_pdf": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{name}"
                            }
                        ]
                    },
                    {
                        "type": "body",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{status}"
                            }
                        ]
                    }
                ]
            }
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'collection_config', 'number_field'],
                                 'msg': 'field required', 'type': 'value_error.missing'}]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message_without_filters_list(mock_event_server):
    config = {
        "name": "broadcast_without_filters_list",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "collection_config": {
            "collection": "crop_details",
            "number_field": "mobile_number",
            "filters_list": [],
            "field_mapping": {
                "brochure_pdf": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{name}"
                            }
                        ]
                    },
                    {
                        "type": "body",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{status}"
                            }
                        ]
                    }
                ]
            }
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.broadcast_msg_id3 = actual["data"]["msg_broadcast_id"]
    assert pytest.broadcast_msg_id3


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message_without_field_mapping(mock_event_server):
    config = {
        "name": "broadcast_with_collection_config",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "collection_config": {
            "collection": "crop_details",
            "number_field": "mobile_number",
            "filters_list": [
                {
                    "column": "age",
                    "condition": "lte",
                    "value": "26"
                },
                {
                    "column": "age",
                    "condition": "gt",
                    "value": "22"
                },
                {
                    "column": "name",
                    "condition": "nin",
                    "value": [
                        "Mahesh",
                        "Hitesh"
                    ]
                }
            ],
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'collection_config', 'field_mapping'],
                                 'msg': 'field required', 'type': 'value_error.missing'}]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_broadcast_message_with_collection_config(mock_event_server):
    config = {
        "name": "broadcast_with_collection_config",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "collection_config": {
            "collection": "crop_details",
            "number_field": "mobile_number",
            "filters_list": [
                {
                    "column": "age",
                    "condition": "lte",
                    "value": "26"
                },
                {
                    "column": "age",
                    "condition": "gt",
                    "value": "22"
                },
                {
                    "column": "name",
                    "condition": "nin",
                    "value": [
                        "Mahesh",
                        "Hitesh"
                    ]
                }
            ],
            "field_mapping": {
                "brochure_pdf": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{name}"
                            }
                        ]
                    },
                    {
                        "type": "body",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{status}"
                            }
                        ]
                    }
                ]
            }
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.broadcast_msg_id2 = actual["data"]["msg_broadcast_id"]
    assert pytest.broadcast_msg_id2


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_resend_broadcast_message(mock_event_server):
    from kairon.shared.chat.broadcast.data_objects import MessageBroadcastSettings

    settings = MessageBroadcastSettings.objects(id=pytest.broadcast_msg_id, bot=pytest.bot, status=True).get()
    settings.status = False
    settings.save()

    config = {
        "name": "test_broadcast",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "919876543210,919012345678"},
        "template_config": [
            {
                "template_id": "sales_template",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/resend/{pytest.broadcast_msg_id}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Resending Broadcast!"


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_resend_broadcast_message_with_retry_limit_exceeded(mock_event_server, monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True),
                           retry_broadcasting_limit=3)

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    from kairon.shared.chat.broadcast.data_objects import MessageBroadcastSettings

    settings = MessageBroadcastSettings.objects(id=pytest.broadcast_msg_id, bot=pytest.bot, status=False).get()
    settings.retry_count = 3
    settings.save()

    config = {
        "name": "test_broadcast",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "919876543210,919012345678"},
        "template_config": [
            {
                "template_id": "sales_template",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/resend/{pytest.broadcast_msg_id}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Retry Broadcasting limit reached!"


def test_list_broadcast():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["schedules"][0].pop("timestamp")
    actual["data"]["schedules"][0].pop("user")
    actual["data"]["schedules"][1].pop("timestamp")
    actual["data"]["schedules"][1].pop("user")
    actual["data"]["schedules"][2].pop("timestamp")
    actual["data"]["schedules"][2].pop("user")
    print(actual["data"])
    assert actual["data"] == {
        "schedules": [
            {
                '_id': pytest.broadcast_msg_id,
                'name': 'test_broadcast',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static', 'recipients_config': {'recipients': '919876543210,919012345678'},
                'template_config': [{'template_id': 'sales_template', 'language': 'en'}],
                'collection_config': {},
                'retry_count': 3,
                'bot': pytest.bot,
                'status': False
            },
            {
                '_id': pytest.broadcast_msg_id3,
                'name': 'broadcast_without_filters_list',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static',
                'recipients_config': {'recipients': ''},
                'template_config': [{'template_id': 'brochure_pdf', 'language': 'hi'}],
                'collection_config': {
                    'collection': 'crop_details',
                    'number_field': 'mobile_number',
                    'filters_list': [],
                    'field_mapping': {
                        'brochure_pdf': [
                            {'type': 'header', 'parameters': [{'type': 'text', 'text': '{name}'}]},
                            {'type': 'body', 'parameters': [{'type': 'text', 'text': '{status}'}]}
                        ]
                    }
                },
                'retry_count': 0,
                'bot': pytest.bot,
                'status': True
            },
            {
                '_id': pytest.broadcast_msg_id2,
                'name': 'broadcast_with_collection_config',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static',
                'recipients_config': {'recipients': ''},
                'template_config': [
                    {'template_id': 'brochure_pdf', 'language': 'hi'}
                ],
                'collection_config': {
                    'collection': 'crop_details',
                    'number_field': 'mobile_number',
                    'filters_list': [
                        {'column': 'age', 'condition': 'lte', 'value': '26'},
                        {'column': 'age', 'condition': 'gt', 'value': '22'},
                        {'column': 'name', 'condition': 'nin', 'value': ['Mahesh', 'Hitesh']}
                    ],
                    'field_mapping': {
                        'brochure_pdf': [
                            {'type': 'header', 'parameters': [{'type': 'text', 'text': '{name}'}]},
                            {'type': 'body', 'parameters': [{'type': 'text', 'text': '{status}'}]}
                        ]
                    }
                },
                'retry_count': 0,
                'bot': pytest.bot,
                'status': True
            }
        ]
    }


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_update_broadcast_with_collection_config(mock_event_server):
    config = {
        "name": "update_broadcast_with_collection_config",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": ""},
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "21 11 * * *",
            "timezone": "Asia/Kolkata",
        },
        "collection_config": {
            "collection": "crop_details",
            "number_field": "contact_number",
            "filters_list": [
                {
                    "column": "age",
                    "condition": "gte",
                    "value": "26"
                },
                {
                    "column": "age",
                    "condition": "lt",
                    "value": "22"
                },
                {
                    "column": "name",
                    "condition": "nin",
                    "value": [
                        "Mahesh",
                        "Hitesh"
                    ]
                }
            ],
            "field_mapping": {
                "brochure_pdf": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{crop}"
                            }
                        ]
                    },
                    {
                        "type": "body",
                        "parameters": [
                            {
                                "type": "text",
                                "text": "{status}"
                            }
                        ]
                    }
                ]
            }
        },
        "retry_count": 0,
        "template_config": [
            {
                'language': 'hi',
                "template_id": "brochure_pdf",
            }
        ]
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.broadcast_msg_id2}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast updated!"


def test_list_broadcast_after_update():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["schedules"][0].pop("timestamp")
    actual["data"]["schedules"][0].pop("user")
    actual["data"]["schedules"][1].pop("timestamp")
    actual["data"]["schedules"][1].pop("user")
    actual["data"]["schedules"][2].pop("timestamp")
    actual["data"]["schedules"][2].pop("user")
    assert actual["data"] == {
        "schedules": [
            {
                '_id': pytest.broadcast_msg_id,
                'name': 'test_broadcast',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static', 'recipients_config': {'recipients': '919876543210,919012345678'},
                'template_config': [{'template_id': 'sales_template', 'language': 'en'}],
                'collection_config': {},
                'retry_count': 3,
                'bot': pytest.bot,
                'status': False
            },
            {
                '_id': pytest.broadcast_msg_id3,
                'name': 'broadcast_without_filters_list',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static',
                'recipients_config': {'recipients': ''},
                'template_config': [{'template_id': 'brochure_pdf', 'language': 'hi'}],
                'collection_config': {
                    'collection': 'crop_details',
                    'number_field': 'mobile_number',
                    'filters_list': [],
                    'field_mapping': {
                        'brochure_pdf': [
                            {'type': 'header', 'parameters': [{'type': 'text', 'text': '{name}'}]},
                            {'type': 'body', 'parameters': [{'type': 'text', 'text': '{status}'}]}
                        ]
                    }
                },
                'retry_count': 0,
                'bot': pytest.bot,
                'status': True
            },
            {
                '_id': pytest.broadcast_msg_id2,
                'name': 'update_broadcast_with_collection_config',
                'connector_type': 'whatsapp',
                'broadcast_type': 'static',
                'recipients_config': {'recipients': ''},
                "scheduler_config": {
                    "expression_type": "cron",
                    "schedule": "21 11 * * *",
                    "timezone": "Asia/Kolkata",
                },
                'template_config': [
                    {'template_id': 'brochure_pdf', 'language': 'hi'}
                ],
                'collection_config': {
                    'collection': 'crop_details',
                    'number_field': 'contact_number',
                    'filters_list': [
                        {'column': 'age', 'condition': 'gte', 'value': '26'},
                        {'column': 'age', 'condition': 'lt', 'value': '22'},
                        {'column': 'name', 'condition': 'nin', 'value': ['Mahesh', 'Hitesh']}
                    ],
                    'field_mapping': {
                        'brochure_pdf': [
                            {'type': 'header', 'parameters': [{'type': 'text', 'text': '{crop}'}]},
                            {'type': 'body', 'parameters': [{'type': 'text', 'text': '{status}'}]}
                        ]
                    }
                },
                'retry_count': 0,
                'bot': pytest.bot,
                'status': True
            }
        ]
    }


@patch("kairon.shared.utils.Utility.delete_scheduled_event", autospec=True)
def test_delete_message_broadcast(mock_event_server):
    from kairon.shared.chat.broadcast.data_objects import MessageBroadcastSettings

    settings = MessageBroadcastSettings.objects(id=pytest.broadcast_msg_id, bot=pytest.bot, status=False).get()
    settings.status = True
    settings.save()

    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.broadcast_msg_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast removed!"


def test_get_broadcast_logs_with_resend_broadcasts():
    from kairon.shared.chat.broadcast.data_objects import MessageBroadcastLogs

    ref_id = ObjectId().__str__()
    timestamp = datetime.utcnow()
    MessageBroadcastLogs(
        **{
            "reference_id": ref_id,
            "log_type": "common",
            "bot": pytest.bot,
            "status": EVENT_STATUS.COMPLETED.value,
            "user": "test_user",
            "broadcast_id": pytest.broadcast_msg_id,
            "recipients": ["919876543210", "918958030541"],
            "timestamp": timestamp,
        }
    ).save()
    timestamp = timestamp + timedelta(minutes=2)
    MessageBroadcastLogs(
        **{
            "reference_id": ref_id,
            "log_type": "resend",
            "bot": pytest.bot,
            "status": STATUSES.SUCCESS.value,
            "api_response": {
                "contacts": [
                    {"input": "+55123456789", "status": "valid", "wa_id": "55123456789"}
                ]
            },
            "recipient": "919876543210",
            "template_params": [
                {
                    "type": "header",
                    "parameters": [
                        {
                            "type": "document",
                            "document": {
                                "link": "https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm",
                                "filename": "Brochure.pdf",
                            },
                        }
                    ],
                }
            ],
            "timestamp": timestamp,
            "retry_count": 1
        }
    ).save()
    MessageBroadcastLogs(
        **{
            "reference_id": ref_id,
            "log_type": "resend",
            "bot": pytest.bot,
            "status": STATUSES.SUCCESS.value,
            "api_response": {
                "contacts": [
                    {"input": "+55123456789", "status": "valid", "wa_id": "55123456789"}
                ]
            },
            "recipient": "918958030541",
            "template_params": [
                {
                    "type": "header",
                    "parameters": [
                        {
                            "type": "document",
                            "document": {
                                "link": "https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm",
                                "filename": "Brochure.pdf",
                            },
                        }
                    ],
                }
            ],
            "timestamp": timestamp,
            "retry_count": 2
        }
    ).save()
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/logs?log_type=resend&retry_count=1&reference_id={ref_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["logs"][0].pop("timestamp")
    assert actual["data"]["logs"] == [
        {
            'reference_id': ref_id,
            'log_type': 'resend',
            'bot': pytest.bot,
            'status': STATUSES.SUCCESS.value,
            'api_response': {
                'contacts': [
                    {
                        'input': '+55123456789',
                        'status': 'valid',
                        'wa_id': '55123456789'
                    }
                ]
            },
            'recipient': '919876543210',
            'template_params': [
                {
                    'type': 'header',
                    'parameters': [
                        {
                            'type': 'document',
                            'document': {
                                'link': 'https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm',
                                'filename': 'Brochure.pdf'
                            }
                        }
                    ]
                }
            ],
            'retry_count': 1
        }
    ]
    assert actual["data"]["total_count"] == 1

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/logs?reference_id={ref_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["logs"][0].pop("timestamp")
    actual["data"]["logs"][1].pop("timestamp")
    actual["data"]["logs"][2].pop("timestamp")
    assert actual["data"] == {
        'logs': [
            {
                'reference_id': ref_id,
                'log_type': 'resend',
                'bot': pytest.bot,
                'status': STATUSES.SUCCESS.value,
                'api_response': {
                    'contacts': [
                        {
                            'input': '+55123456789',
                            'status': 'valid',
                            'wa_id': '55123456789'
                        }
                    ]
                },
                'recipient': '919876543210',
                'template_params': [
                    {
                        'type': 'header',
                        'parameters': [
                            {
                                'type': 'document',
                                'document': {
                                    'link': 'https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm',
                                    'filename': 'Brochure.pdf'
                                }
                            }
                        ]
                    }
                ],
                'retry_count': 1
            },
            {
                'reference_id': ref_id,
                'log_type': 'resend',
                'bot': pytest.bot,
                'status': STATUSES.SUCCESS.value,
                'api_response': {
                    'contacts': [
                        {
                            'input': '+55123456789',
                            'status': 'valid',
                            'wa_id': '55123456789'
                        }
                    ]
                },
                'recipient': '918958030541',
                'template_params': [
                    {
                        'type': 'header',
                        'parameters': [
                            {
                                'type': 'document',
                                'document': {
                                    'link': 'https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm',
                                    'filename': 'Brochure.pdf'
                                }
                            }
                        ]
                    }
                ],
                'retry_count': 2
            },
            {
                'reference_id': ref_id,
                'log_type': 'common',
                'bot': pytest.bot,
                'status': EVENT_STATUS.COMPLETED.value,
                'user': 'test_user',
                'broadcast_id': pytest.broadcast_msg_id,
                'recipients': [
                    '919876543210',
                    '918958030541'
                ]
            }
        ],
        'total_count': 3
    }


def test_list_available_actions():
    script = "bot_response='hello world'"
    request_body = {
        "name": "test_list_available_actions_pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual=response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual['data'][-1]['name'] == 'test_list_available_actions_pyscript_action'
    assert actual['data'][-1]['type'] == 'pyscript_action'


def test_get_client_config_url_with_ip_info(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    with patch(
            "kairon.shared.plugins.ipinfo.IpInfoTracker.execute"
    ) as mock_geo_location:
        mock_geo_location.return_value = {"City": "Mumbai", "Network": "CATO"}
        response = client.get(
            f"/api/bot/{pytest.bot}/chat/client/config/url",
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["data"]
        pytest.url = actual["data"]

    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/user_metrics",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["total"] == 2
    assert actual["data"]["logs"][0]["geo_location"] == {
        "City": "Mumbai",
        "Network": "CATO",
    }
    assert actual["data"]["logs"][0]["ip_info"] == "testclient"
    assert actual["data"]["logs"][0]["metric_type"] == "user_metrics"
    assert actual["data"]["logs"][0]["bot"] == pytest.bot


def test_metadata_upload_api(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "details", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    response_schema = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_schema = response_schema.json()
    assert actual_schema["data"][0]['collection_name'] == 'details'
    assert actual_schema["data"][0]['metadata'][0] == {'column_name': 'details', 'data_type': 'str',
                                                       'enable_search': True, 'create_embeddings': True}
    assert actual_schema["error_code"] == 0

    payload = {
        "data": {"details": "Nupur"},
        "collection": "Details",
        "content_type": "json"}
    payload_response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload_actual = payload_response.json()
    pytest.cognition_id = payload_actual["data"]["_id"]
    assert payload_actual["message"] == "Record saved!"
    assert payload_actual["error_code"] == 0

    response_payload = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition?collection=Details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_payload = response_payload.json()
    assert actual_payload["success"]
    assert actual_payload["message"] is None
    assert actual_payload["error_code"] == 0
    assert actual_payload["data"]['rows'][0]['collection'] == 'details'
    assert actual_payload["data"]['rows'][0]['data'] == {'details': 'Nupur'}
    assert actual_payload["data"]['total'] == 1

    response_one = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "details_one", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details_one"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_one = response_one.json()
    pytest.schema_id_one = actual_one["data"]["_id"]
    assert actual_one["message"] == "Schema saved!"
    assert actual_one["data"]["_id"]
    assert actual_one["error_code"] == 0

    response_two = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "details_two", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details_two"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_two = response_two.json()

    pytest.schema_id_two = actual_two["data"]["_id"]
    assert actual_two["message"] == "Schema saved!"
    assert actual_two["data"]["_id"]
    assert actual_two["error_code"] == 0

    response_three = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "details_three", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details_three"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_three = response_three.json()
    assert actual_three["message"] == "Collection limit exceeded!"
    assert not actual_three["data"]
    assert actual_three["error_code"] == 422

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.schema_id_one}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.schema_id_two}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )

    response_four = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "details", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_four = response_four.json()
    assert not actual_four["success"]
    assert actual_four["message"] == "Collection already exists!"
    assert actual_four["data"] is None
    assert actual_four["error_code"] == 422


def test_metadata_upload_api_column_limit_exceeded():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.cognition_columns_per_collection_limit = 5
    bot_settings.save()
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "tech", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "age", "data_type": "int", "enable_search": True, "create_embeddings": False},
                {"column_name": "color", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "name", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "gender", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "experience", "data_type": "str", "enable_search": True, "create_embeddings": True}
            ],
            "collection_name": "test_metadata_upload_api_column_limit_exceeded"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Column limit exceeded for collection!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_metadata_upload_api_same_column_in_schema():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "tech", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "ai", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "ds", "data_type": "str", "enable_search": True, "create_embeddings": True},
                {"column_name": "tech", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "test_metadata_upload_api_same_column_in_schema"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Columns cannot be same in the schema!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_metadata_upload_invalid_data_type():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "test_metadata_upload_invalid_data_type", "data_type": "bool", "enable_search": True,
                 "create_embeddings": True}],
            "collection_name": "test_metadata_upload_invalid_data_type"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == [{'loc': ['body', 'metadata', 0, 'data_type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'str', 'int', 'float'",
                                  'type': 'type_error.enum', 'ctx': {'enum_values': ['str', 'int', 'float']}},
                                 {'loc': ['body', 'metadata', 0, '__root__'],
                                  'msg': 'Only str, int and float data types are supported', 'type': 'value_error'}]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_metadata_upload_column_name_empty():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "", "data_type": "int", "enable_search": True, "create_embeddings": True}],
            "collection_name": "test_metadata_upload_column_name_empty"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["message"] == [
        {'loc': ['body', 'metadata', 0, '__root__'], 'msg': 'Column name cannot be empty', 'type': 'value_error'}]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_get_payload_metadata():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual['data'][0]['metadata'][0] == {'column_name': 'details', 'data_type': 'str', 'enable_search': True,
                                                'create_embeddings': True}
    assert actual['data'][0]['collection_name'] == 'details'


def test_delete_payload_content_metadata():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.schema_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["message"] == "Schema will be deleted soon!"
    assert actual["data"] is None
    assert actual["error_code"] == 0


def test_metadata_upload_api_and_delete_with_no_cognition_data(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "country", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "Details"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    pytest.schema_id = actual["data"]["_id"]
    assert actual["message"] == "Schema saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    response_one = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.schema_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_one = response_one.json()
    assert actual_one["success"]
    assert actual_one["message"] == "Schema will be deleted soon!"
    assert actual_one["data"] is None
    assert actual_one["error_code"] == 0


def test_delete_payload_content_metadata_does_not_exist():
    schema_id = '61f3a2c0aef98d5b4c58e90f'
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{schema_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Schema does not exists!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_get_payload_content_metadata_not_exists():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] is None
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_delete_schema_attached_to_prompt_action(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    action = {'name': 'test_delete_schema_attached_to_prompt_action',
              'llm_prompts': [{'name': 'System Prompt', 'data': 'You are a personal assistant.', 'type': 'system',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Similarity Prompt',
                               'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                               'type': 'user', 'source': 'bot_content', 'data': 'python', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'If there is no specific query, assume that user is aking about java programming.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True}],
              'instructions': ['Answer in a short manner.', 'Keep it simple.'],
              'num_bot_responses': 5,
              "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
              "llm_type": DEFAULT_LLM,
              "hyperparameters": Utility.get_default_llm_hyperparameters()}
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    response_one = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": None,
            "collection_name": "Python"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response_one.json()

    pytest.delete_schema_id = actual["data"]["_id"]

    response_two = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.delete_schema_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_two = response_two.json()

    assert not actual_two["success"]
    assert actual_two[
               "message"] == 'Cannot remove collection python linked to action "test_delete_schema_attached_to_prompt_action"!'
    assert actual_two["data"] is None
    assert actual_two["error_code"] == 422

    response_three = client.delete(
        f"/api/bot/{pytest.bot}/action/test_delete_schema_attached_to_prompt_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual_three = response_three.json()
    assert actual_three['message'] == 'Action deleted'

    response_four = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.delete_schema_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_four = response_four.json()
    assert actual_four['message'] == 'Schema will be deleted soon!'


def test_content_upload_api_with_gpt_feature_disabled():
    payload = {
        "data": "Data refers to any collection of facts, statistics, or information that can be analyzed or "
                "used to inform decision-making. Data can take many forms, including text, numbers, images, "
                "audio, and video.",
        "content_type": "text",
        "collection": "Data_details"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["message"] == "Faq feature is disabled for the bot! Please contact support."
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_content_upload_api(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    response_one = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "collection_name": "Details"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_one = response_one.json()
    pytest.content_collection_id = actual_one["data"]["_id"]
    payload = {
        "data": "Data refers to any collection of facts, statistics, or information that can be analyzed or "
                "used to inform decision-making. Data can take many forms, including text, numbers, images, "
                "audio, and video.",
        "content_type": "text",
        "collection": "Details"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.content_id_text = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    payload_two = {
        "data": "Data refers to any collection of facts, statistics, or information that can be analyzed.",
        "content_type": "text",
        "collection": "payload_two"}
    response_two = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload_two,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response_two.json()
    assert actual["message"] == "Collection does not exist!"
    assert not actual["data"]
    assert actual["error_code"] == 422

    response_three = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "color", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "response_two"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload_three = {
        "data": "Data can take many forms, including text, numbers, images, audio, and video.",
        "content_type": "text",
        "collection": "response_two"}
    response_four = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload_three,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response_four.json()
    assert actual["message"] == "Text content type does not have schema!"
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_content_upload_api_invalid_atleast_ten_words(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    payload = {
        "data": "Blockchain technology is an advanced"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Content should contain atleast 10 words."
    assert not actual["success"]
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_content_upload_empty_data_text(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = {
        "data": "",
        "content_type": "text",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == [{'loc': ['body', '__root__'], 'msg': 'data cannot be empty', 'type': 'value_error'}]


def test_content_upload_api_without_collection(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = {
        "data": "Blockchain technology is an advanced database mechanism that allows transparent information sharing within a business network."}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.content_id_no_collection = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0


def test_content_update_api():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.content_id_text}",
        json={
            "row_id": pytest.content_id_text,
            "data": "AWS Fargate is a serverless compute engine for containers that allows you to run "
                    "Docker containers without having to manage the underlying EC2 instances. With Fargate, "
                    "you can focus on developing and deploying your applications rather than managing the infrastructure.",
            "collection": "Details",
            "content_type": "text"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Record updated!"
    assert actual["error_code"] == 0


def test_content_update_api_collection_does_not_exist():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.content_id_text}",
        json={
            "row_id": pytest.content_id_text,
            "data": "Docker containers without having to manage the underlying EC2 instances.",
            "collection": "test_content_update_api_collection_does_not_exist",
            "content_type": "text"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}

    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Collection does not exist!"
    assert actual["error_code"] == 422


def test_content_update_api_invalid():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.content_id_text}",
        json={
            "row_id": pytest.content_id_text,
            "data": "AWS Fargate is a serverless compute engine.",
            "collection": "Details",
            "content_type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Content should contain atleast 10 words."
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_content_update_api_already_exist():
    content_id = "6009cb85e65f6dce28fb3e51"
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{content_id}",
        json={
            "row_id": content_id,
            "data": "AWS Fargate is a serverless compute engine for containers that allows you to run "
                    "Docker containers without having to manage the underlying EC2 instances. With Fargate, "
                    "you can focus on developing and deploying your applications rather than managing the infrastructure.",
            "collection": "Details",
            "content_type": "text"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Payload data already exists!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_content_update_api_id_not_found():
    content_id = "594ced02ed345b2b049222c5"
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{content_id}",
        json={
            "row_id": content_id,
            "data": "Artificial intelligence (AI) involves using computers to do things that traditionally require human "
                    "intelligence. AI can process large amounts of data in ways that humans cannot. The goal for AI is "
                    "to be able to do things like recognize patterns, make decisions, and judge like humans.",
            "collection": "Details",
            "content_type": "text"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Payload with given id not found!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


@mock.patch('kairon.shared.cognition.processor.CognitionDataProcessor.list_cognition_data', autospec=True)
@mock.patch('kairon.shared.cognition.processor.CognitionDataProcessor.get_cognition_data', autospec=True)
def test_list_cognition_data(mock_get_cognition_data, mock_list_cognition_data):
    cognition_data = [{'vector_id': 1,
                       'row_id': '65266ff16f0190ca4fd09898',
                       'data': 'AWS Fargate is a serverless compute engine for containers that allows you to run Docker containers without having to manage the underlying EC2 instances. With Fargate, you can focus on developing and deploying your applications rather than managing the infrastructure.',
                       'content_type': 'text',
                       'collection': 'aws', 'user': '"integration@demo.ai"', 'bot': pytest.bot}]
    row_count = 1

    def _list_cognition_data(*args, **kwargs):
        return cognition_data

    mock_list_cognition_data.return_value = _list_cognition_data()

    def _get_cognition_data(*args, **kwargs):
        return cognition_data, row_count

    mock_get_cognition_data.return_value = _get_cognition_data()

    filter_query = 'without having to manage'
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition?data={filter_query}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]['rows'][0]['collection'] == 'aws'
    assert actual["data"]['total'] == 1


def test_get_content_without_data():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]['rows'][0]['collection'] == None
    assert actual["data"]['rows'][0][
               'data'] == 'Blockchain technology is an advanced database mechanism that allows transparent information sharing within a business network.'
    assert actual["data"]['total'] == 1


def test_delete_content():
    response_one = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.content_id_no_collection}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_one = response_one.json()
    assert actual_one["success"]
    assert actual_one["message"] == "Record deleted!"
    assert actual_one["data"] is None
    assert actual_one["error_code"] == 0

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.content_id_text}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Record deleted!"
    assert actual["data"] is None
    assert actual["error_code"] == 0


def test_delete_content_does_not_exist():
    content_id = "635981f6e40f61599e000064"
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/{content_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Payload does not exists!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_get_content_not_exists():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["message"] is None
    assert actual["error_code"] == 0
    assert actual["data"] == {'rows': [], 'total': 0}


def test_delete_payload_content_collection():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.content_collection_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["message"] == "Schema will be deleted soon!"
    assert actual["data"] is None
    assert actual["error_code"] == 0


def test_payload_upload_api_with_gpt_feature_disabled():
    payload = {
        "data": {"name": "Nupur", "age": 25, "city": "Bengaluru"},
        "content_type": "json"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert (
            actual["message"]
            == "Faq feature is disabled for the bot! Please contact support."
    )
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_payload_upload_api(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    metadata = {
        "metadata": [{"column_name": "details", "data_type": "str", "enable_search": True, "create_embeddings": True}],
        "collection_name": "Details",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload = {
        "data": {"details": "AWS"},
        "content_type": "json",
        "collection": "Details"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.payload_id = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0


def test_payload_upload_collection_does_not_exists(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    payload = {
        "data": {"name": "Ram", "age": 23, "color": "red"},
        "content_type": "json",
        "collection": "test_payload_upload_collection_does_not_exists"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == 'Collection does not exist!'


def test_payload_upload_metadata_missing(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = {
        "data": {"city": "Pune", "color": "red"},
        "content_type": "json",
        "collection": "Details"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == 'Columns do not exist in the schema!'


def test_payload_upload_metadata_invalid_data_type(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    metadata = {
        "metadata": [{"column_name": "age", "data_type": "int", "enable_search": True, "create_embeddings": True}],
        "collection_name": "test_payload_upload_metadata_invalid_data_type"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json=metadata,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    payload = {
        "data": {"age": "Twenty-Three"},
        "content_type": "json",
        "collection": "test_payload_upload_metadata_invalid_data_type"
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Invalid data type for 'age': Expected integer value"


def test_payload_updated_api_collection_does_not_exists():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.payload_id}",
        json={
            "row_id": pytest.payload_id,
            "data": {"details": "data science"},
            "collection": "test_payload_updated_api_collection_does_not_exists",
            "content_type": "json"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}

    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Collection does not exist!"
    assert actual["error_code"] == 422


def test_payload_upload_json_data_content_type_text(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = {
        "data": {"age": 23},
        "content_type": "text",
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == [
        {'loc': ['body', '__root__'], 'msg': 'content type and type of data do not match!', 'type': 'value_error'}]


def test_payload_updated_api():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.payload_id}",
        json={
            "row_id": pytest.payload_id,
            "data": {"details": "data science"},
            "collection": "Details",
            "content_type": "json"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Record updated!"
    assert actual["error_code"] == 0


def test_payload_content_update_api_already_exists(monkeypatch):
    payload_id = "64b3b810efa74e8863544af3"

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{payload_id}",
        json={
            "row_id": payload_id,
            "data": {"details": "data science"},
            "content_type": "json",
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert not actual["success"]
    assert actual["message"] == "Payload data already exists!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_payload_content_update_api_id_not_found():
    payload_id = "594ced02ed345b2b049222c5"
    response = client.put(
        url=f"/api/bot/{pytest.bot}/data/cognition/{payload_id}",
        json={
            "row_id": payload_id,
            "data": {"details": "data"},
            "content_type": "json",
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}

    )
    actual = response.json()

    assert not actual["success"]
    assert actual["message"] == "Payload with given id not found!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_get_payload_content():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition?collection=Details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]['rows'][0]['data'] == {'details': 'data science'}
    assert actual["data"]['rows'][0]['collection'] == 'details'
    assert actual["data"]['total'] == 1


def test_delete_payload_content():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/{pytest.payload_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()

    assert actual["success"]
    assert actual["message"] == "Record deleted!"
    assert actual["data"] is None
    assert actual["error_code"] == 0


def test_delete_payload_content_does_not_exist():
    payload_id = "61f3a2c0aef88d5b4c58e90f"
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/{payload_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Payload does not exists!"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_get_payload_content_not_exists():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] is None
    assert actual["error_code"] == 0
    assert actual["data"] == {"rows": [], "total": 0}


def test_get_kairon_faq_action_with_no_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/prompt",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["data"] == []


def test_add_prompt_action_with_utter(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "utter_test_add_prompt_action", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action name cannot start with utter_"
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_similarity_threshold(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action_with_invalid_similarity_threshold",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                'hyperparameters': {"top_results": 10, "similarity_threshold": 1.70},
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [{'loc': ['body', 'llm_prompts', 1, 'hyperparameters', '__root__'],
                                  'msg': 'similarity_threshold should be within 0.3 and 1', 'type': 'value_error'}]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_top_results(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action_with_invalid_top_results",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                'hyperparameters': {"top_results": 40, "similarity_threshold": 0.70},
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [{'loc': ['body', 'llm_prompts', 1, 'hyperparameters', '__root__'],
                                  'msg': 'top_results should not be greater than 30', 'type': 'value_error'}]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_query_prompt():
    action = {
        "name": "test_add_prompt_action_with_invalid_query_prompt",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "history",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Query prompt must have static source!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_num_bot_responses():
    action = {
        "name": "test_add_prompt_action_with_invalid_num_bot_responses",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "num_bot_responses": 10,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "num_bot_responses"],
            "msg": "num_bot_responses should not be greater than 5",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_system_prompt_source():
    action = {
        "name": "test_add_prompt_action_with_invalid_system_prompt_source",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "history",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "System prompt must have static source!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_multiple_system_prompt():
    action = {
        "name": "test_add_prompt_action_with_multiple_system_prompt",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "instructions": "Answer question based on the context below.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Only one system prompt can be present!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_empty_llm_prompt_name():
    action = {
        "name": "test_add_prompt_action_with_empty_llm_prompt_name",
        "llm_prompts": [
            {
                "name": "",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Name cannot be empty!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_empty_data_for_static_prompt():
    action = {
        "name": "test_add_prompt_action_with_empty_data_for_static_prompt",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "data is required for static prompts!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_multiple_history_source_prompts():
    action = {
        "name": "test_add_prompt_action_with_multiple_history_source_prompts",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "History Prompt",
                "type": "user",
                "source": "history",
                "is_enabled": True,
            },
            {
                "name": "Analytical Prompt",
                "type": "user",
                "source": "history",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Only one history source can be present!",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_gpt_feature_disabled():
    action = {
        "name": "test_add_prompt_action_with_gpt_feature_disabled",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "top_results": 10,
        "similarity_threshold": 0.70,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert (
            actual["message"]
            == "Faq feature is disabled for the bot! Please contact support."
    )
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_llm_type(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action_with_invalid_llm_type", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": "test",
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not DeepDiff(actual["message"],
                        [{'loc': ['body', 'llm_type'], 'msg': 'Invalid llm type', 'type': 'value_error'}],
                        ignore_order=True)
    assert not actual["success"]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_add_prompt_action_with_invalid_hyperameters(monkeypatch):
    temp = Utility.get_default_llm_hyperparameters()
    temp['temperature'] = 3.0

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action_with_invalid_hyperameters", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": temp
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not DeepDiff(actual["message"],
                        [{'loc': ['body', 'hyperparameters'],
                          'msg': "['temperature']: 3.0 is greater than the maximum of 2.0", 'type': 'value_error'}],
                        ignore_order=True)
    assert not actual["success"]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_add_prompt_action(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_prompt_action_already_exist(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action exists!"
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_prompt_action_does_not_exist():
    action = {
        "name": "test_update_prompt_action_does_not_exist",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/61512cc2c6219f0aae7bba3d",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action not found"
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_prompt_action_with_invalid_similarity_threshold():
    action = {
        "name": "test_update_prompt_action_with_invalid_similarity_threshold",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                'hyperparameters': {"top_results": 9, "similarity_threshold": 1.50},
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": "updated_failure_message",
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [{'loc': ['body', 'llm_prompts', 1, 'hyperparameters', '__root__'],
                                  'msg': 'similarity_threshold should be within 0.3 and 1', 'type': 'value_error'}]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_prompt_action_with_invalid_top_results():
    action = {
        "name": "test_update_prompt_action_with_invalid_top_results",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection"
                , 'hyperparameters': {"top_results": 39, "similarity_threshold": 0.50},
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming here.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 5,
        "failure_message": "updated_failure_message",
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [{'loc': ['body', 'llm_prompts', 1, 'hyperparameters', '__root__'],
                                  'msg': 'top_results should not be greater than 30', 'type': 'value_error'}]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_prompt_action_with_invalid_num_bot_responses():
    action = {
        "name": "test_update_prompt_action_with_invalid_num_bot_responses",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Science",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "num_bot_responses": 50,
        "failure_message": "updated_failure_message",
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == [
        {'loc': ['body', 'num_bot_responses'], 'msg': 'num_bot_responses should not be greater than 5',
         'type': 'value_error'}]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_prompt_action_with_invalid_query_prompt():
    action = {
        "name": "test_update_prompt_action_with_invalid_query_prompt",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "history",
                "is_enabled": True,
            },
        ],
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "num_bot_responses": 5,
        "use_query_prompt": True,
        "query_prompt": "",
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Query prompt must have static source!",
            "type": "value_error",
        }
    ]
    assert not actual["success"]


def test_update_prompt_action_with_query_prompt_with_false():
    action = {
        "name": "test_update_prompt_action_with_query_prompt_with_false",
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "bot_content",
                "is_enabled": False,
            },
        ],
        "failure_message": "updated_failure_message",
        "num_bot_responses": 5,
        "set_slots": [
            {"name": "gpt_result", "value": "${data}", "evaluation_type": "expression"},
            {
                "name": "gpt_result_type",
                "value": "${data.type}",
                "evaluation_type": "script",
            },
        ],
        "dispatch_response": False,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == [
        {
            "loc": ["body", "llm_prompts"],
            "msg": "Query prompt must have static source!",
            "type": "value_error",
        }
    ]
    assert not actual["success"]


def test_update_prompt_action():
    action = {
        "name": "test_update_prompt_action", 'user_question': {'type': 'from_slot', 'value': 'prompt_question'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity_analytical Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming language,",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": "updated_failure_message",
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/prompt/{pytest.action_id}",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Action updated!"
    assert not actual["data"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_get_prompt_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/prompt",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]

    actual_data = actual["data"]
    actual_data[0].pop("_id", None)

    expected_data = [{
        'name': 'test_update_prompt_action',
        'num_bot_responses': 5,
        'failure_message': 'updated_failure_message',
        'user_question': {'type': 'from_slot', 'value': 'prompt_question'},
        'llm_type': 'openai',
        'process_media': False,
        'hyperparameters': {
            'temperature': 0.0,
            'max_tokens': 300,
            'model': 'gpt-4.1-mini',
            'top_p': 0.0,
            'n': 1,
            'stop': None,
            'presence_penalty': 0.0,
            'frequency_penalty': 0.0,
            'logit_bias': {}
        },
        'llm_prompts': [
            {
                'name': 'System Prompt',
                'data': 'You are a personal assistant.',
                'type': 'system',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Similarity_analytical Prompt',
                'data': 'Bot_collection',
                'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                'type': 'user',
                'source': 'bot_content',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'A programming language is a system of notation for writing computer programs.Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'If there is no specific query, assume that user is aking about java programming language,',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            }
        ],
        'instructions': ['Answer in a short manner.', 'Keep it simple.'],
        'set_slots': [],
        'dispatch_response': True,
        'status': True
    }]

    assert not DeepDiff(actual_data, expected_data, ignore_order=True)



def test_add_prompt_action_with_empty_collection_for_bot_content_prompt(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_with_empty_collection_for_bot_content_prompt",
        'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    # Add prompt action
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    # Get all prompt actions
    response = client.get(
        f"/api/bot/{pytest.bot}/action/prompt",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]

    prompt_action = actual["data"][1]
    prompt_action.pop("_id", None)

    expected_action = {
        'name': 'test_add_prompt_action_with_empty_collection_for_bot_content_prompt',
        'num_bot_responses': 5,
        'failure_message': "I'm sorry, I didn't quite understand that. Could you rephrase?",
        'user_question': {'type': 'from_user_message'},
        'llm_type': 'openai',
        'process_media': False,
        'hyperparameters': {
            'temperature': 0.0,
            'max_tokens': 300,
            'model': 'gpt-4.1-mini',
            'top_p': 0.0,
            'n': 1,
            'stop': None,
            'presence_penalty': 0.0,
            'frequency_penalty': 0.0,
            'logit_bias': {}
        },
        'llm_prompts': [
            {
                'name': 'System Prompt',
                'data': 'You are a personal assistant.',
                'type': 'system',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Similarity Prompt',
                'data': 'default',
                'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                'type': 'user',
                'source': 'bot_content',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'If there is no specific query, assume that user is aking about java programming.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            }
        ],
        'instructions': ['Answer in a short manner.', 'Keep it simple.'],
        'set_slots': [],
        'dispatch_response': True,
        'status': True
    }

    assert not DeepDiff(prompt_action, expected_action, ignore_order=True)

def test_add_prompt_action_with_bot_content_prompt_with_payload(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True),
                           cognition_collections_limit=5)

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    response_one = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [
                {"column_name": "name", "data_type": "str", "enable_search": True, "create_embeddings": True}],
            "collection_name": "States"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response_one.json()
    pytest.delete_schema_id = actual["data"]["_id"]

    payload = {
        "data": {"name": "Karnataka"},
        "content_type": "json",
        "collection": "States"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.content_id_text = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    action = {'name': 'test_add_prompt_action_with_bot_content_prompt_with_payload',
              'llm_prompts': [{'name': 'System Prompt', 'data': 'You are a personal assistant.', 'type': 'system',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Similarity Prompt',
                               'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                               'type': 'user', 'source': 'bot_content', 'data': 'states', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'If there is no specific query, assume that user is aking about java programming.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True}],
              'instructions': ['Answer in a short manner.', 'Keep it simple.'],
              'num_bot_responses': 5,
              "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
              "llm_type": DEFAULT_LLM,
              "hyperparameters": Utility.get_default_llm_hyperparameters()
              }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    response = client.get(
        f"/api/bot/{pytest.bot}/action/prompt",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    action_data = actual["data"][2]
    action_data.pop("_id", None)

    expected_action = {
        'name': 'test_add_prompt_action_with_bot_content_prompt_with_payload',
        'num_bot_responses': 5,
        'failure_message': "I'm sorry, I didn't quite understand that. Could you rephrase?",
        'user_question': {'type': 'from_user_message'},
        'llm_type': 'openai',
        'process_media': False,
        'hyperparameters': {
            'temperature': 0.0,
            'max_tokens': 300,
            'model': 'gpt-4.1-mini',
            'top_p': 0.0,
            'n': 1,
            'stop': None,
            'presence_penalty': 0.0,
            'frequency_penalty': 0.0,
            'logit_bias': {}
        },
        'llm_prompts': [
            {
                'name': 'System Prompt',
                'data': 'You are a personal assistant.',
                'type': 'system',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Similarity Prompt',
                'data': 'states',
                'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                'type': 'user',
                'source': 'bot_content',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'If there is no specific query, assume that user is aking about java programming.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            }
        ],
        'instructions': ['Answer in a short manner.', 'Keep it simple.'],
        'set_slots': [],
        'dispatch_response': True,
        'status': True
    }

    assert not DeepDiff(action_data, expected_action, ignore_order=True)


def test_add_prompt_action_with_bot_content_prompt_with_content(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True),
                           cognition_collections_limit=5)

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    response_one = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": None,
            "collection_name": "Python"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response_one.json()
    pytest.delete_schema_id = actual["data"]["_id"]

    payload = {
        "data": "Python is a high-level, general-purpose programming language. "
                "Its design philosophy emphasizes code readability with the use of significant indentation. "
                "Python is dynamically typed and garbage-collected.",
        "content_type": "text",
        "collection": "Python"}
    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    pytest.content_id_text = actual["data"]["_id"]
    assert actual["message"] == "Record saved!"
    assert actual["data"]["_id"]
    assert actual["error_code"] == 0

    action = {'name': 'test_add_prompt_action_with_bot_content_prompt_with_content',
              'llm_prompts': [{'name': 'System Prompt', 'data': 'You are a personal assistant.', 'type': 'system',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Similarity Prompt',
                               'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                               'type': 'user', 'source': 'bot_content', 'data': 'python', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True},
                              {'name': 'Query Prompt',
                               'data': 'If there is no specific query, assume that user is aking about java programming.',
                               'instructions': 'Answer according to the context', 'type': 'query',
                               'source': 'static', 'is_enabled': True}],
              'instructions': ['Answer in a short manner.', 'Keep it simple.'],
              'num_bot_responses': 5,
              "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
              "llm_type": DEFAULT_LLM,
              "hyperparameters": Utility.get_default_llm_hyperparameters()
              }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    response = client.get(
        f"/api/bot/{pytest.bot}/action/prompt",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual=response.json()
    prompt_action = actual["data"][3]
    prompt_action.pop("_id", None)

    expected = {
        'name': 'test_add_prompt_action_with_bot_content_prompt_with_content',
        'num_bot_responses': 5,
        'failure_message': "I'm sorry, I didn't quite understand that. Could you rephrase?",
        'user_question': {'type': 'from_user_message'},
        'llm_type': 'openai',
        'process_media': False,
        'hyperparameters': {
            'temperature': 0.0,
            'max_tokens': 300,
            'model': 'gpt-4.1-mini',
            'top_p': 0.0,
            'n': 1,
            'stop': None,
            'presence_penalty': 0.0,
            'frequency_penalty': 0.0,
            'logit_bias': {}
        },
        'llm_prompts': [
            {
                'name': 'System Prompt',
                'data': 'You are a personal assistant.',
                'type': 'system',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Similarity Prompt',
                'data': 'python',
                'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
                'type': 'user',
                'source': 'bot_content',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            },
            {
                'name': 'Query Prompt',
                'data': 'If there is no specific query, assume that user is aking about java programming.',
                'instructions': 'Answer according to the context',
                'type': 'query',
                'source': 'static',
                'is_enabled': True
            }
        ],
        'instructions': ['Answer in a short manner.', 'Keep it simple.'],
        'set_slots': [],
        'dispatch_response': True,
        'status': True
    }

    assert not DeepDiff(prompt_action, expected, ignore_order=True, ignore_type_in_groups=[(dict, dict)])

def test_add_prompt_action_with_crud(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )
    add_payload_1 = {
        "collection_name": "test_collection",
        "is_secure": ["mobile_number"],
        "is_non_editable": ["empid"],
        "data": {
            "mobile_number": "09876541",
            "name": "testing_1",
            "empid": 12345
        },
        "status": True
    }
    add_resp_1 = client.post(
        f"/api/bot/{pytest.bot}/data/collection",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=add_payload_1
    )
    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_crud",
        'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "CRUD Prompt",
                "instructions": "Fetch data from the collection and answer accordingly.",
                "type": "user",
                "source": "crud",
                "is_enabled": True,
                "crud_config": {
                    "collections": ["test_collection"],
                    "query": {"key": "value"},
                    "result_limit": 5,
                    "query_source":"value"
                }
            }
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

def test_add_prompt_action_with_crud_query_as_string(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_crud_string_query",
        'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "CRUD Prompt",
                "instructions": "Fetch data from the collection and answer accordingly.",
                "type": "user",
                "source": "crud",
                "is_enabled": True,
                "crud_config": {
                    "collections": ["test_collection"],
                    "query": '{"key": "value"}',  # JSON string to hit the isinstance check
                    "result_limit": 5,
                    "query_source": "value"
                }
            }
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

def test_add_prompt_action_with_crud_query_invalid_json(monkeypatch):
    from fastapi import status

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )
    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_crud_invalid_json",
        "user_question": {"type": "from_user_message"},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "CRUD Prompt",
                "instructions": "Fetch data from the collection and answer accordingly.",
                "type": "user",
                "source": "crud",
                "is_enabled": True,
                "crud_config": {
                    "collections": ["test_collection"],
                    "query": "this is not json",
                    "result_limit": 5,
                    "query_source": "value"
                }
            }
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response=response.json()
    assert response["error_code"] == 422
    assert any(
        "Invalid JSON format in query: this is not json" in err["msg"]
        for err in response["message"]
    )


def test_add_prompt_action_with_crud_query_source_slot_valid(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_crud_slot_query",
        "user_question": {"type": "from_user_message"},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "CRUD Prompt",
                "instructions": "Fetch data from the collection and answer accordingly.",
                "type": "user",
                "source": "crud",
                "is_enabled": True,
                "crud_config": {
                    "collections": ["test_collection"],
                    "query": "slot_name",  # This is a valid slot name
                    "result_limit": 5,
                    "query_source": "slot"
                }
            }
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_prompt_action_with_crud_query_source_slot_invalid(monkeypatch):
    from fastapi import status

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)

    action = {
        "name": "test_add_prompt_action_crud_slot_query_invalid",
        "user_question": {"type": "from_user_message"},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "CRUD Prompt",
                "instructions": "Fetch data from the collection and answer accordingly.",
                "type": "user",
                "source": "crud",
                "is_enabled": True,
                "crud_config": {
                    "collections": ["test_collection"],
                    "query": {"slot": "value"},  # Invalid: query must be a string for slot source
                    "result_limit": 5,
                    "query_source": "slot"
                }
            }
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()

    assert response["error_code"] == 422
    assert any(
        "When query_source is 'slot', query must be a valid slot name." in err["msg"]
        for err in response["message"]
    )



def test_delete_prompt_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/non_existent_kairon_faq_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == 'Action with name "non_existent_kairon_faq_action" not found'
    )


def test_delete_prompt_action_1():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/test_add_prompt_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_list_entities_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/entities",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert len(actual['data']) == 20
    assert actual["success"]


@pytest.fixture()
def save_actions():
    from unittest import mock
    import textwrap
    from kairon.shared.callback.data_objects import CallbackConfig, encrypt_secret
    from kairon.shared.actions.data_objects import SetSlots, CustomActionParameters, HttpActionConfig, \
        HttpActionResponse, HttpActionRequestBody, SetSlotsFromResponse, SlotSetAction, EmailActionConfig, \
        GoogleSearchAction, CustomActionRequestParameters, ZendeskAction, JiraAction, PipedriveLeadsAction, \
        PromptAction, UserQuestion, WebSearchAction, RazorpayAction, PyscriptActionConfig, DbQuery, \
        CallbackActionConfig, CustomActionDynamicParameters, ScheduleAction, DatabaseAction, LiveAgentActionConfig, \
        KaironTwoStageFallbackAction, FormValidationAction

    HttpActionConfig(
        action_name="http_action_1",
        response=HttpActionResponse(value="The value of ${data.a.b.3} in ${data.a.b.d.0} is ${data.a.b.d}"),
        http_url="http://localhost:8081/mock",
        request_method="GET",
        headers=[HttpActionRequestBody(key="bot", parameter_type="slot", value="bot", encrypt=True),
                 HttpActionRequestBody(key="user", parameter_type="value", value="1011", encrypt=True),
                 HttpActionRequestBody(key="tag", parameter_type="value", value="from_bot", encrypt=True),
                 HttpActionRequestBody(key="email", parameter_type="key_vault", value="EMAIL", encrypt=False)],
        params_list=[HttpActionRequestBody(key="bot", parameter_type="slot", value="bot", encrypt=True),
                     HttpActionRequestBody(key="user", parameter_type="value", value="1011", encrypt=False),
                     HttpActionRequestBody(key="tag", parameter_type="value", value="from_bot", encrypt=True),
                     HttpActionRequestBody(key="name", parameter_type="key_vault", value="FIRSTNAME",
                                           encrypt=False),
                     HttpActionRequestBody(key="contact", parameter_type="key_vault", value="CONTACT",
                                           encrypt=False)],
        set_slots=[SetSlotsFromResponse(name="name", value="${data.a.b.d}"),
                   SetSlotsFromResponse(name="age", value="${data.a.b.d.0}")],
        bot=pytest.bot,
        user="user"
    ).save()

    HttpActionConfig(
        action_name="http_action_2",
        response=HttpActionResponse(value="The value of ${data.a.b.3} in ${data.a.b.d.0} is ${data.a.b.d}"),
        http_url="http://localhost:8081/mock",
        request_method="GET",
        headers=[HttpActionRequestBody(key="bot", parameter_type="slot", value="bot", encrypt=True),
                 HttpActionRequestBody(key="user", parameter_type="value", value="1011", encrypt=True),
                 HttpActionRequestBody(key="name", parameter_type="slot", value="name", encrypt=True),
                 HttpActionRequestBody(key="email", parameter_type="key_vault", value="EMAIL", encrypt=False)],
        params_list=[HttpActionRequestBody(key="bot", parameter_type="slot", value="bot", encrypt=True),
                     HttpActionRequestBody(key="user", parameter_type="value", value="1011", encrypt=False),
                     HttpActionRequestBody(key="tag", parameter_type="value", value="from_bot", encrypt=True),
                     HttpActionRequestBody(key="name", parameter_type="key_vault", value="FIRSTNAME",
                                           encrypt=False),
                     HttpActionRequestBody(key="contact", parameter_type="key_vault", value="CONTACT",
                                           encrypt=False)],
        set_slots=[SetSlotsFromResponse(name="name", value="${data.a.b.d}"),
                   SetSlotsFromResponse(name="location", value="${data.a.b.d.0}")],
        bot=pytest.bot,
        user="user"
    ).save()

    SlotSetAction(
        name="slot_set_action_1",
        set_slots=[SetSlots(name="location", type="reset_slot", value="location"),
                   SetSlots(name="name", type="from_value", value="end_user"),
                   SetSlots(name="age", type="reset_slot")],
        bot=pytest.bot,
        user="user"
    ).save()
    SlotSetAction(
        name="slot_set_action_2",
        set_slots=[SetSlots(name="name", type="reset_slot", value="")],
        bot=pytest.bot,
        user="user"
    ).save()

    with patch('kairon.shared.utils.SMTP', autospec=True):
        EmailActionConfig(
            action_name="email_action_1",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_password=CustomActionRequestParameters(key='smtp_password', value="test"),
            from_email=CustomActionRequestParameters(value="name", parameter_type="slot"),
            to_email=CustomActionParameters(value=["test@test.com"], parameter_type="value"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()
        EmailActionConfig(
            action_name="email_action_2",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_password=CustomActionRequestParameters(key='smtp_password', value="slot"),
            from_email=CustomActionRequestParameters(value="test@test.com", parameter_type="value"),
            to_email=CustomActionParameters(value=["test@test.com"], parameter_type="value"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()
        EmailActionConfig(
            action_name="email_action_3",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_password=CustomActionRequestParameters(key='smtp_password', value="test"),
            from_email=CustomActionRequestParameters(value="from_email", parameter_type="slot"),
            to_email=CustomActionParameters(value="name", parameter_type="slot"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()
        EmailActionConfig(
            action_name="email_action_4",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_password=CustomActionRequestParameters(key='name', parameter_type="slot", value="name"),
            from_email=CustomActionRequestParameters(value="test@test.com", parameter_type="value"),
            to_email=CustomActionParameters(value=["test@test.com"], parameter_type="value"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()
        EmailActionConfig(
            action_name="email_action_5",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_userid=CustomActionRequestParameters(key='name', parameter_type="slot", value="name"),
            smtp_password=CustomActionRequestParameters(key='smtp_password', value="test"),
            from_email=CustomActionRequestParameters(value="test@test.com", parameter_type="value"),
            to_email=CustomActionParameters(value=["test@test.com"], parameter_type="value"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()
        EmailActionConfig(
            action_name="email_action_6",
            smtp_url="test.test.com",
            smtp_port=293,
            smtp_userid=CustomActionRequestParameters(key='name', parameter_type="slot", value="name"),
            smtp_password=CustomActionRequestParameters(key='smtp_password', value="test"),
            from_email=CustomActionRequestParameters(value="test@test.com", parameter_type="value"),
            to_email=CustomActionParameters(value=["test@test.com"], parameter_type="value"),
            custom_text=CustomActionRequestParameters(key='bot', parameter_type="slot", value="bot"),
            subject="test",
            response="Email Triggered",
            bot=pytest.bot,
            user="user"
        ).save()

    GoogleSearchAction(
        name="google_action_1",
        api_key=CustomActionRequestParameters(value='1234567890'),
        search_engine_id='asdfg::123456',
        bot=pytest.bot,
        user="user",
        dispatch_response=False,
        num_results=3,
        set_slot="name"
    ).save()
    GoogleSearchAction(
        name="google_action_2",
        api_key=CustomActionRequestParameters(key='name', parameter_type="slot", value='name'),
        search_engine_id='asdfg::123456',
        bot=pytest.bot,
        user="user",
        dispatch_response=False,
        num_results=3,
        set_slot="location"
    ).save()

    with mock.patch('zenpy.Zenpy'):
        ZendeskAction(
            name="zendesk_action_1",
            subdomain='digite751',
            user_name='udit.pandey@digite.com',
            api_token=CustomActionRequestParameters(value='1234567890'),
            subject='new ticket',
            response='ticket created',
            bot=pytest.bot,
            user="user"
        ).save()
        ZendeskAction(
            name="zendesk_action_2",
            subdomain='digite751',
            user_name='udit.pandey@digite.com',
            api_token=CustomActionRequestParameters(key="name", parameter_type="slot", value='name'),
            subject='new ticket',
            response='ticket created',
            bot=pytest.bot,
            user="user"
        ).save()

    def _mock_response(*args, **kwargs):
        return None

    with mock.patch('kairon.shared.actions.data_objects.JiraAction.validate', new=_mock_response):
        JiraAction(
            name="jira_action_1",
            url='https://test-digite.atlassian.net',
            user_name='test@digite.com',
            api_token=CustomActionRequestParameters(key="name", parameter_type="slot", value='name'),
            project_key='HEL',
            issue_type='Bug',
            summary='fallback',
            response='Successfully created',
            bot=pytest.bot,
            user="user"
        ).save()
        JiraAction(
            name="jira_action_2",
            url='https://test-digite.atlassian.net',
            user_name='test@digite.com',
            api_token=CustomActionRequestParameters(key="location", parameter_type="slot", value='location'),
            project_key='HEL',
            issue_type='Bug',
            summary='fallback',
            response='Successfully created',
            bot=pytest.bot,
            user="user"
        ).save()

    with mock.patch('pipedrive.client.Client'):
        metadata = {'name': 'location', 'org_name': 'organization', 'email': 'email', 'phone': 'phone'}
        PipedriveLeadsAction(
            name="pipedrive_action_1",
            domain='https://digite751.pipedrive.com/',
            api_token=CustomActionRequestParameters(key="name", parameter_type="slot", value='name'),
            title='new lead generated',
            response='lead created',
            metadata=metadata,
            bot=pytest.bot,
            user="user"
        ).save()
        metadata = {'name': 'name', 'org_name': 'organization', 'email': 'email', 'phone': 'phone'}
        PipedriveLeadsAction(
            name="pipedrive_action_2",
            domain='https://digite751.pipedrive.com/',
            api_token=CustomActionRequestParameters(key="location", parameter_type="slot", value='location'),
            title='new lead generated',
            response='lead created',
            metadata=metadata,
            bot=pytest.bot,
            user="user"
        ).save()
    llm_prompts = [
        {'name': 'System Prompt',
         'data': 'You are a personal assistant. Answer question based on the context below.',
         'type': 'system', 'source': 'static', 'is_enabled': True},
        {'name': 'History Prompt', 'type': 'user', 'source': 'history', 'is_enabled': True},
        {'name': 'Query Prompt', 'data': "What kind of language is python?", 'instructions': 'Rephrase the query.',
         'type': 'query', 'source': 'static', 'is_enabled': False},
        {'name': 'Similarity Prompt',
         'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
         'type': 'user', 'source': 'bot_content', 'data': 'python',
         'hyperparameters': {"top_results": 10, "similarity_threshold": 0.70},
         'is_enabled': True}
    ]
    PromptAction(
        name="prompt_action_1",
        llm_type="openai",
        hyperparameters=Utility.get_llm_hyperparameters("openai"),
        num_bot_responses=2,
        llm_prompts=llm_prompts,
        user_question=UserQuestion(type="from_slot", value="name"),
        set_slots=[SetSlotsFromResponse(name="location", value="${data.a.b.d.0}")],
        bot=pytest.bot,
        user="user"
    ).save()
    PromptAction(
        name="prompt_action_2",
        llm_type="openai",
        hyperparameters=Utility.get_llm_hyperparameters("openai"),
        num_bot_responses=2,
        llm_prompts=llm_prompts,
        user_question=UserQuestion(type="from_slot", value="location"),
        set_slots=[SetSlotsFromResponse(name="name", value="${data.a.b.d}")],
        bot=pytest.bot,
        user="user"
    ).save()

    llm_prompts = [
        {'name': 'System Prompt',
         'data': 'You are a personal assistant. Answer question based on the context below.',
         'type': 'system', 'source': 'static', 'is_enabled': True},
        {'name': 'History Prompt', 'type': 'user', 'source': 'history', 'is_enabled': True},
        {'name': 'Query Prompt', 'data': "What kind of language is python?", 'instructions': 'Rephrase the query.',
         'type': 'query', 'source': 'static', 'is_enabled': False},
        {'name': 'Similarity Prompt',
         'instructions': 'Answer question based on the context above, if answer is not in the context go check previous logs.',
         'type': 'user', 'source': 'bot_content', 'data': 'python',
         'hyperparameters': {"top_results": 10, "similarity_threshold": 0.70},
         'is_enabled': True},
        {'name': 'Name Prompt',
         'data': 'name',
         'instructions': 'Answer according to the context', 'type': 'user', 'source': 'slot',
         'is_enabled': True},
        {'name': 'Location Prompt',
         'data': 'location',
         'instructions': 'Answer according to the context', 'type': 'user', 'source': 'slot',
         'is_enabled': True}
    ]
    PromptAction(
        name="prompt_action_3",
        llm_type="anthropic",
        hyperparameters=Utility.get_llm_hyperparameters("anthropic"),
        num_bot_responses=2,
        llm_prompts=llm_prompts,
        user_question=UserQuestion(type="from_user_message", value="hello"),
        bot=pytest.bot,
        user="user"
    ).save()
    WebSearchAction(
        name="web_search_action_1",
        website="https://www.w3schools.com/",
        topn=1,
        set_slot='location',
        bot=pytest.bot,
        user="user"
    ).save()
    WebSearchAction(
        name="web_search_action_2",
        website="https://www.w3schools.com/",
        topn=1,
        set_slot='name',
        bot=pytest.bot,
        user="user"
    ).save()
    RazorpayAction(
        name="razorpay_action_1",
        api_key=CustomActionRequestParameters(value="API_KEY", parameter_type="ActionParameterType.key_vault"),
        api_secret=CustomActionRequestParameters(value="API_SECRET", parameter_type="ActionParameterType.key_vault"),
        amount=CustomActionRequestParameters(value="amount", parameter_type="slot"),
        currency=CustomActionRequestParameters(value="INR", parameter_type="value"),
        username=CustomActionRequestParameters(parameter_type="sender_id"),
        email=CustomActionRequestParameters(parameter_type="sender_id"),
        contact=CustomActionRequestParameters(value="name", parameter_type="slot"),
        notes=[
            CustomActionRequestParameters(key="order_id", parameter_type="slot",
                                          value="order_id", encrypt=True),
            CustomActionRequestParameters(key="location", parameter_type="slot",
                                          value="location", encrypt=False),
        ],
        bot=pytest.bot,
        user="user"
    ).save()
    RazorpayAction(
        name="razorpay_action_2",
        api_key=CustomActionRequestParameters(value="API_KEY", parameter_type="key_vault"),
        api_secret=CustomActionRequestParameters(value="API_SECRET", parameter_type="key_vault"),
        amount=CustomActionRequestParameters(value="location", parameter_type="slot"),
        currency=CustomActionRequestParameters(value="INR", parameter_type="value"),
        username=CustomActionRequestParameters(parameter_type="sender_id"),
        email=CustomActionRequestParameters(parameter_type="sender_id"),
        contact=CustomActionRequestParameters(value="contact", parameter_type="slot"),
        notes=[
            CustomActionRequestParameters(key="name", parameter_type="slot",
                                          value="name", encrypt=True),
            CustomActionRequestParameters(key="phone_number", parameter_type="value",
                                          value="9876543210", encrypt=False),
        ],
        bot=pytest.bot,
        user="user"
    ).save()

    script = """
    name = slot["name"]
    bot_response = slots
    type = text
    """
    script = textwrap.dedent(script)
    PyscriptActionConfig(
        name="pyscript_action_1",
        source_code=script,
        dispatch_response=True,
        bot=pytest.bot,
        user="user"
    ).save()
    script = """
    slots = {"location": "Bangalore"}
    bot_response = slots
    type = text
    """
    script = textwrap.dedent(script)
    PyscriptActionConfig(
        name="pyscript_action_2",
        source_code=script,
        dispatch_response=True,
        bot=pytest.bot,
        user="user"
    ).save()
    DatabaseAction(
        name="database_action_1",
        collection='vector_db_collection',
        payload=[DbQuery(query_type=DbActionOperationType.payload_search.value,
                         type=DbQueryValueType.from_slot.value,
                         value="name")],
        response=HttpActionResponse(value="The value of ${data.0.city} with color ${data.0.color} is ${data.0.id}"),
        set_slots=[SetSlotsFromResponse(name="city_value", value="${data.0.id}")],
        bot=pytest.bot,
        user="user"
    ).save()
    DatabaseAction(
        name="database_action_2",
        collection='vector_db_collection',
        payload=[DbQuery(query_type=DbActionOperationType.payload_search.value,
                         type=DbQueryValueType.from_slot.value,
                         value="search")],
        response=HttpActionResponse(value="The value of ${data.0.city} with color ${data.0.color} is ${data.0.id}"),
        set_slots=[SetSlotsFromResponse(name="location", value="${data.0.id}")],
        bot=pytest.bot,
        user="user"
    ).save()

    CallbackConfig(
        name="callback_script2",
        pyscript_code="bot_response='hello world'",
        validation_secret=encrypt_secret(
            "gAAAAABmqK71xDb4apnxOAfJjDUv1lrCTooWNX0GPyBHhqW1KBlblUqGNPwsX1V7FlIlgpwWGRWljiYp9mYAf1eG4AcG1dTXQuZCndCewox"),
        execution_mode="sync",
        bot="6697add6b8e47524eb983373",
    ).save()

    CallbackActionConfig(
        name="callback_action1",
        callback_name="callback_script2",
        dynamic_url_slot_name="location",
        metadata_list=[],
        bot_response="Hello",
        dispatch_bot_response=True,
        bot=pytest.bot,
        user="user"
    ).save()
    CallbackActionConfig(
        name="callback_action2",
        callback_name="callback_script2",
        dynamic_url_slot_name="name",
        metadata_list=[],
        bot_response="Hello",
        dispatch_bot_response=True,
        bot=pytest.bot,
        user="user"
    ).save()
    ScheduleAction(
        name="schedule_action_1",
        bot=pytest.bot,
        user="user",
        schedule_time=CustomActionDynamicParameters(parameter_type=ActionParameterType.slot.value,
                                                    value="name"),
        schedule_action="callback_script2",
        timezone="Asia/Kolkata",
        response_text="Action schedule",
        params_list=[CustomActionRequestParameters(key="bot", parameter_type="slot", value="bot", encrypt=True),
                     CustomActionRequestParameters(key="user", parameter_type="value", value="1011", encrypt=False)]
    ).save()
    ScheduleAction(
        name="schedule_action_2",
        bot=pytest.bot,
        user="user",
        schedule_time=CustomActionDynamicParameters(parameter_type=ActionParameterType.slot.value,
                                                    value="location"),
        schedule_action="callback_script2",
        timezone="Asia/Kolkata",
        response_text="Action schedule",
        params_list=[CustomActionRequestParameters(key="name", parameter_type="slot", value="name", encrypt=True),
                     CustomActionRequestParameters(key="user", parameter_type="value", value="1011", encrypt=False)]
    ).save()
    LiveAgentActionConfig(
        name="live_agent_action",
        bot_response="Connecting to live agent",
        dispatch_bot_response=True,
        bot=pytest.bot,
        user="user",
    ).save()
    KaironTwoStageFallbackAction(
        name="two_stage_fallback_action",
        text_recommendations={
            "count": 3,
            "use_intent_ranking": True
        },
        bot=pytest.bot,
        user="user",
    ).save()
    semantic_expression = "if ((location in ['Mumbai', 'Bangalore'] && location.startsWith('M') " \
                          "&& location.endsWith('i')) || location.length() > 20) " \
                          "{return true;} else {return false;}"
    FormValidationAction(
        name="form_validation_action",
        slot="location",
        validation_semantic=semantic_expression,
        bot=pytest.bot,
        user="user"
    ).save()


def test_get_slot_actions(save_actions):
    response = client.get(
        f"/api/bot/{pytest.bot}/slots/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["data"] == {
        'http_action': ['http_action_1', 'http_action_2'],
        'email_action': ['email_action_6'],
        'zendesk_action': [],
        'jira_action': [],
        'slot_set_action': [],
        'google_search_action': [],
        'pipedrive_leads_action': [],
        'prompt_action': [],
        'web_search_action': [],
        'razorpay_action': [],
        'pyscript_action': [],
        'database_action': [],
        'callback_action': [],
        'schedule_action': ['schedule_action_1']
    }

    response = client.get(
        f"/api/bot/{pytest.bot}/slots/location",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["data"] == {
        'http_action': ['http_action_2'],
        'email_action': [],
        'zendesk_action': [],
        'jira_action': ['jira_action_2'],
        'slot_set_action': ['slot_set_action_1'],
        'google_search_action': ['google_action_2'],
        'pipedrive_leads_action': ['pipedrive_action_1', 'pipedrive_action_2'],
        'prompt_action': ['prompt_action_1', 'prompt_action_2', 'prompt_action_3'],
        'web_search_action': ['web_search_action_1'],
        'razorpay_action': ['razorpay_action_1', 'razorpay_action_2'],
        'pyscript_action': ['pyscript_action_2'],
        'database_action': ['database_action_2'],
        'callback_action': ['callback_action1'],
        'schedule_action': ['schedule_action_2']
    }

    response = client.get(
        f"/api/bot/{pytest.bot}/slots/name",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["message"]
    assert actual["data"] == {
        'http_action': ['http_action_1', 'http_action_2'],
        'email_action': ['email_action_1', 'email_action_3', 'email_action_4', 'email_action_5', 'email_action_6'],
        'zendesk_action': ['zendesk_action_2'],
        'jira_action': ['jira_action_1'],
        'slot_set_action': ['slot_set_action_1', 'slot_set_action_2'],
        'google_search_action': ['google_action_1', 'google_action_2'],
        'pipedrive_leads_action': ['pipedrive_action_1', 'pipedrive_action_2'],
        'prompt_action': ['prompt_action_1', 'prompt_action_2', 'prompt_action_3'],
        'web_search_action': ['web_search_action_2'],
        'razorpay_action': ['razorpay_action_1', 'razorpay_action_2'],
        'pyscript_action': ['pyscript_action_1'],
        'database_action': ['database_action_1'],
        'callback_action': ['callback_action2'],
        'schedule_action': ['schedule_action_1', 'schedule_action_2']
    }


def test_update_bot_name():
    response = client.put(
        f"/api/account/bot/{pytest.bot}",
        json={"data": "Hi-Hello-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["message"] == "Name updated"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]) == 2
    pytest.bot = response["data"]["account_owned"][0]["_id"]
    assert response["data"]["account_owned"][0]["name"] == "Hi-Hello-bot"
    assert response["data"]["account_owned"][1]["name"] == "covid-bot"


@pytest.fixture()
def resource_test_upload_zip():
    data_path = "tests/testing_data/yml_training_files"
    tmp_dir = tempfile.gettempdir()
    zip_file = os.path.join(tmp_dir, "test")
    shutil.make_archive(zip_file, "zip", data_path)
    pytest.zip = open(zip_file + ".zip", "rb").read()
    yield "resource_test_upload_zip"
    if os.path.exists(zip_file + ".zip"):
        os.remove(zip_file + ".zip")
    if os.path.exists(os.path.join("training_data", pytest.bot)):
        shutil.rmtree(os.path.join("training_data", pytest.bot))


@responses.activate
def test_upload_zip(resource_test_upload_zip):
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        ("training_files", ("data.zip", pytest.zip)),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/all/domain.yml", "rb")),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )


@responses.activate
def test_upload():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/all/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/all/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/all/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/all/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )


@responses.activate
def test_upload_yml():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/valid_yml/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/valid_yml/domain.yml", "rb")),
        ),
        (
            "training_files",
            (
                "stories.yml",
                open("tests/testing_data/valid_yml/data/stories.yml", "rb"),
            ),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/valid_yml/config.yml", "rb")),
        ),
        (
            "training_files",
            ("actions.yml", open("tests/testing_data/valid_yml/actions.yml", "rb")),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )


def test_list_entities():
    response = client.get(
        f"/api/bot/{pytest.bot}/entities",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    expected = {'bot', 'file', 'category', 'file_text', 'ticketid', 'file_error',
                'priority', 'requested_slot', 'fdresponse', 'kairon_action_response',
                'audio', 'image', 'doc_url', 'document', 'video', 'order', 'payment', 'latitude',
                'longitude', 'flow_reply', 'http_status_code', 'name', 'quick_reply', 'mail_id',
                'subject', 'body', 'media_ids','flow_docs','llm_call_id'}
    assert not DeepDiff({item['name'] for item in actual['data']}, expected, ignore_order=True)
    assert actual["success"]


def test_model_testing_no_existing_models():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "No model trained yet. Please train a model to test"
    assert not actual["success"]


@responses.activate
@patch.object(ModelProcessor, "is_daily_training_limit_exceeded")
def test_train(mock_training_limit):
    mock_training_limit.return_value = False
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_training}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model training started."
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.model_training
    )

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_upload_limit_exceeded(mock_request_event_server, monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 2
    bot_settings.save()
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files={
            "training_files": (
                "nlu.yml",
                open("tests/testing_data/yml_training_files/data/nlu.yml", "rb"),
            )
        },
    )
    actual = response.json()
    assert actual["message"] == "Daily limit exceeded."
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert not actual["success"]


@responses.activate
def test_upload_using_event_failure(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 15
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST", event_url, json={"success": False, "message": "Failed to trigger url"}
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=(
            (
                "training_files",
                (
                    "nlu.yml",
                    open("tests/testing_data/yml_training_files/data/nlu.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "domain.yml",
                    open("tests/testing_data/yml_training_files/domain.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "stories.yml",
                    open(
                        "tests/testing_data/yml_training_files/data/stories.yml", "rb"
                    ),
                ),
            ),
            (
                "training_files",
                (
                    "config.yml",
                    open("tests/testing_data/yml_training_files/config.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "actions.yml",
                    open("tests/testing_data/yml_training_files/actions.yml", "rb"),
                ),
            ),
        ),
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert (
            actual["message"]
            == "Failed to trigger data_importer event: Failed to trigger url"
    )


@responses.activate
def test_upload_using_event_append(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 15
    bot_settings.save()

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        responses.POST,
        event_url,
        json={"success": True},
        status=200,
        match=[
            responses.matchers.json_params_matcher(
                {
                    "data": {
                        "bot": pytest.bot,
                        "user": pytest.username,
                        "import_data": "--import-data",
                        "overwrite": "",
                        "event_type": EventClass.data_importer,
                    },
                    "cron_exp": None,
                    "timezone": None,
                    "run_at": None
                }
            )
        ],
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=(
            (
                "training_files",
                (
                    "nlu.yml",
                    open("tests/testing_data/yml_training_files/data/nlu.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "domain.yml",
                    open("tests/testing_data/yml_training_files/domain.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "stories.yml",
                    open(
                        "tests/testing_data/yml_training_files/data/stories.yml", "rb"
                    ),
                ),
            ),
            (
                "training_files",
                (
                    "config.yml",
                    open("tests/testing_data/yml_training_files/config.yml", "rb"),
                ),
            ),
            (
                "training_files",
                (
                    "actions.yml",
                    open("tests/testing_data/yml_training_files/actions.yml", "rb"),
                ),
            ),
        ),
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Upload in progress! Check logs."
    complete_end_to_end_event_execution(
        pytest.bot, "test_user", EventClass.data_importer
    )


def test_get_qna(monkeypatch):
    data = [
        {
            "_id": "638dde37cfe8a7de324067fa",
            "story": "accelerator_28",
            "intent": "accelerator_28",
            "utterance": "utter_accelerator_28",
            "training_examples": [
                {
                    "text": "What is the purpose of an acceleration?",
                    "_id": "638dde36cfe8a7de32405eaa",
                },
                {
                    "text": "What is the purpose of an accelerators?",
                    "_id": "638dde36cfe8a7de32405eab",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405ada",
                    "text": {
                        "text": "\tAnything that helps project teams reduce effort, save cost"
                    },
                }
            ],
        },
        {
            "_id": "638dde37cfe8a7de324067fd",
            "story": "accelerator_subscription_mainspring_31",
            "intent": "accelerator_subscription_mainspring_31",
            "utterance": "utter_accelerator_subscription_mainspring_31",
            "training_examples": [
                {
                    "text": "\tHow do I subscribe to accelerators for my project?",
                    "_id": "638dde36cfe8a7de32405ec0",
                },
                {
                    "text": "\tHow to do accelerator subscription in mainspring",
                    "_id": "638dde36cfe8a7de32405ec1",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405b64",
                    "custom": {
                        "custom": {
                            "data": [
                                {
                                    "type": "paragraph",
                                    "children": [
                                        {
                                            "text": "Step 1 : Navigate to PM Plan >> Delivery Assets"
                                        }
                                    ],
                                },
                                {
                                    "type": "paragraph",
                                    "children": [
                                        {
                                            "text": "Step 2 : Subscribe the accelerators which are applicable"
                                        }
                                    ],
                                },
                            ]
                        }
                    },
                }
            ],
        },
        {
            "_id": "638dde37cfe8a7de324067fe",
            "story": "accelerators_auto_recommended_32",
            "intent": "accelerators_auto_recommended_32",
            "utterance": "utter_accelerators_auto_recommended_32",
            "training_examples": [
                {
                    "text": "\tOn what basis are accelerators recommended for a project?",
                    "_id": "638dde36cfe8a7de32405ec3",
                },
                {
                    "text": "\tWhat is the criteria based on which accelerators are auto recommended ?",
                    "_id": "638dde36cfe8a7de32405ec4",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405b2d",
                    "text": {
                        "text": "\tAccelerators are auto-recommended from Knowhub based on these project attributes"
                    },
                }
            ],
        },
    ]

    def __mock_qna(*args, **kwargs):
        for item in data:
            yield item

    monkeypatch.setattr(BaseQuerySet, "aggregate", __mock_qna)

    response = client.get(
        f"/api/bot/{pytest.bot}/qna/flatten",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"] == {"qna": data, "total": 0}


def test_model_testing_exhosted_daily_limit():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.test_limit_per_day = 0
    bot_settings.save()
    response = client.post(
        url=f"/api/bot/{pytest.bot}/test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Daily limit exceeded."
    assert not actual["success"]


def test_get_data_importer_logs():
    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 10
    assert actual["data"]["total"] == 10
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert set(actual["data"]["logs"][0]["files_received"]) == {
        "stories",
        "nlu",
        "domain",
        "config",
        "actions",
    }
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    assert actual['data']["logs"][1]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert actual['data']["logs"][1]['status'] == STATUSES.SUCCESS.value
    assert set(actual['data']["logs"][1]['files_received']) == {'stories', 'nlu', 'domain', 'config', 'actions'}
    assert actual['data']["logs"][1]['is_data_uploaded']
    assert actual['data']["logs"][1]['start_timestamp']
    assert actual['data']["logs"][1]['end_timestamp']
    del actual['data']["logs"][1]['start_timestamp']
    del actual['data']["logs"][1]['end_timestamp']
    del actual['data']["logs"][1]['files_received']
    assert actual['data']["logs"][1] == {'intents': {'count': 14, 'data': []}, 'utterances': {'count': 14, 'data': []},
                                         'stories': {'count': 16, 'data': []},
                                         'training_examples': {'count': 192, 'data': []},
                                         'domain': {'intents_count': 15, 'actions_count': 23, 'slots_count': 10,
                                                    'utterances_count': 14, 'forms_count': 2, 'entities_count': 8,
                                                    'data': []},
                                         'config': {'count': 0, 'data': []}, 'rules': {'count': 1, 'data': []},
                                         'actions': [{'type': 'http_actions', 'count': 14, 'data': []},
                                                     {'type': 'two_stage_fallbacks', 'count': 0, 'data': []},
                                                     {'type': 'email_actions', 'count': 0, 'data': []},
                                                     {'type': 'zendesk_actions', 'count': 0, 'data': []},
                                                     {'type': 'jira_actions', 'count': 0, 'data': []},
                                                     {'type': 'form_validation_actions', 'count': 0, 'data': []},
                                                     {'type': 'slot_set_actions', 'count': 0, 'data': []},
                                                     {'type': 'google_search_actions', 'count': 0, 'data': []},
                                                     {'type': 'pipedrive_leads_actions', 'count': 0, 'data': []},
                                                     {'type': 'prompt_actions', 'count': 0, 'data': []},
                                                     {'type': 'web_search_actions', 'count': 0, 'data': []},
                                                     {'type': 'razorpay_actions', 'count': 0, 'data': []},
                                                     {'type': 'pyscript_actions', 'count': 0, 'data': []},
                                                     {'type': 'database_actions', 'count': 0, 'data': []},
                                                     {'type': 'live_agent_actions', 'count': 0, 'data': []},
                                                     {'type': 'callback_actions', 'count': 0, 'data': []},
                                                     {'type': 'schedule_actions', 'count': 0, 'data': []},
                                                     {'type': 'parallel_actions', 'count': 0, 'data': []}],
                                         'multiflow_stories': {'count': 0, 'data': []},
                                         'bot_content': {'count': 0, 'data': []},
                                         'user_actions': {'count': 9, 'data': []},
                                         'exception': '',
                                         'is_data_uploaded': True,
                                         'status': STATUSES.SUCCESS.value, 'event_status': EVENT_STATUS.COMPLETED.value}
    assert actual['data']["logs"][2]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert actual['data']["logs"][2]['status'] == STATUSES.FAIL.value
    assert set(actual['data']["logs"][2]['files_received']) == {'stories', 'nlu', 'domain', 'config',
                                                                'chat_client_config', 'bot_content'}
    assert actual['data']["logs"][2]['is_data_uploaded']
    assert actual['data']["logs"][2]['start_timestamp']
    assert actual['data']["logs"][2]['end_timestamp']

    assert actual['data']["logs"][3]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert actual['data']["logs"][3]['status'] == STATUSES.FAIL.value
    assert set(actual['data']["logs"][3]['files_received']) == {'rules', 'stories', 'nlu', 'domain', 'config',
                                                                'actions', 'chat_client_config', 'multiflow_stories',
                                                                'bot_content'}
    assert actual['data']["logs"][3]['is_data_uploaded']
    assert actual['data']["logs"][3]['start_timestamp']
    assert actual['data']["logs"][3]['end_timestamp']
    assert actual['data']["logs"][3]['intents']['count'] == 19
    assert len(actual['data']["logs"][3]['intents']['data']) == 21
    assert actual['data']["logs"][3]['utterances']['count'] == 27
    assert len(actual['data']["logs"][3]['utterances']['data']) == 11
    assert actual['data']["logs"][3]['stories']['count'] == 16
    assert len(actual['data']["logs"][3]['stories']['data']) == 1
    assert actual['data']["logs"][3]['rules']['count'] == 3
    assert len(actual['data']["logs"][3]['rules']['data']) == 0
    assert actual['data']["logs"][3]['training_examples']['count'] == 305
    assert len(actual['data']["logs"][3]['training_examples']['data']) == 0
    assert actual['data']["logs"][3]['domain'] == {'intents_count': 28, 'actions_count': 41, 'slots_count': 11,
                                                   'utterances_count': 27, 'forms_count': 2, 'entities_count': 9,
                                                   'data': []}
    assert actual['data']["logs"][3]['config'] == {'count': 0, 'data': []}
    assert actual['data']["logs"][3]['actions'] == [{'type': 'http_actions', 'count': 17, 'data': []},
                                                    {'type': 'two_stage_fallbacks', 'count': 0, 'data': []},
                                                    {'type': 'email_actions', 'count': 0, 'data': []},
                                                    {'type': 'zendesk_actions', 'count': 0, 'data': []},
                                                    {'type': 'jira_actions', 'count': 0, 'data': []},
                                                    {'type': 'form_validation_actions', 'count': 1, 'data': []},
                                                    {'type': 'slot_set_actions', 'count': 0, 'data': []},
                                                    {'type': 'google_search_actions', 'count': 1, 'data': []},
                                                    {'type': 'pipedrive_leads_actions', 'count': 0, 'data': []},
                                                    {'type': 'prompt_actions', 'count': 0, 'data': []},
                                                    {'type': 'web_search_actions', 'count': 0, 'data': []},
                                                    {'type': 'razorpay_actions', 'count': 0, 'data': []},
                                                    {'type': 'pyscript_actions', 'count': 0, 'data': []},
                                                    {'type': 'database_actions', 'count': 0, 'data': []},
                                                    {'type': 'live_agent_actions', 'count': 0, 'data': []},
                                                    {'type': 'callback_actions', 'count': 0, 'data': []},
                                                    {'type': 'schedule_actions', 'count': 0, 'data': []},
                                                    {'type': 'parallel_actions', 'count': 0, 'data': []}]
    assert actual['data']["logs"][3]['is_data_uploaded']
    assert set(actual['data']["logs"][3]['files_received']) == {'rules', 'stories', 'nlu', 'config', 'domain',
                                                                'actions', 'chat_client_config', 'multiflow_stories',
                                                                'bot_content'}


@responses.activate
def test_upload_with_chat_client_config_only():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert set(actual["data"]["logs"][0]["files_received"]) == {"chat_client_config"}
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["end_timestamp"]

    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual['data'].pop('headers')
    actual['data'].pop('nudge_server_url')
    assert actual["data"] == Utility.read_yaml("tests/testing_data/all/chat_client_config.yml")["config"]


@responses.activate
def test_upload_with_chat_client_config():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 15
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/all/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/all/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/all/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/all/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )


@responses.activate
def test_upload_without_chat_client_config():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/all/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/all/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/all/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/all/config.yml", "rb")),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )


def test_download_data_with_chat_client_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/download/data",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    file_bytes = BytesIO(response.content)
    zip_file = ZipFile(file_bytes, mode="r")
    assert zip_file.filelist.__len__() == 10
    assert zip_file.getinfo("chat_client_config.yml")
    assert zip_file.getinfo("config.yml")
    assert zip_file.getinfo("domain.yml")
    assert zip_file.getinfo("actions.yml")
    assert zip_file.getinfo("bot_content.yml")
    assert zip_file.getinfo("multiflow_stories.yml")
    assert zip_file.getinfo("data/stories.yml")
    assert zip_file.getinfo("data/rules.yml")
    assert zip_file.getinfo("data/nlu.yml")


def test_get_slots():
    response = client.get(
        f"/api/bot/{pytest.bot}/slots",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 27
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    default_slots_count = sum(slot.get('is_default') for slot in actual["data"])
    assert default_slots_count == 20


def test_add_slots():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "bot_add",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert "data" in actual
    assert actual["message"] == "Slot added successfully!"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_slots_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "bot_add",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot already exists!"
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_empty_slots():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Slot Name cannot be empty or blank spaces"


def test_add_invalid_slots_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "bot_invalid",
            "type": "invalid",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert (
            actual["message"][0]["msg"]
            == "value is not a valid enumeration member; permitted: 'float', 'categorical', 'list', 'text', 'bool', 'any'"
    )
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_edit_slots():
    response = client.put(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "bot",
            "type": "text",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Slot updated!"


def test_edit_empty_slots():
    response = client.put(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Slot Name cannot be empty or blank spaces"


def test_delete_slots():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "color",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/color",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot deleted!"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_edit_invalid_slots_type():
    response = client.put(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "bot",
            "type": "invalid",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"][0]["msg"]
            == "value is not a valid enumeration member; permitted: 'float', 'categorical', 'list', 'text', 'bool', 'any'"
    )


def test_get_intents():
    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 15
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_get_all_intents():
    response = client.get(
        f"/api/bot/{pytest.bot}/intents/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 15
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_intents():
    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "happier"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"


def test_add_intents_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "happier"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Intent already exists!"


def test_add_empty_intents():
    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": ""},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Intent Name cannot be empty or blank spaces"


def test_get_training_examples():
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 8
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_training_example_exists():
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/exists/hey",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == {"is_exists": True, "intent": "greet"}
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_training_example_does_not_exist():
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/exists/xyz",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == {"is_exists": False, "intent": None}
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_get_training_examples_empty_intent():
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/ ",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 0
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_get_training_examples_as_dict(monkeypatch):
    training_examples = {"hi": "greet", "hello": "greet", "ok": "affirm", "no": "deny"}

    def _mongo_aggregation(*args, **kwargs):
        return [{"training_examples": training_examples}]

    monkeypatch.setattr(BaseQuerySet, "aggregate", _mongo_aggregation)

    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == training_examples
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_training_examples():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        json={"data": ["How do you do?"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 9


def test_add_training_examples_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        json={"data": ["How do you do?"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert (
            actual["data"][0]["message"] == "Training Example exists in intent: ['greet']"
    )
    assert actual["data"][0]["_id"] is None


def test_add_empty_training_examples():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        json={"data": [""]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert (
            actual["data"][0]["message"]
            == "Training Example cannot be empty or blank spaces"
    )
    assert actual["data"][0]["_id"] is None


def test_remove_training_examples():
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    assert len(training_examples["data"]) == 9
    id = training_examples["data"][0]["_id"]
    response = client.delete(
        f"/api/bot/{pytest.bot}/training_examples/{id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Training Example removed!"
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    assert len(training_examples["data"]) == 8


def test_remove_training_examples_empty_id():
    response = client.delete(
        f"/api/bot/{pytest.bot}/training_examples/ ",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Unable to remove document"


def test_edit_training_examples():
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    response = client.put(
        f"/api/bot/{pytest.bot}/training_examples/greet/"
        + training_examples["data"][0]["_id"],
        json={"data": "hey, there"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Training Example updated!"


def test_get_responses():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 1
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_get_all_responses():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 14
    assert actual["data"][0]["name"]
    assert actual["data"][0]["texts"][0]["text"]
    assert not actual["data"][0]["customs"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_response_already_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/utterance",
        json={"data": "utter_greet"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance exists"


def test_add_utterance_name():
    response = client.post(
        f"/api/bot/{pytest.bot}/utterance",
        json={"data": "utter_test_add_name"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance added!"


def test_add_utterance_name_empty():
    response = client.post(
        f"/api/bot/{pytest.bot}/utterance",
        json={"data": " "},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_get_utterances():
    response = client.get(
        f"/api/bot/{pytest.bot}/utterance",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["utterances"]) == 15
    assert type(actual["data"]["utterances"]) == list


def test_add_response():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        json={"data": "Wow! How are you?"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"
    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 2


def test_add_custom_response():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/json/utter_custom",
        json={"data": {"question": "Wow! How are you?"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"
    response = client.get(
        f"/api/bot/{pytest.bot}/utterance",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 1


def test_get_custom_responses():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 1
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_response_upper_case():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/Utter_Greet",
        json={"data": "Upper Greet Response"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"


def test_get_response_upper_case():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/Utter_Greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 3

    response_lower = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual_lower = response_lower.json()
    assert len(actual_lower["data"]) == 3
    assert actual_lower["data"] == actual["data"]


def test_add_response_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        json={"data": "Wow! How are you?"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance already exists!"


def test_add_custom_response_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/json/utter_custom",
        json={"data": {"question": "Wow! How are you?"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance already exists!"


def test_add_empty_response():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        json={"data": ""},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance text cannot be empty or blank spaces"


def test_add_custom_empty_response():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/json/utter_custom",
        json={"data": ""},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance must be dict type and must not be empty"


def test_remove_response():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    utterances = response.json()
    assert len(utterances["data"]) == 3
    id = utterances["data"][0]["_id"]
    response = client.delete(
        f"/api/bot/{pytest.bot}/response/{id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response removed!"
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    assert len(training_examples["data"]) == 2


def test_remove_utterance_attached_to_story():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_remove_utterance_attached_to_story",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"
    response = client.delete(
        f"/api/bot/{pytest.bot}/responses/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == 'Cannot remove action "utter_greet" linked to flow "greet again"'
    )


def test_remove_utterance():
    client.post(
        f"/api/bot/{pytest.bot}/response/utter_remove_utterance",
        json={"data": "this will be removed"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.delete(
        f"/api/bot/{pytest.bot}/responses/utter_remove_utterance",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance removed!"


def test_remove_utterance_non_existing():
    response = client.delete(
        f"/api/bot/{pytest.bot}/responses/utter_delete_non_existing",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance does not exists"


def test_remove_utterance_empty():
    response = client.delete(
        f"/api/bot/{pytest.bot}/responses/ ",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Utterance cannot be empty or spaces"


def test_remove_response_empty_id():
    response = client.delete(
        f"/api/bot/{pytest.bot}/response/ ",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Response Id cannot be empty or spaces"


def test_edit_response():
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    response = client.put(
        f"/api/bot/{pytest.bot}/response/utter_greet/"
        + training_examples["data"][0]["_id"],
        json={"data": "Hello, How are you!"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance updated!"


def test_edit_custom_response():
    training_examples = client.get(
        f"/api/bot/{pytest.bot}/response/utter_custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    response = client.put(
        f"/api/bot/{pytest.bot}/response/json/utter_custom/"
        + training_examples["data"][0]["_id"],
        json={"data": {"question": "How are you?"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance updated!"

    training_examples = client.get(
        f"/api/bot/{pytest.bot}/response/utter_custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    training_examples = training_examples.json()
    assert training_examples["data"][0]["_id"]
    assert training_examples["data"][0]["value"] == {
        "custom": {"question": "How are you?"}
    }
    assert training_examples["data"][0]["type"] == "json"


def test_remove_custom_utterance():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/json/utter_custom",
        json={"data": {"question": "are you ok?"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    id = actual["data"]["_id"]
    response = client.delete(
        f"/api/bot/{pytest.bot}/response/{id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response removed!"

    response = client.delete(
        f"/api/bot/{pytest.bot}/responses/utter_custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance removed!"


def test_add_story():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "test_greet", "type": "INTENT"},
                {"name": "utter_test_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    pytest.story_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_story_with_name_already_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "greet",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "test_greet", "type": "INTENT"},
                {"name": "utter_test_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Story with the name already exists"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_add_story_invalid_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "TEST",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "type"],
            "msg": "value is not a valid enumeration member; permitted: 'STORY', 'RULE', 'MULTIFLOW'",
            "type": "type_error.enum",
            "ctx": {"enum_values": ["STORY", "RULE", "MULTIFLOW"]},
        }
    ]


def test_add_story_empty_event():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={"name": "test_add_story_empty_event", "type": "STORY", "steps": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Steps are required to form Flow",
            "type": "value_error",
        }
    ]

def test_add_story_lone_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_lone_intent",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
                {"name": "greet_again", "type": "INTENT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Intent should be followed by utterance or action",
            "type": "value_error",
        }
    ]


def test_add_story_consecutive_intents():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_consecutive_intents",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Found 2 consecutive intents",
            "type": "value_error",
        }
    ]


def test_add_story_multiple_actions():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_consecutive_actions",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "HTTP_ACTION"},
                {"name": "utter_greet_again", "type": "HTTP_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"


def test_add_story_utterance_as_first_step():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_consecutive_intents",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "BOT"},
                {"name": "utter_greet", "type": "HTTP_ACTION"},
                {"name": "utter_greet_again", "type": "HTTP_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "First step should be an intent",
            "type": "value_error",
        }
    ]


def test_add_story_missing_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [{"name": "greet"}, {"name": "utter_greet", "type": "BOT"}],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps", 0, "type"],
            "msg": "field required",
            "type": "value_error.missing",
        }
    ]


def test_add_story_invalid_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "data"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
            "loc": ["body", "steps", 0, "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', 'FORM_END', 'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', 'GOOGLE_SEARCH_ACTION', 'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', 'PIPEDRIVE_LEADS_ACTION', 'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', 'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', 'PROMPT_ACTION', 'DATABASE_ACTION', 'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', 'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
        }
    ]


def test_add_multiflow_story():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "more_queries",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "QQAA",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "QQAA",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNXX",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_queries",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "MnveRRhd",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_queries",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_more_queries",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "MnveRRhd",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    pytest.multiflow_story_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_multiflow_story_with_slot_values():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_path_with_slot",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "more_queries",
                            "type": "SLOT",
                            "value": "Yes",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "QQAA",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "QQAA",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNXX",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_queries",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "MnveRRhd",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_queries",
                        "type": "SLOT",
                        "value": "Yes",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_more_queries",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "MnveRRhd",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_multiflow_story_with_path():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_multiflow_with_path_type",
            "steps": [
                {
                    "step": {
                        "name": "hobby",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_hobby",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_hobby",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "frontend",
                            "type": "SLOT",
                            "value": "Yes",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "backend",
                            "type": "HTTP_ACTION",
                            "node_id": "4",
                            "component_id": "QQAA",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "backend",
                        "type": "HTTP_ACTION",
                        "node_id": "4",
                        "component_id": "QQAA",
                    },
                    "connections": [
                        {
                            "name": "utter_backend",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNXX",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_backend",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_frontend",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "MnveRRhd",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "frontend",
                        "type": "SLOT",
                        "value": "Yes",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_frontend",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "MnveRRhd",
                        }
                    ],
                },
            ],
            "metadata": [
                {"node_id": "5", "flow_type": "RULE"},
                {"node_id": "6", "flow_type": "STORY"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_multiflow_story_with_name_already_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "more_queries",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "MNbcg",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_queries",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_queries",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_more_queries",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "MNbcg",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Multiflow Story with the name already exists"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_add_multiflow_story_no_steps():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={"name": "test_path", "steps": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Steps are required to form Flow",
            "type": "value_error",
        }
    ]
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_multiflow_story_lone_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_add_multiflow_story_lone_intent",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "queries",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "MNbcg",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "queries",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    assert actual["message"] == "Leaf nodes cannot be intent"


def test_add_multiflow_story_missing_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {"name": "hi", "node_id": "1", "component_id": "MNbcg"},
                    "connections": [
                        {
                            "name": "utter_hi",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "queries",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "5",
                            "component_id": "MNbcg",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "5",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "queries",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]

    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps", 0, "step", "type"],
            "msg": "field required",
            "type": "value_error.missing",
        }
    ]


def test_add_multiflow_story_invalid_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "hi",
                        "type": "data",
                        "node_id": "1",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_hi",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcg",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    assert actual["message"] == [
        {
            "loc": ["body", "steps", 0, "step", "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', 'FORM_END', "
                   "'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', 'GOOGLE_SEARCH_ACTION', "
                   "'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', 'PIPEDRIVE_LEADS_ACTION', "
                   "'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', 'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', "
                   "'PROMPT_ACTION', 'DATABASE_ACTION', 'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', "
                   "'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
        }
    ]


def test_update_story():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_path",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow updated successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_update_story_with_name_already_exists():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_add_story_consecutive_actions",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Story with the name already exists"
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_story_invalid_event_type():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_path",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "data"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
            "loc": ["body", "steps", 0, "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', 'FORM_END', 'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', 'GOOGLE_SEARCH_ACTION', 'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', 'PIPEDRIVE_LEADS_ACTION', 'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', 'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', 'PROMPT_ACTION', 'DATABASE_ACTION', 'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', 'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
        }
    ]


def test_update_multiflow_story_with_tag():
    response = client.put(
        f"/api/bot/{pytest.bot}/v2/stories/{pytest.multiflow_story_id}",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "greeting",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_greeting",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcZZg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greeting",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "MNbcZZg",
                    },
                    "connections": [
                        {
                            "name": "more_query",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "uhsjJ",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "MgGFD",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "MgGFD",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_query",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "IIUUUYY",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_query",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "uhsjJ",
                    },
                    "connections": [
                        {
                            "name": "utter_more_query",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "IIUUUYY",
                        }
                    ],
                },
            ],
            "flow_tags": ["agentic_flow", "chatbot_flow"]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Story flow updated successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_update_multiflow_story():
    response = client.put(
        f"/api/bot/{pytest.bot}/v2/stories/{pytest.multiflow_story_id}",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "greeting",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_greeting",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "MNbcZZg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greeting",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "MNbcZZg",
                    },
                    "connections": [
                        {
                            "name": "more_query",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "uhsjJ",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "MgGFD",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "MgGFD",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "MNbcg",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "MNbcg",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_query",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "IIUUUYY",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_query",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "uhsjJ",
                    },
                    "connections": [
                        {
                            "name": "utter_more_query",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "IIUUUYY",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["message"] == "Story flow updated successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_update_multiflow_story_with_name_already_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "another_test_path",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "63g0SIHe0vlF7BpABhUBlcOW",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "637k8PnBABFMoKiUJqQTCBRP",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "637k8PnBABFMoKiUJqQTCBRP",
                    },
                    "connections": [
                        {
                            "name": "more_queries",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "63NUrDSW34K8XzuabEwO7SJH",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "63zr5t71RcH6WZCP5kNGpZYv",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "63zr5t71RcH6WZCP5kNGpZYv",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "630r3YIqp2UhggEsIvC8Q8pC",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "630r3YIqp2UhggEsIvC8Q8pC",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_queries",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "63vwObDTOE2KLCP1FejFbSm8",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_queries",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "63NUrDSW34K8XzuabEwO7SJH",
                    },
                    "connections": [
                        {
                            "name": "utter_more_queries",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "63vwObDTOE2KLCP1FejFbSm8",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.put(
        f"/api/bot/{pytest.bot}/v2/stories/{pytest.multiflow_story_id}",
        json={
            "name": "another_test_path",
            "steps": [
                {
                    "step": {
                        "name": "greeting",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "NNNNHHG",
                    },
                    "connections": [
                        {
                            "name": "utter_greeting",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "NNNNHHG",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greeting",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "NNNNHHG",
                    },
                    "connections": [
                        {
                            "name": "more_query",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "NNNNHHG",
                        },
                        {
                            "name": "goodbye",
                            "type": "INTENT",
                            "node_id": "4",
                            "component_id": "NNNNHHG",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "goodbye",
                        "type": "INTENT",
                        "node_id": "4",
                        "component_id": "NNNNHHG",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNNNHHG",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNNNHHG",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_query",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "NNNNHHG",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_query",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "NNNNHHG",
                    },
                    "connections": [
                        {
                            "name": "utter_more_query",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "NNNNHHG",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "Multiflow Story with the name already exists"
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_update_multiflow_story_invalid_event_type():
    response = client.put(
        f"/api/bot/{pytest.bot}/v2/stories/{pytest.multiflow_story_id}",
        json={
            "name": "test_path",
            "steps": [
                {
                    "step": {
                        "name": "hiie",
                        "type": "data",
                        "node_id": "1",
                        "component_id": "63Xx6ZbMOcBcq5Ltb1XoC3R5",
                    },
                    "connections": [
                        {
                            "name": "utter_hiie",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "63nzrQFKnrc97QOI2renluu9",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    assert actual["message"] == [
        {
            "loc": ["body", "steps", 0, "step", "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', "
                   "'FORM_END', 'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', "
                   "'GOOGLE_SEARCH_ACTION', 'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', "
                   "'PIPEDRIVE_LEADS_ACTION', 'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', "
                   "'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', 'PROMPT_ACTION', 'DATABASE_ACTION', "
                   "'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', 'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
        }
    ]


def test_get_multiflow_stories():
    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    #
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])
    get_story = [
        x
        for x in actual["data"]
        if x["type"] == "MULTIFLOW" and x["name"] == "test_path"
    ]
    assert len(get_story) == 1
    get_story = get_story[0]
    assert get_story["type"] == "MULTIFLOW"
    assert get_story["name"] == "test_path"
    assert get_story["steps"] == [
        {
            "step": {
                "name": "greeting",
                "type": "INTENT",
                "node_id": "1",
                "component_id": "MNbcg",
            },
            "connections": [
                {
                    "name": "utter_greeting",
                    "type": "BOT",
                    "node_id": "2",
                    "component_id": "MNbcZZg",
                }
            ],
        },
        {
            "step": {
                "name": "utter_greeting",
                "type": "BOT",
                "node_id": "2",
                "component_id": "MNbcZZg",
            },
            "connections": [
                {
                    "name": "more_query",
                    "type": "INTENT",
                    "node_id": "3",
                    "component_id": "uhsjJ",
                },
                {
                    "name": "goodbye",
                    "type": "INTENT",
                    "node_id": "4",
                    "component_id": "MgGFD",
                },
            ],
        },
        {
            "step": {
                "name": "goodbye",
                "type": "INTENT",
                "node_id": "4",
                "component_id": "MgGFD",
            },
            "connections": [
                {
                    "name": "utter_goodbye",
                    "type": "BOT",
                    "node_id": "5",
                    "component_id": "MNbcg",
                }
            ],
        },
        {
            "step": {
                "name": "utter_goodbye",
                "type": "BOT",
                "node_id": "5",
                "component_id": "MNbcg",
            },
            "connections": [],
        },
        {
            "step": {
                "name": "utter_more_query",
                "type": "BOT",
                "node_id": "6",
                "component_id": "IIUUUYY",
            },
            "connections": [],
        },
        {
            "step": {
                "name": "more_query",
                "type": "INTENT",
                "node_id": "3",
                "component_id": "uhsjJ",
            },
            "connections": [
                {
                    "name": "utter_more_query",
                    "type": "BOT",
                    "node_id": "6",
                    "component_id": "IIUUUYY",
                }
            ],
        },
    ]


def test_delete_multiflow_story():
    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.multiflow_story_id}/MULTIFLOW",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow deleted successfully"


def test_delete_multiflow_non_existing_story():
    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.multiflow_story_id}/MULTIFLOW",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Flow does not exists"


def test_delete_story():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path1",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet_delete", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.story_id = actual["data"]["_id"]

    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}/STORY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow deleted successfully"


def test_delete_non_existing_story():
    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}/STORY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Flow does not exists"


def test_get_stories():
    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])
    assert actual["data"][0]["template_type"] == "CUSTOM"
    assert actual["data"][1]["template_type"] == "CUSTOM"
    assert actual["data"][16]["template_type"] == "Q&A"
    assert actual["data"][17]["template_type"] == "Q&A"
    assert actual["data"][19].get("template_type")


def test_get_utterance_from_intent():
    response = client.get(
        f"/api/bot/{pytest.bot}/utterance_from_intent/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["name"] == "utter_offer_help"
    assert actual["data"]["type"] == UTTERANCE_TYPE.BOT
    assert Utility.check_empty_string(actual["message"])


def test_get_utterance_from_not_exist_intent():
    response = client.get(
        f"/api/bot/{pytest.bot}/utterance_from_intent/greeting",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["name"] is None
    assert actual["data"]["type"] is None
    assert Utility.check_empty_string(actual["message"])


def test_add_story_stop_flow_action():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_stop_flow_action",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_goodbye", "type": "BOT"},
                {"name": "utter_goodbye", "type": "BOT"},
                {"name": "stop", "type": "STOP_FLOW_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    story = next((item for item in actual['data'] if item['name'] == 'test_add_story_stop_flow_action'), None)
    assert story is not None
    assert story['steps'][-1]['name'] == 'stop_flow_action'
    assert story['steps'][-1]['type'] == 'STOP_FLOW_ACTION'


def test_add_story_stop_flow_action_not_at_end():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_stop_flow_action_not_at_end",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_goodbye", "type": "BOT"},
                {"name": "stop", "type": "STOP_FLOW_ACTION"},
                {"name": "utter_goodbye", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Stop Flow Action should only be at the end of the flow",
            "type": "value_error",
        }
    ]


def test_add_story_stop_flow_action_after_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_stop_flow_action_after_intent",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "stop", "type": "STOP_FLOW_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Stop Flow Action should not be after intent",
            "type": "value_error",
        }
    ]

@responses.activate
def test_upload_stop_flow_action():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/stop_flow_action/upload_story/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/stop_flow_action/upload_story/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/stop_flow_action/upload_story/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/stop_flow_action/upload_story/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/stop_flow_action/upload_story/chat_client_config.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    story = next((story_item for story_item in actual["data"] if story_item["name"] == "story_with_stop_flow_action"), None)

    assert story is not None
    assert story["steps"][-1]["name"] == "stop_flow_action"
    assert story["steps"][-1]["type"] == "STOP_FLOW_ACTION"


def test_download_story_with_stop_flow_action():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_download_story_with_stop_flow_action",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_goodbye", "type": "BOT"},
                {"name": "stop_flow_action", "type": "STOP_FLOW_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/download/data",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    file_bytes = BytesIO(response.content)

    zip_file = ZipFile(file_bytes, mode="r")
    with zip_file.open("data/stories.yml") as file:
        stories_yaml = yaml.safe_load(file.read().decode("utf-8"))
    with zip_file.open("domain.yml") as file:
        domain_yaml = yaml.safe_load(file.read().decode("utf-8"))

    story = next((story_item for story_item in stories_yaml["stories"] if story_item["story"] == "test_download_story_with_stop_flow_action"), None)
    assert story is not None
    assert story["steps"][-1]["action"] == "action_listen"
    assert domain_yaml["actions"][-1] == "action_listen"


@responses.activate
def test_add_multiflow_story_stop_flow_action():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_add_multiflow_story_stop_flow_action",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "stop_flow",
                            "type": "STOP_FLOW_ACTION",
                            "node_id": "3",
                            "component_id": "NNXX",
                        },
                        {
                            "name": "utter_bye",
                            "type": "BOT",
                            "node_id": "4",
                            "component_id": "NNXXY",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "stop_flow",
                        "type": "STOP_FLOW_ACTION",
                        "node_id": "3",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_bye",
                        "type": "BOT",
                        "node_id": "4",
                        "component_id": "NNXXY",
                    },
                    "connections": [
                        {
                            "name": "utter_bye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNXXY",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_bye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNXXY",
                    },
                    "connections": None,
                }
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    story = next((item for item in actual['data'] if item['name'] == 'test_add_multiflow_story_stop_flow_action'), None)
    assert story is not None

    stop_flow_step = next((step for step in story['steps'] if
                           step['step']['name'] == 'stop_flow' and step['step']['type'] == 'STOP_FLOW_ACTION'), None)

    assert stop_flow_step is not None
    assert stop_flow_step['connections'] == []


def test_add_multiflow_story_stop_flow_action_not_at_end():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_stop_path",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "more_queries",
                            "type": "INTENT",
                            "node_id": "3",
                            "component_id": "MNbcg",
                        },
                        {
                            "name": "stop_flow",
                            "type": "STOP_FLOW_ACTION",
                            "node_id": "4",
                            "component_id": "QQAA",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "stop_flow",
                        "type": "STOP_FLOW_ACTION",
                        "node_id": "4",
                        "component_id": "QQAA",
                    },
                    "connections": [
                        {
                            "name": "utter_goodbye",
                            "type": "BOT",
                            "node_id": "5",
                            "component_id": "NNXX",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_goodbye",
                        "type": "BOT",
                        "node_id": "5",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_more_queries",
                        "type": "BOT",
                        "node_id": "6",
                        "component_id": "MnveRRhd",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "more_queries",
                        "type": "INTENT",
                        "node_id": "3",
                        "component_id": "MNbcg",
                    },
                    "connections": [
                        {
                            "name": "utter_more_queries",
                            "type": "BOT",
                            "node_id": "6",
                            "component_id": "MnveRRhd",
                        }
                    ],
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual['success']
    assert actual['message'] == 'STOP_FLOW_ACTION should be a leaf node!'
    assert actual["error_code"] == 422


def test_add_multiflow_story_stop_flow_action_after_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_stop_path",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "stop_flow",
                            "type": "STOP_FLOW_ACTION",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "stop_flow",
                        "type": "STOP_FLOW_ACTION",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": None,
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual['success']
    assert actual['message'] == 'STOP_FLOW_ACTION cannot be a successor of an intent!'
    assert actual["error_code"] == 422

@responses.activate
@patch.object(ModelProcessor, "is_daily_training_limit_exceeded")
def test_upload_stop_flow_action_multiflow(mock_training_limit):
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/stop_flow_action/upload_multiflow_story/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("rules.yml", open("tests/testing_data/stop_flow_action/upload_multiflow_story/data/rules.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/stop_flow_action/upload_multiflow_story/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/stop_flow_action/upload_multiflow_story/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/stop_flow_action/upload_multiflow_story/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/stop_flow_action/upload_multiflow_story/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "actions.yml",
                open("tests/testing_data/stop_flow_action/upload_multiflow_story/actions.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "multiflow_stories.yml",
                open("tests/testing_data/stop_flow_action/upload_multiflow_story/multiflow_stories.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    for story in actual["data"]:
        if story.get("type") == "MULTIFLOW":
            for substep in story["steps"]:
                if substep.get("step", {}).get("name") == "stop_flow_action":
                    assert substep["connections"] == []


    mock_training_limit.return_value = False
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_training}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model training started."
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.model_training
    )


def test_download_multiflow_story_with_stop_flow_action():
    response = client.post(
        f"/api/bot/{pytest.bot}/v2/stories",
        json={
            "name": "test_download_multiflow_story_with_stop_flow_action",
            "steps": [
                {
                    "step": {
                        "name": "greet",
                        "type": "INTENT",
                        "node_id": "1",
                        "component_id": "Mnvehd",
                    },
                    "connections": [
                        {
                            "name": "utter_greet",
                            "type": "BOT",
                            "node_id": "2",
                            "component_id": "PLhfhs",
                        }
                    ],
                },
                {
                    "step": {
                        "name": "utter_greet",
                        "type": "BOT",
                        "node_id": "2",
                        "component_id": "PLhfhs",
                    },
                    "connections": [
                        {
                            "name": "stop_flow_action",
                            "type": "STOP_FLOW_ACTION",
                            "node_id": "3",
                            "component_id": "NNXX",
                        },
                        {
                            "name": "utter_bye",
                            "type": "BOT",
                            "node_id": "4",
                            "component_id": "NNXXY",
                        },
                    ],
                },
                {
                    "step": {
                        "name": "stop_flow_action",
                        "type": "STOP_FLOW_ACTION",
                        "node_id": "3",
                        "component_id": "NNXX",
                    },
                    "connections": None,
                },
                {
                    "step": {
                        "name": "utter_bye",
                        "type": "BOT",
                        "node_id": "4",
                        "component_id": "NNXXY",
                    },
                    "connections": None,
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Story flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/download/data",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    file_bytes = BytesIO(response.content)
    zip_file = ZipFile(file_bytes, mode="r")

    with zip_file.open("multiflow_stories.yml") as file:
        multi_stories_content = yaml.safe_load(file.read().decode("utf-8"))
    with zip_file.open("domain.yml") as file:
        domain_content = yaml.safe_load(file.read().decode("utf-8"))

    events = next(block['events'] for block in multi_stories_content['multiflow_story'] if block['block_name'] == 'test_download_multiflow_story_with_stop_flow_action')

    for event in events:
        if event["step"]["name"] == "stop_flow_action":
            assert event["connections"] == []

    for event in events:
        if event["step"]["name"] == "utter_greet":
            assert any(conn["name"] == "stop_flow_action" for conn in event["connections"])

    assert domain_content['actions'][-1] == 'stop_flow_action'



@patch('kairon.shared.data.processor.MongoProcessor.get_flows_by_tag')
def test_get_flows_by_tag(mock_tag_list):
    mock_tag_list.return_value = {
        'rule': ['rule1', 'rule2'],
        'multiflow': ['multiflow1', 'multiflow2']
    }

    response = client.get(f"/api/bot/{pytest.bot}/flow_tag/agentic_flow",
                          headers={"Authorization": pytest.token_type + " " + pytest.access_token})

    assert response.status_code == 200
    data_out = response.json()
    print(data_out)
    assert data_out == {
        'data': {
            'rule': ['rule1', 'rule2'],
            'multiflow': ['multiflow1', 'multiflow2']
        },
        'error_code': 0,
        'success': True,
        'message': None
    }
    mock_tag_list.assert_called_once_with(pytest.bot, 'agentic_flow')


@responses.activate
def test_train_on_updated_data(monkeypatch):
    def _mock_training_limit(*arge, **kwargs):
        return False

    monkeypatch.setattr(
        ModelProcessor, "is_daily_training_limit_exceeded", _mock_training_limit
    )

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_training}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "frontend",
            "type": "text",
            "influence_conversation": True,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert "data" in actual
    assert actual["message"] == "Slot added successfully!"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "more_queries",
            "type": "text",
            "influence_conversation": True,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model training started."
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.model_training
    )


def test_download_model_training_logs(monkeypatch):
    start_date = datetime.utcnow() - timedelta(days=1)
    end_date = datetime.utcnow() + timedelta(days=1)
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/download/model_training?start_date={start_date}&end_date={end_date}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.content


@pytest.fixture
def mock_is_training_inprogress_exception(monkeypatch):
    def _inprogress_execption_response(*args, **kwargs):
        raise AppException("Previous model training in progress.")

    monkeypatch.setattr(
        ModelProcessor, "is_training_inprogress", _inprogress_execption_response
    )


def test_train_inprogress(mock_is_training_inprogress_exception):
    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is False
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == "Previous model training in progress."


@pytest.fixture
def mock_is_training_inprogress(monkeypatch):
    def _inprogress_response(*args, **kwargs):
        return False

    monkeypatch.setattr(ModelProcessor, "is_training_inprogress", _inprogress_response)


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_train_daily_limit_exceed(mock_request_event_server, monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.training_limit_per_day = 2
    bot_settings.save()
    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == "Daily model training limit exceeded."


def test_get_model_training_history():
    response = client.get(
        f"/api/bot/{pytest.bot}/train/history",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is True
    assert actual["error_code"] == 0
    assert actual["data"]
    assert "training_history" in actual["data"]


def test_model_testing_limit_exceeded(monkeypatch):
    monkeypatch.setitem(Utility.environment["model"]["test"], "limit_per_day", 0)
    response = client.post(
        url=f"/api/bot/{pytest.bot}/test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Daily limit exceeded."
    assert not actual["success"]


@responses.activate
def test_model_testing_event(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.test_limit_per_day = 5
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_testing}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    response = client.post(
        url=f"/api/bot/{pytest.bot}/test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Testing in progress! Check logs."
    assert actual["success"]


@responses.activate
def test_model_testing_in_progress():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_testing}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        url=f"/api/bot/{pytest.bot}/test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Event already in progress! Check logs."
    assert not actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.model_testing
    )


def test_get_model_testing_logs():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/test?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/test?log_type=stories&reference_id={actual['data']['logs'][0]['reference_id']}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]

def test_get_model_testing_logs_new():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/model_test?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["success"]

def test_search_model_testing_logs():
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/model_test/search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
          )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]

def test_search_model_testing_logs_for_from_date_and_to_date():
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/model_test/search?from_date=2025-08-01&to_date=2025-08-31",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
          )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]

def test_search_model_testing_logs_for_is_augmented_False():
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/model_test/search?is_augmented=False",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
          )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]

def test_search_model_testing_logs_is_augmented_True():
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/model_test/search?is_augmented=True",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
          )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]






def test_download_model_testing_logs(monkeypatch):
    start_date = datetime.utcnow() - timedelta(days=1)
    end_date = datetime.utcnow() + timedelta(days=1)
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/download/model_testing?start_date={start_date}&end_date={end_date}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.content


def test_deploy_missing_configuration():
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Please configure the bot endpoint for deployment!"


def endpoint_response(*args, **kwargs):
    return {"bot_endpoint": {"url": "http://localhost:5000"}}


@pytest.fixture
def mock_endpoint(monkeypatch):
    monkeypatch.setattr(MongoProcessor, "get_endpoints", endpoint_response)


@pytest.fixture
def mock_endpoint_with_token(monkeypatch):
    def _endpoint_response(*args, **kwargs):
        return {
            "bot_endpoint": {
                "url": "http://localhost:5000",
                "token": "AGTSUDH!@#78JNKLD",
                "token_type": "Bearer",
            }
        }

    monkeypatch.setattr(MongoProcessor, "get_endpoints", _endpoint_response)


def test_deploy_connection_error(mock_endpoint):
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Host is not reachable"


@responses.activate
def test_deploy(mock_endpoint):
    responses.add(
        responses.PUT,
        "http://localhost:5000/model",
        status=204,
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model was successfully replaced."


@responses.activate
def test_deployment_history():
    response = client.get(
        f"/api/bot/{pytest.bot}/deploy/history",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["deployment_history"]) == 3
    assert actual["message"] is None


@responses.activate
def test_deploy_with_token(mock_endpoint_with_token):
    responses.add(
        responses.PUT,
        "http://localhost:5000/model",
        json="Model was successfully replaced.",
        headers={
            "Content-type": "application/json",
            "Accept": "text/plain",
            "Authorization": "Bearer AGTSUDH!@#78JNKLD",
        },
        status=200,
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model was successfully replaced."


@responses.activate
def test_deploy_bad_request(mock_endpoint):
    responses.add(
        responses.PUT,
        "http://localhost:5000/model",
        json={
            "version": "1.0.0",
            "status": "failure",
            "reason": "BadRequest",
            "code": 400,
        },
        status=200,
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "BadRequest"


@responses.activate
def test_deploy_server_error(mock_endpoint):
    responses.add(
        responses.PUT,
        "http://localhost:5000/model",
        json={
            "version": "1.0.0",
            "status": "ServerError",
            "message": "An unexpected error occurred.",
            "code": 500,
        },
        status=200,
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/deploy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "An unexpected error occurred."

def test_integration_token():
    response = client.post(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 1", "expiry_minutes": 1440, "role": "designer"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    token = response.json()
    assert token["success"]
    assert token["error_code"] == 0
    assert token["data"]["access_token"]
    assert token["data"]["token_type"]
    assert (
            token["message"]
            == """This token will be shown only once. Please copy this somewhere safe. 
            It is your responsibility to keep the token secret. If leaked, others may have access to your system."""
    )

    response = client.get(
        "/api/user/details",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    ).json()
    assert len(response["data"]["user"]["bots"]["account_owned"]) == 1
    assert len(response["data"]["user"]["bots"]["shared"]) == 0

    response = client.get(
        "/api/account/bot",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    ).json()
    assert len(response["data"]["account_owned"]) == 1
    assert len(response["data"]["shared"]) == 0

    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["user"]["bots"]["account_owned"]) == 2

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 4
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
        json={"data": "integration"},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"


def test_integration_token_missing_x_user():
    response = client.post(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 2"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["access_token"]
    assert actual["data"]["token_type"]
    assert (
            actual["message"]
            == """This token will be shown only once. Please copy this somewhere safe. 
            It is your responsibility to keep the token secret. If leaked, others may have access to your system."""
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": actual["data"]["token_type"]
                             + " "
                             + actual["data"]["access_token"]
        },
    )
    actual = response.json()
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Alias user missing for integration"


@responses.activate
def test_augment_paraphrase_gpt():
    responses.add(
        responses.POST,
        url="http://localhost:8000/paraphrases/gpt",
        match=[
            responses.matchers.json_params_matcher(
                {
                    "api_key": "MockKey",
                    "data": ["Where is digite located?"],
                    "engine": "davinci",
                    "temperature": 0.75,
                    "max_tokens": 100,
                    "num_responses": 10,
                }
            )
        ],
        json={
            "success": True,
            "data": {
                "paraphrases": ["Where is digite located?", "Where is digite situated?"]
            },
            "message": None,
            "error_code": 0,
        },
        status=200,
    )
    response = client.post(
        "/api/augment/paraphrases/gpt",
        json={"data": ["Where is digite located?"], "api_key": "MockKey"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == {
        "paraphrases": ["Where is digite located?", "Where is digite situated?"]
    }
    assert Utility.check_empty_string(actual["message"])


def test_augment_paraphrase_gpt_validation():
    response = client.post(
        "/api/augment/paraphrases/gpt",
        json={"data": [], "api_key": "MockKey"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == [
        {"loc": ["body", "data"], "msg": "Question Please!", "type": "value_error"}
    ]

    response = client.post(
        "/api/augment/paraphrases/gpt",
        json={
            "data": ["hi", "hello", "thanks", "hello", "bye", "how are you"],
            "api_key": "MockKey",
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == [
        {
            "loc": ["body", "data"],
            "msg": "Max 5 Questions are allowed!",
            "type": "value_error",
        }
    ]


@responses.activate
def test_augment_paraphrase_gpt_fail():
    key_error_message = "Incorrect API key provided: InvalidKey. You can find your API key at https://beta.openai.com."
    responses.add(
        responses.POST,
        url="http://localhost:8000/paraphrases/gpt",
        match=[
            responses.matchers.json_params_matcher(
                {
                    "api_key": "InvalidKey",
                    "data": ["Where is digite located?"],
                    "engine": "davinci",
                    "temperature": 0.75,
                    "max_tokens": 100,
                    "num_responses": 10,
                }
            )
        ],
        json={
            "success": False,
            "data": None,
            "message": key_error_message,
        },
        status=200,
    )
    response = client.post(
        "/api/augment/paraphrases/gpt",
        json={"data": ["Where is digite located?"], "api_key": "InvalidKey"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert not actual["success"]
    assert actual["data"] is None
    assert actual["message"] == key_error_message


@responses.activate
def test_augment_paraphrase():
    responses.add(
        responses.POST,
        "http://localhost:8000/paraphrases",
        json={
            "success": True,
            "data": {
                "questions": [
                    "Where is digite located?",
                    "Where is digite?",
                    "What is the location of digite?",
                    "Where is the digite located?",
                    "Where is it located?",
                    "What location is digite located?",
                    "Where is the digite?",
                    "where is digite located?",
                    "Where is digite situated?",
                    "digite is located where?",
                ]
            },
            "message": None,
            "error_code": 0,
        },
        status=200,
        match=[responses.matchers.json_params_matcher(["where is digite located?"])],
    )
    response = client.post(
        "/api/augment/paraphrases",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": ["where is digite located?"]},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])


def test_augment_paraphrase_no_of_questions():
    response = client.post(
        "/api/augment/paraphrases",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": []},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == [
        {"loc": ["body", "data"], "msg": "Question Please!", "type": "value_error"}
    ]

    response = client.post(
        "/api/augment/paraphrases",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": ["Hi", "Hello", "How are you", "Bye", "Thanks", "Welcome"]},
    )

    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == [
        {
            "loc": ["body", "data"],
            "msg": "Max 5 Questions are allowed!",
            "type": "value_error",
        }
    ]


def test_get_user_details():
    response = client.get(
        "/api/user/details",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])


def test_update_user_details():
    response = client.post(
        "/api/user/details/Completed",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Details updated!"


def test_download_data():
    response = client.get(
        f"/api/bot/{pytest.bot}/download/data",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    file_bytes = BytesIO(response.content)
    zip_file = ZipFile(file_bytes, mode="r")
    assert zip_file.filelist.__len__() == 10
    zip_file.close()
    file_bytes.close()


def test_download_model():
    response = client.get(
        f"/api/bot/{pytest.bot}/download/model",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    d = response.headers["content-disposition"]
    fname = re.findall("filename=(.+)", d)[0]
    file_bytes = BytesIO(response.content)
    tar = tarfile.open(fileobj=file_bytes, mode="r", name=fname)
    assert tar.members.__len__()
    tar.close()
    file_bytes.close()


def test_get_endpoint():
    response = client.get(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert actual["success"]


def test_save_endpoint_error():
    response = client.put(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body"], "msg": "field required", "type": "value_error.missing"}
    ]
    assert not actual["success"]


def test_save_empty_endpoint():
    response = client.put(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Endpoint saved successfully!"
    assert actual["success"]


def test_save_history_endpoint():
    response = client.put(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={
            "history_endpoint": {
                "url": "http://localhost:27019/",
                "token": "kairon-history-user",
            }
        },
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Endpoint saved successfully!"
    assert actual["success"]


@responses.activate
def test_save_endpoint(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost/"
    )

    responses.add(
        responses.GET,
        f"http://localhost/api/bot/{pytest.bot}/reload",
        status=200,
        json={
            "success": True,
            "error_code": 0,
            "data": None,
            "message": "Reloading Model!",
        },
    )

    response = client.put(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={
            "bot_endpoint": {"url": "http://localhost:5005/"},
            "action_endpoint": {"url": "http://localhost:5000/"},
            "history_endpoint": {"url": "http://localhost", "token": "rasa234568"},
        },
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Endpoint saved successfully!"
    assert actual["success"]
    response = client.get(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]["endpoint"].get("bot_endpoint")
    assert actual["data"]["endpoint"].get("action_endpoint")
    assert actual["data"]["endpoint"].get("history_endpoint")


def test_save_empty_history_endpoint():
    response = client.put(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"history_endpoint": {"url": " ", "token": "testing-endpoint"}},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "url cannot be blank or empty spaces"
    assert not actual["success"]


def test_get_history_endpoint():
    response = client.get(
        f"/api/bot/{pytest.bot}/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]["endpoint"]["history_endpoint"]["url"] == "http://localhost"
    assert actual["data"]["endpoint"]["history_endpoint"]["token"] == "rasa234***"
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert actual["success"]


def test_delete_endpoint():
    response = client.delete(
        f"/api/bot/{pytest.bot}/endpoint/history_endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Endpoint removed"
    assert actual["success"]


def test_get_templates():
    response = client.get(
        f"/api/system/templates/use-case",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert "Hi-Hello" in actual["data"]["use-cases"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert actual["success"]


def test_set_templates():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/use-case",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "Hi-Hello"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Data applied!"
    assert actual["success"]


def test_set_templates_invalid():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/use-case",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "Hi"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "Invalid template!"
    assert not actual["success"]


def test_set_templates_insecure():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/use-case",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "../Hi-Hello"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Data applied!"
    assert actual["success"]


@responses.activate
def test_reload_model(monkeypatch):
    processor = MongoProcessor()
    start_time = datetime.utcnow() - timedelta(days=1)
    end_time = datetime.utcnow() + timedelta(days=1)

    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost/"
    )

    responses.add(
        responses.GET,
        f"http://localhost/api/bot/{pytest.bot}/reload",
        status=200,
        json={
            "success": True,
            "error_code": 0,
            "data": None,
            "message": "Reloading Model!",
        },
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/model/reload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Reloading Model!"
    assert actual["success"]
    logs = processor.get_logs(pytest.bot, "audit_logs", start_time, end_time)
    logs[0].pop('timestamp')
    logs[0].pop('_id')
    assert logs[0] == {'attributes': [{'key': 'bot', 'value': pytest.bot}], 'user': 'integration@demo.ai',
                       'action': 'activity', 'entity': 'model_reload',
                       'data': {'message': None, 'username': 'integration@demo.ai', 'exception': None,
                                'status': 'Initiated'}}


@responses.activate
def test_reload_model_exception():
    processor = MongoProcessor()
    start_time = datetime.utcnow() - timedelta(days=1)
    end_time = datetime.utcnow() + timedelta(days=1)
    # def mongo_store(*arge, **kwargs):
    #     return None
    #
    # monkeypatch.setattr(Utility, "get_local_mongo_store", mongo_store)
    # monkeypatch.setitem(Utility.environment['action'], "url", None)
    # monkeypatch.setitem(Utility.environment['model']['agent'], "url", "http://localhost/")
    response = client.get(
        f"/api/bot/{pytest.bot}/model/reload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    assert actual['data'] is None
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual['message'] == 'Agent config not found!'
    logs = processor.get_logs(pytest.bot, "audit_logs", start_time, end_time)
    logs[0].pop('timestamp')
    logs[0].pop('_id')
    assert logs[0] == {'attributes': [{'key': 'bot', 'value': pytest.bot}],
                       'user': 'integration@demo.ai', 'action': 'activity', 'entity': 'model_reload',
                       'data': {'message': None, 'username': 'integration@demo.ai',
                                'exception': 'Agent config not found!', 'status': 'Failed'}}


def test_get_config_templates():
    response = client.get(
        f"/api/bot/{pytest.bot}/templates/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    templates = {template["name"] for template in actual["data"]["config-templates"]}
    assert templates == {
        "long-answer",
        "rasa-default",
        "contextual",
        "kairon-default",
        "gpt-faq",
        "openai-classifier",
        "openai-featurizer",
    }
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert actual["success"]


def test_set_config_templates():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "rasa-default"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Config applied!"
    assert actual["success"]


def test_set_config_templates_invalid():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "test"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "Invalid config!"
    assert not actual["success"]


def test_set_config_templates_insecure():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "../rasa-default"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Config applied!"
    assert actual["success"]


def test_get_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert all(
        key in ["language", "pipeline", "policies", "recipe"]
        for key in actual["data"]["config"].keys()
    )
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert actual["success"]


def test_set_config():
    response = client.put(
        f"/api/bot/{pytest.bot}/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=read_config_file("./tests/testing_data/kairon-default.yml"),
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved!"
    assert actual["success"]


def test_set_config_policy_error():
    data = read_config_file("./tests/testing_data/kairon-default.yml")
    data["policies"].append({"name": "TestPolicy"})
    response = client.put(
        f"/api/bot/{pytest.bot}/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=data,
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "Invalid policy TestPolicy"
    assert not actual["success"]


def test_set_config_pipeline_error():
    data = read_config_file("./tests/testing_data/kairon-default.yml")
    data["pipeline"].append({"name": "TestFeaturizer"})
    response = client.put(
        f"/api/bot/{pytest.bot}/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=data,
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert str(actual["message"]).__contains__("Invalid component TestFeaturizer")
    assert not actual["success"]


def test_set_config_pipeline_error_empty_policies():
    data = read_config_file("./tests/testing_data/kairon-default.yml")
    data["policies"] = []
    response = client.put(
        f"/api/bot/{pytest.bot}/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=data,
    )

    actual = response.json()
    assert actual["data"] is None
    assert str(actual["message"]).__contains__("You didn't define any policies")
    assert actual["error_code"] == 422
    assert not actual["success"]


def test_delete_intent():
    client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "happier"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.delete(
        f"/api/bot/{pytest.bot}/intents/happier",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent deleted!"
    assert actual["success"]


def test_api_login_with_account_not_verified():
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@10"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False

    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == "Please verify your mail"
    value = list(
        AuditLogData.objects(user="integration@demo.ai", action='activity', entity='invalid_login').order_by(
            "-timestamp")
    )[0]
    assert value["entity"] == "invalid_login"
    assert value["timestamp"]
    assert value["data"] == {'message': ['Please verify your mail'], 'username': 'integration@demo.ai'}


def test_account_registration_with_confirmation(monkeypatch):
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/registration",
        json={
            "email": "integ1@gmail.com",
            "first_name": "Dem",
            "last_name": "User22",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration33",
            "bot": "integration33",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert (
            actual["message"]
            == "Account Registered! A confirmation link has been sent to your mail"
    )
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None

    response = client.post(
        "/api/account/email/confirmation",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoiaW50ZWcxQGdtYWlsLmNvbSJ9.Ycs1ROb1w6MMsx2WTA4vFu3-jRO8LsXKCQEB3fkoU20"
        },
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False

    assert actual["message"] == "Account Verified!"
    assert actual["data"] is None
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.post(
        "/api/auth/login",
        data={"username": "integ1@gmail.com", "password": "Welcome@10"},
    )
    actual = response.json()
    pytest.add_member_token = actual["data"]["access_token"]
    pytest.add_member_token_type = actual["data"]["token_type"]

    response = client.post(
        "/api/account/bot",
        headers={"Authorization": pytest.add_member_token_type + " " + pytest.add_member_token,
                 'Content-Type': 'application/json'},
        json={"name": "Hi-Hello", "from_template": "Hi-Hello"},
    ).json()
    assert response['message'] == "Bot created"
    assert response['data']['bot_id']

    response = client.get(
        "/api/account/bot",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    pytest.add_member_bot = response["data"]["account_owned"][0]["_id"]


def test_account_registration_with_confirmation_enabled_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.post(
        "/api/account/email/confirmation",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoiaW50ZWcxQGdtYWlsLmNvbSJ9.Ycs1ROb1w6MMsx2WTA4vFu3-jRO8LsXKCQEB3fkoU20"
        },
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False

    assert actual["message"] == "This feature is disabled"
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_invalid_token_for_confirmation():
    response = client.post(
        "/api/account/email/confirmation",
        json={"data": "hello"},
    )
    actual = response.json()

    assert actual["message"] == "Invalid token"
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_add_member(monkeypatch):
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)

    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integration@demo.ai", "role": "tester"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "An invitation has been sent to the user"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integration2@demo.ai", "role": "designer"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "An invitation has been sent to the user"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integrationtest@demo.ai", "role": "designer"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "An invitation has been sent to the user"
    assert response["error_code"] == 0
    assert response["success"]


@responses.activate
def test_add_member_invalid_email():
    api_key = "test"
    email = "integration@demo.ai"
    with patch.dict(
            Utility.environment,
            {"verify": {"email": {"type": "quickemail", "key": api_key, "enable": True}}},
    ):
        responses.add(
            responses.GET,
            "http://api.quickemailverification.com/v1/verify?"
            + urlencode({"apikey": api_key, "email": email}),
            json={
                "result": "valid",
                "reason": "rejected_email",
                "disposable": "true",
                "accept_all": "false",
                "role": "false",
                "free": "false",
                "email": email,
                "user": "test",
                "domain": "quickemailverification.com",
                "mx_record": "us2.mx1.mailhostbox.com",
                "mx_domain": "mailhostbox.com",
                "safe_to_send": "false",
                "did_you_mean": "",
                "success": "true",
                "message": None,
            },
        )

        response = client.post(
            f"/api/user/{pytest.add_member_bot}/member",
            json={"email": email, "role": "tester"},
            headers={
                "Authorization": pytest.add_member_token_type
                                 + " "
                                 + pytest.add_member_token
            },
        ).json()
        assert response["message"] == [
            {
                "loc": ["body", "email"],
                "msg": "Invalid or disposable Email!",
                "type": "value_error",
            }
        ]
        assert response["error_code"] == 422
        assert not response["success"]


def test_add_member_as_owner(monkeypatch):
    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integration@demo.ai", "role": "owner"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == [
        {
            "loc": ["body", "role"],
            "msg": "There can be only 1 owner per bot",
            "type": "value_error",
        }
    ]
    assert response["error_code"] == 422
    assert not response["success"]


def test_list_bot_invites():
    response = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@10"},
    ).json()

    response = client.get(
        "/api/user/invites/active",
        headers={
            "Authorization": response["data"]["token_type"]
                             + " "
                             + response["data"]["access_token"]
        },
    ).json()
    assert (
            response["data"]["active_invites"][0]["accessor_email"] == "integration@demo.ai"
    )
    assert response["data"]["active_invites"][0]["role"] == "tester"
    assert response["data"]["active_invites"][0]["bot_name"] == "Hi-Hello"
    assert response["error_code"] == 0
    assert response["success"]


def test_login_limit_exceeded():
    response_one = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@3010"},
    ).json()
    response_two = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@3010"},
    ).json()
    response_three = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@3010"},
    ).json()
    response = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@3010"},
    ).json()

    assert not response['success']
    assert response['message'].__contains__("Account frozen due to too many unsuccessful login attempts.")
    assert response['data'] is None
    assert response['error_code'] == 422


def test_search_users(monkeypatch):
    def __mock_list_bot_invites(*args, **kwargs):
        for item in ["integration@demo.ai", "integration2@demo.com"]:
            yield item

    monkeypatch.setattr(AccountProcessor, "search_user", __mock_list_bot_invites)

    response = client.post(
        f"/api/user/search",
        json={"data": "inte"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["data"]["matching_users"] == [
        "integration@demo.ai",
        "integration2@demo.com",
    ]
    assert response["error_code"] == 0
    assert response["success"]


def test_transfer_ownership_to_user_not_a_member(monkeypatch):
    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)
    response = client.put(
        f"/api/user/{pytest.add_member_bot}/owner/change",
        json={"data": "integration@demo.ai"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User is yet to accept the invite"
    assert response["error_code"] == 422
    assert not response["success"]


def test_accept_bot_invite(monkeypatch):
    def __mock_verify_token(*args, **kwargs):
        return {"mail_id": "integration@demo.ai"}

    monkeypatch.setattr(Utility, "verify_token", __mock_verify_token)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    monkeypatch.setattr(AccountProcessor, "get_user_details", mock_smtp)
    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)
    response = client.post(
        f"/api/user/{pytest.add_member_bot}/invite/accept",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoidXNlckBrYWlyb24uY"
        },
    ).json()
    assert response["message"] == "Invitation accepted"
    assert response["error_code"] == 0
    assert response["success"]


def test_accept_bot_invite_logged_in_user_with_email_enabled(monkeypatch):
    response = client.post(
        "/api/auth/login",
        data={"username": "integrationtest@demo.ai", "password": "Welcome@10"},
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        "/api/user/invites/active",
        headers={
            "Authorization": actual["data"]["token_type"]
                             + " "
                             + actual["data"]["access_token"]
        },
    ).json()
    assert (
            response["data"]["active_invites"][0]["accessor_email"]
            == "integrationtest@demo.ai"
    )
    assert response["data"]["active_invites"][0]["role"] == "designer"
    assert response["data"]["active_invites"][0]["bot_name"] == "Hi-Hello"

    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    monkeypatch.setattr(AccountProcessor, "check_email_confirmation", mock_smtp)
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member/invite/accept",
        headers={
            "Authorization": actual["data"]["token_type"]
                             + " "
                             + actual["data"]["access_token"]
        },
    ).json()
    Utility.email_conf["email"]["enable"] = False
    assert response["message"] == "Invitation accepted"
    assert response["error_code"] == 0
    assert response["success"]


def test_accept_bot_invite_logged_in_user():
    response = client.post(
        "/api/auth/login",
        data={"username": "integration2@demo.ai", "password": "Welcome@10"},
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        "/api/user/invites/active",
        headers={
            "Authorization": actual["data"]["token_type"]
                             + " "
                             + actual["data"]["access_token"]
        },
    ).json()
    assert (
            response["data"]["active_invites"][0]["accessor_email"]
            == "integration2@demo.ai"
    )
    assert response["data"]["active_invites"][0]["role"] == "designer"
    assert response["data"]["active_invites"][0]["bot_name"] == "Hi-Hello"

    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member/invite/accept",
        headers={
            "Authorization": actual["data"]["token_type"]
                             + " "
                             + actual["data"]["access_token"]
        },
    ).json()
    assert response["message"] == "Invitation accepted"
    assert response["error_code"] == 0
    assert response["success"]


def test_list_bot_invites_none():
    response = client.get(
        f"/api/user/invites/active",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["data"]["active_invites"] == []
    assert response["error_code"] == 0
    assert response["success"]


def test_add_member_email_disabled():
    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integration_email_false@demo.ai", "role": "designer"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User added"
    assert response["error_code"] == 0
    assert response["success"]


def test_list_members():
    response = client.get(
        f"/api/user/{pytest.add_member_bot}/member",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["error_code"] == 0
    assert response["success"]
    assert response["data"][0]["accessor_email"] == "integ1@gmail.com"
    assert response["data"][0]["role"] == "owner"
    assert response["data"][1]["status"]
    assert response["data"][1]["accessor_email"] == "integration@demo.ai"
    assert response["data"][1]["role"] == "tester"
    assert response["data"][1]["status"]
    assert response["data"][2]["accessor_email"] == "integration2@demo.ai"
    assert response["data"][2]["role"] == "designer"
    assert response["data"][2]["status"]
    assert response["data"][3]["accessor_email"] == "integrationtest@demo.ai"
    assert response["data"][3]["role"] == "designer"
    assert response["data"][3]["status"]
    assert response["data"][4]["accessor_email"] == "integration_email_false@demo.ai"
    assert response["data"][4]["role"] == "designer"
    assert response["data"][4]["status"]


def test_transfer_ownership(monkeypatch):
    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    response = client.put(
        f"/api/user/{pytest.add_member_bot}/owner/change",
        json={"data": "integration@demo.ai"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "Ownership transferred"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.get(
        f"/api/user/{pytest.add_member_bot}/member",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["error_code"] == 0
    assert response["success"]
    assert response["data"][0]["accessor_email"] == "integ1@gmail.com"
    assert response["data"][0]["role"] == "admin"
    assert response["data"][1]["status"]
    assert response["data"][1]["accessor_email"] == "integration@demo.ai"
    assert response["data"][1]["role"] == "owner"
    assert response["data"][1]["status"]
    assert response["data"][2]["accessor_email"] == "integration2@demo.ai"
    assert response["data"][2]["role"] == "designer"
    assert response["data"][2]["status"]
    assert response["data"][3]["accessor_email"] == "integrationtest@demo.ai"
    assert response["data"][3]["role"] == "designer"
    assert response["data"][3]["status"]
    assert response["data"][4]["accessor_email"] == "integration_email_false@demo.ai"
    assert response["data"][4]["role"] == "designer"
    assert response["data"][4]["status"]


def test_list_members_2():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    bot = response["data"]["account_owned"][1]["_id"]
    response = client.get(
        f"/api/user/{bot}/member",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["error_code"] == 422
    assert not response["success"]
    assert not response["data"]
    assert response["message"] == "Access to bot is denied"


def test_update_member_role_not_exists(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "user@kairon.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "user@kairon.ai",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    response = client.put(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "user@kairon.ai", "role": "admin", "status": "inactive"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User not yet invited to collaborate"
    assert response["error_code"] == 422
    assert not response["success"]


def test_update_member_role(monkeypatch):
    response = client.put(
        f"/api/user/{pytest.add_member_bot}/member",
        json={
            "email": "integration_email_false@demo.ai",
            "role": "admin",
            "status": "inactive",
        },
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User does not exist!"
    assert response["error_code"] == 422
    assert not response["success"]

    response = client.post(
        "/api/account/registration",
        json={
            "email": "integration_email_false@demo.ai",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration_email_false@demo.ai",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    monkeypatch.setitem(Utility.email_conf["email"], "enable", True)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    response = client.put(
        f"/api/user/{pytest.add_member_bot}/member",
        json={
            "email": "integration_email_false@demo.ai",
            "role": "admin",
            "status": "inactive",
        },
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User access updated"
    assert response["error_code"] == 0
    assert response["success"]


def test_delete_member():
    response = client.delete(
        f"/api/user/{pytest.add_member_bot}/member/integration_email_false@demo.ai",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User removed"
    assert response["error_code"] == 0
    assert response["success"]


def test_add_deleted_member_and_updated_role():
    response = client.post(
        f"/api/user/{pytest.add_member_bot}/member",
        json={"email": "integration_email_false@demo.ai", "role": "designer"},
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User added"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.put(
        f"/api/user/{pytest.add_member_bot}/member",
        json={
            "email": "integration_email_false@demo.ai",
            "role": "admin",
            "status": "inactive",
        },
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User access updated"
    assert response["error_code"] == 0
    assert response["success"]


def test_remove_self():
    response = client.delete(
        f"/api/user/{pytest.add_member_bot}/member/integ1@gmail.com",
        headers={
            "Authorization": pytest.add_member_token_type
                             + " "
                             + pytest.add_member_token
        },
    ).json()
    assert response["message"] == "User cannot remove himself"
    assert response["error_code"] == 422
    assert not response["success"]


def test_add_intents_no_bot():
    response = client.post(
        "/api/bot/ /intents",
        json={"data": "greet"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Bot is required"


def test_add_intents_not_authorised():
    response = client.post(
        "/api/bot/5ea8127db7c285f4055129a4/intents",
        json={"data": "greet"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Access to bot is denied"


def test_add_intents_inactive_bot(monkeypatch):
    def _mock_bot(*args, **kwargs):
        return {"status": False}

    async def _mock_user(*args, **kwargs):
        return User(
            email="test",
            first_name="test",
            last_name="test",
            account=2,
            status=True,
            is_integration_user=False,
        )

    def _mock_role(*args, **kwargs):
        return {"role": "admin"}

    monkeypatch.setattr(AccountProcessor, "get_bot", _mock_bot)
    monkeypatch.setattr(Authentication, "get_current_user", _mock_user)
    monkeypatch.setattr(AccountProcessor, "fetch_role_for_user", _mock_role)

    response = client.post(
        "/api/bot/5ea8127db7c285f4055129a4/intents",
        json={"data": "greet"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Inactive Bot Please contact system admin!"


def test_add_intents_invalid_auth_token():
    token = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9.hqWGSaFpvbrXkOWc6lrnffhNWR19W_S1YKFBx2arWBk"
    response = client.post(
        "/api/bot/ /intents",
        json={"data": "greet"},
        headers={"Authorization": token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 401
    assert actual["message"] == "Could not validate credentials"


def test_add_intents_invalid_auth_token_2():
    token = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
    response = client.post(
        "/api/bot/ /intents",
        json={"data": "greet"},
        headers={"Authorization": token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 401
    assert actual["message"] == "Could not validate credentials"


def test_add_intents_to_different_bot():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    pytest.bot_2 = response["data"]["account_owned"][1]["_id"]

    response = client.post(
        f"/api/bot/{pytest.bot_2}/intents",
        json={"data": "greeting"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"


def test_add_training_examples_to_different_bot():
    response = client.post(
        f"/api/bot/{pytest.bot_2}/training_examples/greet",
        json={"data": ["Heya"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    response = client.get(
        f"/api/bot/{pytest.bot_2}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 10


def test_add_response_different_bot():
    response = client.post(
        f"/api/bot/{pytest.bot_2}/response/utter_greet",
        json={"data": "Hi! How are you?"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"
    response = client.get(
        f"/api/bot/{pytest.bot_2}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 3


def test_add_story_to_different_bot():
    response = client.post(
        f"/api/bot/{pytest.bot_2}/stories",
        json={
            "name": "greet user",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greeting", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0


@patch('kairon.api.app.routers.bot.bot.MailReadEvent.__init__', return_value=None)
@patch('kairon.api.app.routers.bot.bot.MailReadEvent.validate')
@patch('kairon.api.app.routers.bot.bot.MailReadEvent.enqueue')
def test_trigger_mail_channel_read(mock_enque, mock_validate, mock_init):
    response = client.get(
        f"/api/bot/{pytest.bot}/mail_channel/read_mailbox",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    mock_validate.assert_called_once()
    mock_enque.assert_called_once()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "mail channel read triggered"



@responses.activate
def test_train_on_different_bot(monkeypatch):
    def _mock_training_limit(*arge, **kwargs):
        return False

    monkeypatch.setattr(
        ModelProcessor, "is_daily_training_limit_exceeded", _mock_training_limit
    )

    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_training}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        f"/api/bot/{pytest.bot_2}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model training started."
    complete_end_to_end_event_execution(
        pytest.bot_2, "integration@demo.ai", EventClass.model_training
    )


def test_train_insufficient_data(monkeypatch):
    def _mock_training_limit(*arge, **kwargs):
        return False

    monkeypatch.setattr(
        ModelProcessor, "is_daily_training_limit_exceeded", _mock_training_limit
    )

    response = client.post(
        "/api/account/bot",
        json={"name": "sample-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    pytest.bot_sample = response["data"]["account_owned"][3]["_id"]

    response_story = client.get(
        f"/api/bot/{pytest.bot_sample}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response_story.json()
    rule_one = actual["data"][1]["_id"]
    rule_two = actual["data"][2]["_id"]

    response_delete_story_one = client.delete(
        f"/api/bot/{pytest.bot_sample}/stories/{rule_one}/RULE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response_delete_story_two = client.delete(
        f"/api/bot/{pytest.bot_sample}/stories/{rule_two}/RULE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.post(
        f"/api/bot/{pytest.bot_sample}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert (
            actual["message"]
            == "Please add at least 2 flows and 2 intents before training the bot!"
    )


def test_delete_bot():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    bot = response["data"]["account_owned"][1]["_id"]

    response = client.delete(
        f"/api/account/bot/{bot}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["message"] == "Bot removed"
    assert response["error_code"] == 0
    assert response["success"]


def test_login_for_verified():
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/auth/login",
        data={"username": "integ1@gmail.com", "password": "Welcome@10"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False

    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.access_token = actual["data"]["access_token"]
    pytest.token_type = actual["data"]["token_type"]


def test_list_bots_for_different_user():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["shared"]) == 1
    pytest.bot = response["data"]["shared"][0]["_id"]


def test_reset_password_for_valid_id(monkeypatch):
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/password/reset",
        json={"data": "integ1@gmail.com"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert actual["success"]
    assert actual["error_code"] == 0
    assert (
            actual["message"]
            == "Success! A password reset link has been sent to your mail id"
    )
    assert actual["data"] is None


def test_reset_password_enabled_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.post(
        "/api/account/password/reset",
        json={"data": "integ1@gmail.com"},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "This feature is disabled"
    assert actual["data"] is None


def test_reset_password_for_invalid_id():
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/password/reset",
        json={"data": "sasha.41195@gmail.com"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Error! There is no user with the following mail id"
    assert actual["data"] is None


def test_list_bots_for_different_user_2():
    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["shared"]) == 1
    pytest.bot = response["data"]["shared"][0]["_id"]
    pytest.account = response["data"]["shared"][0]["account"]


def test_send_link_for_valid_id(monkeypatch):
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/email/confirmation/link",
        json={"data": "integration@demo.ai"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Success! Confirmation link sent"
    assert actual["data"] is None


def test_send_link_enabled_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.post(
        "/api/account/email/confirmation/link",
        json={"data": "integration@demo.ai"},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "This feature is disabled"
    assert actual["data"] is None


def test_send_link_for_confirmed_id():
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/email/confirmation/link",
        json={"data": "integ1@gmail.com"},
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Email already confirmed!"
    assert actual["data"] is None


def test_overwrite_password_for_non_matching_passwords():
    Utility.email_conf["email"]["enable"] = True
    response = client.post(
        "/api/account/password/change",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoiaW50ZWcxQGdtYWlsLmNvbSJ9.Ycs1ROb1w6MMsx2WTA4vFu3-jRO8LsXKCQEB3fkoU20",
            "password": "Welcome@2",
            "confirm_password": "Welcume@2",
        },
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None


def test_overwrite_password_enabled_sso_only(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.post(
        "/api/account/password/change",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoiaW50ZWcxQGdtYWlsLmNvbSJ9.Ycs1ROb1w6MMsx2WTA4vFu3-jRO8LsXKCQEB3fkoU20",
            "password": "Welcome@20",
            "confirm_password": "Welcome@20",
        },
    )
    actual = response.json()
    assert actual["message"] == "This feature is disabled"
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None


def test_add_and_delete_intents_by_integration_user():
    response = client.post(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 1", "role": "designer"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    token = response.json()
    assert token["success"]
    assert token["error_code"] == 0
    assert token["data"]["access_token"]
    assert token["data"]["token_type"]

    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
        json={"data": "integration_intent"},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"

    response = client.delete(
        f"/api/bot/{pytest.bot}/intents/integration_intent",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration1",
        },
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent deleted!"
    assert actual["success"]


def test_add_non_integration_intent_and_delete_intent_by_integration_user():
    response = client.post(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 3", "role": "designer"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    token = response.json()
    assert token["success"]
    assert token["error_code"] == 0
    assert token["data"]["access_token"]
    assert token["data"]["token_type"]
    pytest.disable_token = (
        f'{token["data"]["token_type"]} {token["data"]["access_token"]}'
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "non_integration_intent"},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"

    response = client.delete(
        f"/api/bot/{pytest.bot}/intents/non_integration_intent",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration1",
        },
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "This intent cannot be deleted by an integration user"
    assert not actual["success"]


def test_list_keys_none():
    response = client.get(
        f"/api/bot/{pytest.bot}/secrets/keys",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == []
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert actual["success"]


def test_add_secret():
    request = {"key": "AWS_KEY", "value": "123456789asdfghjk"}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert not Utility.check_empty_string(actual["data"]["key_id"])
    assert actual["error_code"] == 0
    assert actual["message"] == "Secret added!"
    assert actual["success"]


def test_add_secret_invalid_request():
    request = {"key": None, "value": "123456789asdfghjk"}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert not actual["success"]

    request = {"key": "AWS_KEY", "value": None}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert not actual["success"]


def test_add_secret_already_exists():
    request = {"key": "AWS_KEY", "value": "123456789asdfghjk"}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "Key exists!"
    assert not actual["success"]


def test_get_secret_not_exists():
    response = client.get(
        f"/api/bot/{pytest.bot}/secrets/keys/GOOGLE_KEY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "key 'GOOGLE_KEY' does not exists!"


def test_get_secret():
    response = client.get(
        f"/api/bot/{pytest.bot}/secrets/keys/AWS_KEY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == "123456789asdfghjk"
    assert actual["error_code"] == 0
    assert actual["success"]


def test_update_secret():
    request = {"key": "AWS_KEY", "value": "123456789"}
    response = client.put(
        f"/api/bot/{pytest.bot}/secrets/update",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert not Utility.check_empty_string(actual["data"]["key_id"])
    assert actual["error_code"] == 0
    assert actual["message"] == "Secret updated!"
    assert actual["success"]


def test_add_secret_2():
    request = {"key": "GOOGLE_KEY", "value": "sdfghj45678"}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert not Utility.check_empty_string(actual["data"]["key_id"])
    assert actual["error_code"] == 0
    assert actual["message"] == "Secret added!"
    assert actual["success"]


def test_update_secret_invalid_request():
    request = {"key": "  ", "value": "123456789"}
    response = client.put(
        f"/api/bot/{pytest.bot}/secrets/update",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert Utility.check_empty_string(actual["data"])
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "key"], "msg": "key is required", "type": "value_error"}
    ]
    assert not actual["success"]

    request = {"key": "AWS_KEY", "value": "  "}
    response = client.put(
        f"/api/bot/{pytest.bot}/secrets/update",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert Utility.check_empty_string(actual["data"])
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "value"], "msg": "value is required", "type": "value_error"}
    ]
    assert not actual["success"]


def test_update_secret_not_exists():
    request = {"key": "GCP_KEY", "value": "123456789"}
    response = client.put(
        f"/api/bot/{pytest.bot}/secrets/update",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert Utility.check_empty_string(actual["data"])
    assert actual["error_code"] == 422
    assert actual["message"] == "key 'GCP_KEY' does not exists!"
    assert not actual["success"]


def test_list_keys():
    response = client.get(
        f"/api/bot/{pytest.bot}/secrets/keys",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == ["AWS_KEY", "GOOGLE_KEY"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert actual["success"]


def test_delete_secret():
    response = client.delete(
        f"/api/bot/{pytest.bot}/secrets/AWS_KEY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Secret deleted!"
    assert actual["success"]


def test_delete_secret_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/secrets/AWS_KEY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 422
    assert actual["message"] == "key 'AWS_KEY' does not exists!"
    assert not actual["success"]


def test_add_secret_with_deleted_key():
    request = {"key": "AWS_KEY", "value": "123456789asdfghjk"}
    response = client.post(
        f"/api/bot/{pytest.bot}/secrets/add",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert not Utility.check_empty_string(actual["data"]["key_id"])
    assert actual["error_code"] == 0
    assert actual["message"] == "Secret added!"
    assert actual["success"]


def test_get_secret_2():
    response = client.get(
        f"/api/bot/{pytest.bot}/secrets/keys/AWS_KEY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"] == "123456789asdfghjk"
    assert actual["error_code"] == 0
    assert actual["success"]


def test_add_vectordb_action_empty_payload():
    request_body = {
        "name": "add_vectordb_action_empty_payload",
        "collection": 'test_add_vectordb_action_empty_name',
        "payload": [],
        "response": {"value": "0"},
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "payload"], "msg": "payload is required", "type": "value_error"}
    ]
    assert not actual["success"]


def test_add_vectordb_action_empty_name():
    request_body = {
        "name": "",
        "collection": 'test_add_vectordb_action_empty_name',
        "payload": [{
            "type": "from_value",
            "value": {"ids": [0], "with_payload": True, "with_vector": True},
            "query_type": "embedding_search",
        }],
        "response": {"value": "0"},
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "name"], "msg": "name is required", "type": "value_error"}
    ]
    assert not actual["success"]


def test_add_vectordb_action_with_utter():
    request_body = {
        "name": "utter_add_vectordb_action",
        "collection": 'test_add_vectordb_action_empty_name',
        "payload": [{
            "type": "from_value",
            "value": {"ids": [0], "with_payload": True, "with_vector": True},
            "query_type": "embedding_search",
        }],
        "response": {"value": "0"},
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Action name cannot start with utter_"
    assert not actual["success"]


def test_add_vectordb_action_empty_collection_name():
    request_body = {
        "name": 'test_add_vectordb_action_empty_collection_name',
        "collection": '',
        "payload": [{"type": "from_value", "value": {"ids": [0], "with_payload": True, "with_vector": True}, "query_type": "embedding_search",}],
        "response": {"value": "0"}
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == [
        {'loc': ['body', 'collection'], 'msg': 'collection is required', 'type': 'value_error'}]
    assert not actual["success"]


def test_add_vectordb_action_empty_operation_value():
    request_body = {
        "name": 'action_test_empty_operation_value',
        "collection": 'test_add_vectordb_action_empty_operation_value',
        "payload": [{"query_type": "", "type": "from_value", "value": {"ids": [0], "with_payload": True, "with_vector": True}}],
        "response": {"value": "0"}
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'payload', 0, 'query_type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'payload_search', 'embedding_search'",
                                  'type': 'type_error.enum',
                                  'ctx': {'enum_values': ['payload_search', 'embedding_search']}}]
    assert not actual["success"]


def test_add_vectordb_action_empty_payload_type():
    request_body = {
        "name": "test_add_vectordb_action_empty_payload_type",
        "collection": 'test_add_vectordb_action_empty_payload_type',
        "payload": [{
            "query_type": "payload_search",
            "type": "",
            "value": {"ids": [0], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "0"},
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'payload', 0, 'type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'from_value', 'from_slot', 'from_user_message'",
                                  'type': 'type_error.enum',
                                  'ctx': {'enum_values': ['from_value', 'from_slot', 'from_user_message']}},
                                 {'loc': ['body', 'payload', 0, '__root__'], 'msg': 'type is required',
                                  'type': 'value_error'}]
    assert not actual["success"]


def test_add_vectordb_action_without_enable_faq():
    request_body = {
        "name": "vectordb_action_test",
        "collection": 'test_add_vectordb_action_collection_does_not_exists',
        "payload": [{"query_type": "payload_search","type": "from_value", "value": {
            "filter": {
                "should": [
                    {"key": "city", "match": {"value": "London"}},
                    {"key": "color", "match": {"value": "red"}}
                ]
            }
        }}],
        "response": {"value": "0"}
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == 'Collection does not exist!'
    assert not actual["success"]


def test_add_vectordb_action_collection_does_not_exists(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "vectordb_action_test",
        "collection": 'test_add_vectordb_action_collection_does_not_exists',
        "payload": [{"query_type": "payload_search","type": "from_value", "value": {
            "filter": {
                "should": [
                    {"key": "city", "match": {"value": "London"}},
                    {"key": "color", "match": {"value": "red"}}
                ]
            }
        }}],
        "response": {"value": "0"}
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == 'Collection does not exist!'
    assert not actual["success"]


def test_add_vectordb_action(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema",
        json={
            "metadata": [{"column_name": "city", "data_type": "str", "enable_search": True, "create_embeddings": True},
                         {"column_name": "color", "data_type": "str", "enable_search": True,
                          "create_embeddings": True}],
            "collection_name": "test_add_vectordb_action"
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual = response.json()
    pytest.delete_schema_id_db_action = actual["data"]["_id"]
    payload = {
        "data": {"city": "London", "color": "red"},
        "collection": "test_add_vectordb_action",
        "content_type": "json"}
    payload_response = client.post(
        url=f"/api/bot/{pytest.bot}/data/cognition",
        json=payload,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    request_body = {
        "name": 'vectordb_action_test',
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        }],
        "response": {"value": "0"},
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    response_two = client.delete(
        url=f"/api/bot/{pytest.bot}/data/cognition/schema/{pytest.delete_schema_id_db_action}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token}
    )
    actual_two = response_two.json()

    assert not actual_two["success"]
    assert actual_two[
               "message"] == 'Cannot remove collection test_add_vectordb_action linked to action "vectordb_action_test"!'
    assert actual_two["data"] is None
    assert actual_two["error_code"] == 422


def test_add_vectordb_action_case_insensitivity(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "VECTORDB_ACTION_CASE_INSENSITIVE",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        }],
        "response": {"value": "0"},
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/VECTORDB_ACTION_CASE_INSENSITIVE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["data"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/vectordb_action_case_insensitive",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["success"]


def test_add_vectordb_action_existing(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": 'test_add_vectordb_action_existing',
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_value",
            "value": {"ids": [0], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "0"},
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "expression"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"
    assert not actual["success"]


def test_add_vectordb_action_with_slots(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "vectordb",
            "type": "text",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert "data" in actual
    assert actual["message"] == "Slot added successfully!"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    request_body = {
        "name": "test_add_vectordb_action_with_slots",
        "collection": 'test_add_vectordb_action',

        "payload": [{"query_type": "payload_search", "type": "from_slot", "value": "vectordb"}],
        "response": {"value": "0"},
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_add_vectordb_action_payload_and_embedding_search(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        },
        {
            "query_type": "embedding_search",
            "type": "from_value",
            "value": "Hi"
        },
        {
            "query_type": "embedding_search",
            "type": "from_value",
            "value": "How are you"
        }]
    request_body = {
        "name": "vectordb_action_payload_and_embedding_search",
        "collection": 'test_add_vectordb_action',
        "payload": payload,
        "response": {"value": "0"},
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/vectordb_action_payload_and_embedding_search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["data"]['name'] == 'vectordb_action_payload_and_embedding_search'
    assert not DeepDiff(actual["data"]['payload'], payload, ignore_order=True)
    assert actual["success"]


def test_add_vectordb_action_payload_search_mutiple_error(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    payload = [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        },{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "Canada"}},
                        {"key": "color", "match": {"value": "blue"}},
                    ]
                }
            },
        },
        {
            "query_type": "embedding_search",
            "type": "from_value",
            "value": "Hi"
        },
        {
            "query_type": "embedding_search",
            "type": "from_value",
            "value": "How are you"
        }]
    request_body = {
        "name": "vectordb_action_payload_and_embedding_search",
        "collection": 'test_add_vectordb_action',
        "payload": payload,
        "response": {"value": "0"},
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'payload'], 'msg': 'Only One payload_search is allowed!', 'type': 'value_error'}]
    assert not actual["success"]


def test_update_vectordb_action(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "test_update_vectordb_action",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        }],
        "response": {"value": "0"},
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    request_body = {
        "name": "test_update_vectordb_action",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_value",
            "value": {"ids": [0], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "0"},
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/test_update_vectordb_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]


def test_update_vectordb_action_non_existing(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "test_update_vectordb_action_non_existing",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_value",
            "value": {"ids": [6], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "15"},
        "set_slots": [
            {"name": "age", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    request_body = {
        "name": "test_update_vectordb_action_non_existing_new",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_value",
            "value": {"ids": [6], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "15"},
        "set_slots": [
            {"name": "age", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_update_vector_action_wrong_parameter(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "test_update_vector_action_1",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_value",
            "value": {"ids": [8], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "15"},
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "expression"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    request_body = {
        "name": "test_update_vector_action_1",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "embedding_search",
            "type": "from_val",
            "value": {"ids": [81], "with_payload": True, "with_vector": True},
        }],
        "response": {"value": "nupur"},
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "expression"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_get_vectordb_action():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/test_add_vectordb_action_with_slots",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]


def test_get_vector_action_non_exisitng():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db/never_added_vectordb_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] is not None
    assert not actual["success"]


def test_list_vector_db_action():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/db",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual['data'][0]['name'] == 'vectordb_action_test'


def test_delete_vectordb_action(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "test_delete_vectordb_action",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "London"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        }],
        "response": {"value": "30"},
        "set_slots": [],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/test_delete_vectordb_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_delete_vectordb_action_non_existing(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", llm_settings=LLMSettings(enable_faq=True))

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)
    request_body = {
        "name": "test_delete_vectordb_action_non_existing",
        "collection": 'test_add_vectordb_action',
        "payload": [{
            "query_type": "payload_search",
            "type": "from_value",
            "value": {
                "filter": {
                    "should": [
                        {"key": "city", "match": {"value": "India"}},
                        {"key": "color", "match": {"value": "red"}},
                    ]
                }
            },
        }],
        "response": {"value": "1"},
    }

    client.post(
        url=f"/api/bot/{pytest.bot}/action/db",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/new_vectordb_action_never_added",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_malformed_url():
    request_body = {
        "auth_token": "",
        "action_name": "new_http_action",
        "response": {"value": "", "dispatch": False, "evaluation_type": "script"},
        "http_url": "192.168.104.1/api/test",
        "request_method": "GET",
        "http_params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_missing_parameters():
    request_body = {
        "action_name": "new_http_action2",
        "response": {"value": "", "dispatch": False, "evaluation_type": "script"},
        "http_url": "http://www.google.com",
        "request_method": "put",
        "params_list": [{"key": "", "parameter_type": "", "value": ""}],
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_invalid_req_method():
    request_body = {
        "auth_token": "",
        "action_name": "new_http_action",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "TUP",
        "http_params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_no_action_name():
    request_body = {
        "auth_token": "",
        "action_name": "",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "http_params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_with_utter():
    request_body = {
        "action_name": "utter_test_add_http_action_no_token",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "http_params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "Action name cannot start with utter_"
    assert not actual["success"]


def test_add_http_action_no_token():
    request_body = {
        "auth_token": "",
        "action_name": "test_add_http_action_no_token",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "http_params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_add_http_action_with_valid_dispatch_type():
    request_body = {
        "action_name": "test_add_http_action_with_valid_dispatch_type",
        "response": {"value": "string", "dispatch_type": "json"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "dynamic_params": '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}',
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/test_add_http_action_with_valid_dispatch_type",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"]["response"] == {
        "value": "string",
        "dispatch": True,
        "evaluation_type": "expression",
        "dispatch_type": "json",
    }
    assert actual["data"]["http_url"] == "http://www.google.com"
    assert actual["data"]["request_method"] == "GET"
    assert len(actual["data"]["params_list"]) == 0
    assert (
            actual["data"]["dynamic_params"]
            == '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}'
    )


def test_add_http_action_with_invalid_dispatch_type():
    request_body = {
        "action_name": "test_add_http_action_with_invalid_dispatch_type",
        "response": {"value": "string", "dispatch_type": "invalid_dispatch_type"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "dynamic_params": '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}',
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert not actual["success"]
    assert str(actual["message"]).__contains__(
        "value is not a valid enumeration member"
    )
    assert actual["data"] is None
    assert actual["error_code"] == 422


def test_add_http_action_with_dynamic_params():
    request_body = {
        "action_name": "test_add_http_action_with_dynamic_params",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "dynamic_params": '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}',
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_update_http_action_with_dynamic_params():
    request_body = {
        "action_name": "test_update_http_action_with_dynamic_params",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    request_body = {
        "action_name": "test_update_http_action_with_dynamic_params",
        "content_type": "application/x-www-form-urlencoded",
        "response": {
            "value": "json",
            "dispatch": False,
            "evaluation_type": "script",
            "dispatch_type": "json",
        },
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "dynamic_params": '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}',
        "headers": [
            {
                "key": "Authorization",
                "parameter_type": "value",
                "value": "bearer token",
                "encrypt": True,
            }
        ],
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/test_update_http_action_with_dynamic_params",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]["response"] == {
        "value": "json",
        "dispatch": False,
        "evaluation_type": "script",
        "dispatch_type": "json",
    }
    assert actual["data"]["http_url"] == "http://www.alphabet.com"
    assert actual["data"]["request_method"] == "POST"
    assert len(actual["data"]["params_list"]) == 0
    assert (
            actual["data"]["dynamic_params"]
            == '{"sender_id": "${sender_id}", "user_message": "${user_message}", "intent": "${intent}"}'
    )
    assert actual["data"]["headers"] == [
        {
            "key": "Authorization",
            "value": "bearer token",
            "parameter_type": "value",
            "encrypt": True,
        }
    ]
    assert actual["success"]


def test_add_http_action_with_sender_id_parameter_type():
    request_body = {
        "auth_token": "",
        "action_name": "test_add_http_action_with_sender_id_parameter_type",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {
                "key": "testParam1",
                "parameter_type": "sender_id",
                "value": "testValue1",
                "encrypt": True,
            },
            {
                "key": "testParam2",
                "parameter_type": "slot",
                "value": "testValue2",
                "encrypt": True,
            },
            {
                "key": "testParam3",
                "encrypt": True,
                "parameter_type": "user_message",
            },
            {"key": "testParam4", "parameter_type": "chat_log", "encrypt": True},
            {"key": "testParam5", "parameter_type": "intent", "encrypt": True},
            {
                "key": "testParam6",
                "parameter_type": "value",
                "encrypt": True,
                "value": "12345",
            },
            {
                "key": "testParam7",
                "parameter_type": "key_vault",
                "encrypt": False,
                "value": "ACCESS_KEY",
            },
        ],
        "headers": [
            {"key": "testParam1", "parameter_type": "sender_id", "value": "testValue1"},
            {"key": "testParam2", "parameter_type": "slot", "value": "testValue2"},
            {
                "key": "testParam3",
                "parameter_type": "user_message",
            },
            {
                "key": "testParam4",
                "parameter_type": "chat_log",
            },
            {
                "key": "testParam5",
                "parameter_type": "intent",
            },
            {"key": "testParam6", "parameter_type": "value", "value": "12345"},
            {
                "key": "testParam7",
                "parameter_type": "key_vault",
                "encrypt": False,
                "value": "SECRET_KEY",
            },
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_get_http_action():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/test_add_http_action_with_sender_id_parameter_type",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert (
            actual["data"]["action_name"]
            == "test_add_http_action_with_sender_id_parameter_type"
    )
    assert actual["data"]["response"] == {
        "value": "string",
        "dispatch": True,
        "evaluation_type": "expression",
        "dispatch_type": "text",
    }
    assert actual["data"]["http_url"] == "http://www.google.com"
    assert actual["data"]["request_method"] == "GET"
    assert actual["data"]["params_list"] == [
        {
            "key": "testParam1",
            "value": "testValue1",
            "parameter_type": "sender_id",
            "encrypt": True,
        },
        {
            "key": "testParam2",
            "value": "testvalue2",
            "parameter_type": "slot",
            "encrypt": True,
        },
        {
            "key": "testParam3",
            "value": "",
            "parameter_type": "user_message",
            "encrypt": True,
        },
        {
            "key": "testParam4",
            "value": "",
            "parameter_type": "chat_log",
            "encrypt": True,
        },
        {"key": "testParam5", "value": "", "parameter_type": "intent", "encrypt": True},
        {
            "key": "testParam6",
            "value": "12345",
            "parameter_type": "value",
            "encrypt": True,
        },
        {
            "key": "testParam7",
            "value": "ACCESS_KEY",
            "parameter_type": "key_vault",
            "encrypt": True,
        },
    ]
    assert actual["data"]["headers"] == [
        {
            "key": "testParam1",
            "value": "testValue1",
            "parameter_type": "sender_id",
            "encrypt": False,
        },
        {
            "key": "testParam2",
            "value": "testvalue2",
            "parameter_type": "slot",
            "encrypt": False,
        },
        {
            "key": "testParam3",
            "value": "",
            "parameter_type": "user_message",
            "encrypt": False,
        },
        {
            "key": "testParam4",
            "value": "",
            "parameter_type": "chat_log",
            "encrypt": False,
        },
        {
            "key": "testParam5",
            "value": "",
            "parameter_type": "intent",
            "encrypt": False,
        },
        {
            "key": "testParam6",
            "value": "12345",
            "parameter_type": "value",
            "encrypt": False,
        },
        {
            "key": "testParam7",
            "value": "SECRET_KEY",
            "parameter_type": "key_vault",
            "encrypt": True,
        },
    ]
    assert not actual["message"]
    assert actual["success"]


def test_add_http_action_invalid_parameter_type():
    request_body = {
        "auth_token": "",
        "action_name": "test_add_http_action_invalid_parameter_type",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {"key": "testParam1", "parameter_type": "val", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_add_http_action_with_token():
    request_body = {
        "action_name": "test_add_http_action_with_token_and_story",
        "response": {"value": "string", "evaluation_type": "script"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "headers": [
            {
                "key": "Authorization",
                "parameter_type": "value",
                "value": "bearer dfiuhdfishifoshfoishnfoshfnsif***",
                "encrypt": True,
            },
            {
                "key": "testParam1",
                "parameter_type": "value",
                "value": "testVal***",
                "encrypt": True,
            },
            {
                "key": "testParam1",
                "parameter_type": "value",
                "value": "testVal***",
                "encrypt": True,
            },
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/test_add_http_action_with_token_and_story",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]["response"] == {
        "dispatch": True,
        "evaluation_type": "script",
        "value": "string",
        "dispatch_type": "text",
    }
    assert actual["data"]["headers"] == [
        {
            "key": "Authorization",
            "parameter_type": "value",
            "value": "bearer dfiuhdfishifoshfoishnfoshfnsif***",
            "encrypt": True,
        },
        {
            "key": "testParam1",
            "parameter_type": "value",
            "value": "testVal***",
            "encrypt": True,
        },
        {
            "key": "testParam1",
            "parameter_type": "value",
            "value": "testVal***",
            "encrypt": True,
        },
    ]
    assert actual["data"]["http_url"] == "http://www.google.com"
    assert actual["data"]["request_method"] == "GET"
    assert len(actual["data"]["headers"]) == 3
    assert actual["success"]


def test_add_http_action_no_params():
    request_body = {
        "auth_token": "",
        "action_name": "test_add_http_action_no_params",
        "response": {"value": "string", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_add_http_action_existing():
    request_body = {
        "auth_token": "",
        "action_name": "test_add_http_action_existing",
        "response": {"value": "string", "dispatch": False, "evaluation_type": "script"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_get_http_action_non_exisitng():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/never_added",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] is not None
    assert not actual["success"]


def test_update_http_action():
    request_body = {
        "action_name": "test_update_http_action",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    request_body = {
        "action_name": "test_update_http_action",
        "content_type": "application/x-www-form-urlencoded",
        "response": {
            "value": "json",
            "dispatch": False,
            "evaluation_type": "script",
            "dispatch_type": "json",
        },
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {
                "key": "testParam1",
                "parameter_type": "value",
                "value": "testValue1",
                "encrypt": True,
            },
            {
                "key": "testParam2",
                "parameter_type": "slot",
                "value": "testValue1",
                "encrypt": True,
            },
        ],
        "headers": [
            {
                "key": "Authorization",
                "parameter_type": "value",
                "value": "bearer token",
                "encrypt": True,
            }
        ],
        "set_slots": [
            {"name": "bot", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/test_update_http_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]["response"] == {
        "value": "json",
        "dispatch": False,
        "evaluation_type": "script",
        "dispatch_type": "json",
    }
    assert actual["data"]["http_url"] == "http://www.alphabet.com"
    assert actual["data"]["request_method"] == "POST"
    assert len(actual["data"]["params_list"]) == 2
    assert actual["data"]["params_list"] == [
        {
            "key": "testParam1",
            "value": "testValue1",
            "parameter_type": "value",
            "encrypt": True,
        },
        {
            "key": "testParam2",
            "value": "testvalue1",
            "parameter_type": "slot",
            "encrypt": True,
        },
    ]
    assert actual["data"]["headers"] == [
        {
            "key": "Authorization",
            "value": "bearer token",
            "parameter_type": "value",
            "encrypt": True,
        }
    ]
    assert actual["success"]


def test_update_http_action_wrong_parameter():
    request_body = {
        "auth_token": "",
        "action_name": "test_update_http_action_6",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0

    request_body = {
        "auth_token": "bearer hjklfsdjsjkfbjsbfjsvhfjksvfjksvfjksvf",
        "action_name": "test_update_http_action_6",
        "response": {"value": "json"},
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {"key": "testParam1", "parameter_type": "val", "value": "testValue1"},
            {"key": "testParam2", "parameter_type": "slot", "value": "testValue1"},
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]

    request_body = {
        "auth_token": "bearer hjklfsdjsjkfbjsbfjsvhfjksvfjksvfjksvf",
        "action_name": "test_update_http_action_6",
        "response": {"value": "json"},
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {"key": "testParam1", "parameter_type": "val", "value": "testValue1"},
            {"key": "testParam2", "parameter_type": "slot", "value": "testValue1"},
        ],
        "set_slots": [
            {"name": " ", "value": "${RESPONSE}", "evaluation_type": "script"}
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'params_list', 0, 'parameter_type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log', 'key_vault'",
                                  'type': 'type_error.enum', 'ctx': {
            'enum_values': ['value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log',
                            'key_vault']}}, {'loc': ['body', 'set_slots', 0, 'name'], 'msg': 'slot name is required',
                                             'type': 'value_error'}]

    assert not actual["success"]

    request_body = {
        "auth_token": "bearer hjklfsdjsjkfbjsbfjsvhfjksvfjksvfjksvf",
        "action_name": "test_update_http_action_6",
        "response": {"value": "json"},
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {"key": "testParam1", "parameter_type": "val", "value": "testValue1"},
            {"key": "testParam2", "parameter_type": "slot", "value": "testValue1"},
        ],
        "set_slots": [{"name": "bot", "value": " ", "evaluation_type": "script"}],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'params_list', 0, 'parameter_type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log', 'key_vault'",
                                  'type': 'type_error.enum', 'ctx': {
            'enum_values': ['value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log',
                            'key_vault']}}, {'loc': ['body', 'set_slots', 0, 'value'],
                                             'msg': 'expression is required to evaluate value of slot',
                                             'type': 'value_error'}]

    assert not actual["success"]

    request_body = {
        "auth_token": "bearer hjklfsdjsjkfbjsbfjsvhfjksvfjksvfjksvf",
        "action_name": "test_update_http_action_6",
        "response": {"value": " ", "dispatch": True},
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {"key": "testParam1", "parameter_type": "val", "value": "testValue1"},
            {"key": "testParam2", "parameter_type": "slot", "value": "testValue1"},
        ],
        "set_slots": [{"name": "bot", "value": " ", "evaluation_type": "script"}],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {'loc': ['body', 'response', '__root__'], 'msg': 'response is required for dispatch', 'type': 'value_error'},
        {'loc': ['body', 'params_list', 0, 'parameter_type'],
         'msg': "value is not a valid enumeration member; permitted: 'value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log', 'key_vault'",
         'type': 'type_error.enum', 'ctx': {
            'enum_values': ['value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log',
                            'key_vault']}},
        {'loc': ['body', 'set_slots', 0, 'value'], 'msg': 'expression is required to evaluate value of slot',
         'type': 'value_error'}]

    assert not actual["success"]


def test_update_http_action_non_existing():
    request_body = {
        "auth_token": "",
        "action_name": "test_update_http_action_non_existing",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    request_body = {
        "auth_token": "bearer hjklfsdjsjkfbjsbfjsvhfjksvfjksvfjksvf",
        "action_name": "test_update_http_action_non_existing_new",
        "response": "json",
        "http_url": "http://www.alphabet.com",
        "request_method": "POST",
        "params_list": [
            {"key": "param1", "value": "value1", "parameter_type": "value"},
            {"key": "param2", "value": "value2", "parameter_type": "slot"},
        ],
    }
    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_delete_http_action():
    request_body = {
        "auth_token": "",
        "action_name": "test_delete_http_action",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/test_delete_http_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_delete_http_action_non_existing():
    request_body = {
        "auth_token": "",
        "action_name": "new_http_action4",
        "response": {"value": "", "dispatch": False},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [],
    }

    client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/new_http_action_never_added",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"]
    assert not actual["success"]


def test_list_actions():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path_action",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "action_greet", "type": "ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert not DeepDiff(actual['data'], {'actions': ['action_greet'],
                              'database_action': ['vectordb_action_test', 'vectordb_action_case_insensitive',
                                                  'test_add_vectordb_action_existing',
                                                  'test_add_vectordb_action_with_slots',
                                                  'test_update_vectordb_action',
                                                  'test_update_vectordb_action_non_existing',
                                                  'test_update_vector_action_1',
                                                  'test_delete_vectordb_action_non_existing',
                                                  'vectordb_action_payload_and_embedding_search'],
                              'http_action': ['test_add_http_action_no_token',
                                              'test_add_http_action_with_valid_dispatch_type',
                                              'test_add_http_action_with_dynamic_params',
                                              'test_update_http_action_with_dynamic_params',
                                              'test_add_http_action_with_sender_id_parameter_type',
                                              'test_add_http_action_with_token_and_story',
                                              'test_add_http_action_no_params',
                                              'test_add_http_action_existing', 'test_update_http_action',
                                              'test_update_http_action_6', 'test_update_http_action_non_existing',
                                              'new_http_action4'],
                              'utterances': ['utter_greet', 'utter_cheer_up', 'utter_did_that_help', 'utter_happy',
                                             'utter_goodbye', 'utter_iamabot', 'utter_default',
                                             'utter_please_rephrase'],
                              'slot_set_action': [], 'form_validation_action': [], 'email_action': [],
                              'google_search_action': [],
                              'jira_action': [], 'zendesk_action': [], 'pipedrive_leads_action': [],
                              'hubspot_forms_action': [],
                              'two_stage_fallback': [], 'kairon_bot_response': [], 'razorpay_action': [],
                              'prompt_action': [], 'callback_action': [], 'schedule_action': [],
                              'pyscript_action': [], 'web_search_action': [], 'live_agent_action': [],
                                         'parallel_action':[]}, ignore_order=True)

    assert actual["success"]


@responses.activate
def test_train_using_event():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.model_training}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/train",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["message"] == "Model training started."
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.model_training
    )


def test_list_action_server_logs_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/actions/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"]["logs"] == []
    assert actual["data"]["total"] == 0


def test_list_action_server_logs():
    bot = pytest.bot
    bot_2 = "integration2"
    request_params = {"key": "value", "key2": "value2"}
    expected_intents = [
        "intent13",
        "intent11",
        "intent9",
        "intent8",
        "intent7",
        "intent6",
        "intent5",
        "intent4",
        "intent3",
        "intent2",
    ]
    ActionServerLogs(
        intent="intent1",
        action="http_action",
        sender="sender_id",
        timestamp="2021-04-05T07:59:08.771000",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent2",
        action="http_action",
        sender="sender_id",
        url="http://kairon-api.digite.com/api/bot",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent1",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot_2,
    ).save()
    ActionServerLogs(
        intent="intent3",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent4",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent5",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent6",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent7",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent8",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent9",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent10",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot_2,
    ).save()
    ActionServerLogs(
        intent="intent11",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent12",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot_2,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent13",
        action="http_action",
        sender="sender_id_13",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    response = client.get(
        f"/api/bot/{pytest.bot}/actions/logs",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )


    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]["logs"]) == 10
    assert actual["data"]["total"] == 10
    assert [log["intent"] in expected_intents for log in actual["data"]["logs"]]
    assert actual["data"]["logs"][0]["action"] == "http_action"
    assert any(
        [log["request_params"] == request_params for log in actual["data"]["logs"]]
    )
    assert any([log["sender"] == "sender_id_13" for log in actual["data"]["logs"]])
    assert any(
        [log["bot_response"] == "Bot Response" for log in actual["data"]["logs"]]
    )
    assert any([log["api_response"] == "Response" for log in actual["data"]["logs"]])
    assert any([log["status"] == STATUSES.FAIL.value for log in actual["data"]["logs"]])
    assert any([log["status"] == STATUSES.SUCCESS.value for log in actual["data"]["logs"]])

    from_date = date.today()
    to_date = from_date + timedelta(days=1)
    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/actions/search"
        f"?from_date={from_date}&to_date={to_date}&status=Success",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response_json = search_response.json()
    print("actions:", response_json)

    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    assert data['total'] == 6

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/actions/search"
        f"?from_date={from_date}&to_date={to_date}&status=Failed",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response_json = search_response.json()
    print("actions:", response_json)

    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    assert data['total'] == 4
    response = client.get(
        f"/api/bot/{pytest.bot}/actions/logs?start_idx=0&page_size=15",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/actions?start_idx=0&page_size=15",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]["logs"]) == 10
    assert actual["data"]["total"] == 10

    response = client.get(
        f"/api/bot/{pytest.bot}/actions/logs?start_idx=10&page_size=1",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 11


def test_get_mail_channel_logs():
    MailResponseLog(
        sender_id="chocoboyxp@gmail.com",
        uid=4337,
        responses=[
            {
                "recipient_id": "spandan.mondal@nimblework.com",
                "text": "How may i help you?"
            }
        ],
        slots={
            "doc_url": "None",
            "document": "None",
            "video": "None",
            "audio": "None",
            "image": "None",
            "kairon_action_response": "None",
            "bot": "67e24b3847fb806ba96ff494",
            "session_started_metadata": "{'channel': 'mail', 'tabname': 'default', 'is_integration_user': False, 'bot': '64a43ce6af92e374371ed5bd', 'account': 1048, 'channel_type': 'chat_client'}",
            "bot_response": "How may i help you?"
        },
        bot=pytest.bot,
        user="spandan.mondal@nimblework.com",
        status=MailStatus.SUCCESS.value
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/mail_channel",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    from_date = datetime.utcnow().date() - timedelta(days=1)
    to_date = datetime.utcnow().date() + timedelta(days=1)
    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/mail_channel/search"
        f"?from_date={from_date}&to_date={to_date}&status=success",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )
    response_json = search_response.json()
    print("actions:", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0
    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)


def test_feedback():
    request = {
        "rating": 5.0,
        "scale": 5.0,
        "feedback": "The product is better than rasa.",
    }
    response = client.post(
        f"/api/account/feedback",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Thanks for your feedback!"


def test_add_rule():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    pytest.story_id = actual["data"]["_id"]


def test_add_rule_with_name_already_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "ask the user to rephrase whenever they send a message with low nlu confidence",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["data"] is None
    assert actual["message"] == "Rule with the name already exists"


def test_add_rule_invalid_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "TEST",
            "template_type": "Q&A",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "type"],
            "msg": "value is not a valid enumeration member; permitted: 'STORY', 'RULE', 'MULTIFLOW'",
            "type": "type_error.enum",
            "ctx": {"enum_values": ["STORY", "RULE", "MULTIFLOW"]},
        }
    ]


def test_add_rule_empty_event():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={"name": "test_add_rule_empty_event", "type": "RULE", "steps": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Steps are required to form Flow",
            "type": "value_error",
        }
    ]


def test_add_rule_lone_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_rule_lone_intent",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
                {"name": "greet_again", "type": "INTENT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Intent should be followed by utterance or action",
            "type": "value_error",
        }
    ]


def test_add_rule_consecutive_intents():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_rule_consecutive_intents",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Found 2 consecutive intents",
            "type": "value_error",
        }
    ]


def test_add_rule_multiple_actions():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_rule_consecutive_actions",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "HTTP_ACTION"},
                {"name": "utter_greet_again", "type": "HTTP_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"


def test_add_rule_utterance_as_first_step():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_rule_consecutive_intents",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "BOT"},
                {"name": "utter_greet", "type": "HTTP_ACTION"},
                {"name": "utter_greet_again", "type": "HTTP_ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "First step should be an intent",
            "type": "value_error",
        }
    ]


def test_add_rule_missing_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [{"name": "greet"}, {"name": "utter_greet", "type": "BOT"}],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps", 0, "type"],
            "msg": "field required",
            "type": "value_error.missing",
        }
    ]


def test_add_rule_invalid_event_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "data"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
            "loc": ["body", "steps", 0, "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', 'FORM_END', 'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', 'GOOGLE_SEARCH_ACTION', 'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', 'PIPEDRIVE_LEADS_ACTION', 'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', 'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', 'PROMPT_ACTION', 'DATABASE_ACTION', 'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', 'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
        }
    ]

def test_update_rule_with_tag():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
            "flow_tags": ["agentic_flow"]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow updated successfully"
    assert actual["data"]["_id"]



def test_update_rule():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow updated successfully"
    assert actual["data"]["_id"]


def test_update_rule_with_name_already_exists():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_add_rule_consecutive_actions",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Rule with the name already exists"
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_update_rule_invalid_event_type():
    response = client.put(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "data"},
                {"name": "utter_nonsense", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "ctx": {
                "enum_values": [
                    "INTENT",
                    "SLOT",
                    "FORM_START",
                    "FORM_END",
                    "BOT",
                    "HTTP_ACTION",
                    "ACTION",
                    "SLOT_SET_ACTION",
                    "FORM_ACTION",
                    "GOOGLE_SEARCH_ACTION",
                    "EMAIL_ACTION",
                    "JIRA_ACTION",
                    "ZENDESK_ACTION",
                    "PIPEDRIVE_LEADS_ACTION",
                    "HUBSPOT_FORMS_ACTION",
                    "RAZORPAY_ACTION",
                    "TWO_STAGE_FALLBACK_ACTION",
                    "PYSCRIPT_ACTION",
                    "PROMPT_ACTION",
                    "DATABASE_ACTION",
                    "WEB_SEARCH_ACTION",
                    "LIVE_AGENT_ACTION",
                    "STOP_FLOW_ACTION",
                    "CALLBACK_ACTION",
                    "SCHEDULE_ACTION",
                    "PARALLEL_ACTION"
                ]
            },
            "loc": ["body", "steps", 0, "type"],
            "msg": "value is not a valid enumeration member; permitted: 'INTENT', 'SLOT', 'FORM_START', 'FORM_END', 'BOT', 'HTTP_ACTION', 'ACTION', 'SLOT_SET_ACTION', 'FORM_ACTION', 'GOOGLE_SEARCH_ACTION', 'EMAIL_ACTION', 'JIRA_ACTION', 'ZENDESK_ACTION', 'PIPEDRIVE_LEADS_ACTION', 'HUBSPOT_FORMS_ACTION', 'RAZORPAY_ACTION', 'TWO_STAGE_FALLBACK_ACTION', 'PYSCRIPT_ACTION', 'PROMPT_ACTION', 'DATABASE_ACTION', 'WEB_SEARCH_ACTION', 'LIVE_AGENT_ACTION', 'STOP_FLOW_ACTION', 'CALLBACK_ACTION', 'SCHEDULE_ACTION', 'PARALLEL_ACTION'",
            "type": "type_error.enum",
        }
    ]


def test_delete_rule():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path1",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"
    pytest.story_id = actual["data"]["_id"]

    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}/RULE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow deleted successfully"


def test_delete_non_existing_rule():
    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}/RULE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Flow does not exists"


def test_add_rule_with_multiple_intents():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "RULE",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
                {"name": "location", "type": "INTENT"},
                {"name": "utter_location", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Found rules 'test_path' that contain more than intent.\nPlease use stories for this case",
            "type": "value_error",
        }
    ]
    assert actual["data"] is None


@responses.activate
def test_validate():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/validate",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Event triggered! Check logs."
    complete_end_to_end_event_execution(
        pytest.bot, "test_user", EventClass.data_importer
    )


@responses.activate
def test_upload_missing_data():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    files = (
        (
            "training_files",
            (
                "domain.yml",
                BytesIO(open("tests/testing_data/all/domain.yml", "rb").read()),
            ),
        ),
        (
            "training_files",
            (
                "stories.yml",
                BytesIO(open("tests/testing_data/all/data/stories.yml", "rb").read()),
            ),
        ),
        (
            "training_files",
            (
                "config.yml",
                BytesIO(open("tests/testing_data/all/config.yml", "rb").read()),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "test_user", EventClass.data_importer
    )


@responses.activate
def test_upload_valid_and_invalid_data():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    files = (
        ("training_files", ("nlu_1.yml", b"")),
        (
            "training_files",
            ("domain_5.yml", open("tests/testing_data/all/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/all/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("config_6.yml", open("tests/testing_data/all/config.yml", "rb")),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "test_user", EventClass.data_importer
    )


def test_upload_with_http_error():
    config = Utility.load_yaml("./tests/testing_data/yml_training_files/config.yml")
    config.get("pipeline").append({"name": "XYZ"})
    files = (
        ("training_files", ("config.yml", json.dumps(config).encode())),
        (
            "training_files",
            ("actions.yml", open("tests/testing_data/error/actions.yml", "rb")),
        ),
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 4
    assert actual["data"]["total"] == 4
    assert actual["data"]["logs"][0]["status"] == STATUSES.FAIL.value
    assert actual["data"]["logs"][0]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][0]["is_data_uploaded"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert (
            "Required fields {'request_method'} not found"
            in str(actual["data"]["logs"][0]["actions"][0]["data"][0])
    )
    assert actual["data"]["logs"][0]["config"]["data"] == ["Invalid component XYZ"]


def test_upload_actions_and_config():
    files = (
        (
            "training_files",
            (
                "config.yml",
                open("tests/testing_data/yml_training_files/config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "actions.yml",
                open("tests/testing_data/yml_training_files/actions.yml", "rb"),
            ),
        ),
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 5
    assert actual["data"]["total"] == 5
    assert actual['data']["logs"][0]['status'] == STATUSES.SUCCESS.value
    assert actual['data']["logs"][0]['event_status'] == EVENT_STATUS.COMPLETED.value
    assert actual['data']["logs"][0]['is_data_uploaded']
    assert actual['data']["logs"][0]['start_timestamp']
    assert actual['data']["logs"][0]['end_timestamp']
    print(actual['data']["logs"][0]['actions'])
    assert actual['data']["logs"][0]['actions'] == [{'type': 'http_actions', 'count': 17, 'data': []},
                                                    {'type': 'two_stage_fallbacks', 'count': 0, 'data': []},
                                                    {'type': 'email_actions', 'count': 0, 'data': []},
                                                    {'type': 'zendesk_actions', 'count': 0, 'data': []},
                                                    {'type': 'jira_actions', 'count': 0, 'data': []},
                                                    {'type': 'form_validation_actions', 'count': 1, 'data': []},
                                                    {'type': 'slot_set_actions', 'count': 0, 'data': []},
                                                    {'type': 'google_search_actions', 'count': 1, 'data': []},
                                                    {'type': 'pipedrive_leads_actions', 'count': 0, 'data': []},
                                                    {'type': 'prompt_actions', 'count': 0, 'data': []},
                                                    {'type': 'web_search_actions', 'count': 0, 'data': []},
                                                    {'type': 'razorpay_actions', 'count': 0, 'data': []},
                                                    {'type': 'pyscript_actions', 'count': 0, 'data': []},
                                                    {'type': 'database_actions', 'count': 0, 'data': []},
                                                    {'type': 'live_agent_actions', 'count': 0, 'data': []},
                                                    {'type': 'callback_actions', 'count': 0, 'data': []},
                                                    {'type': 'schedule_actions', 'count': 0, 'data': []},
                                                    {'type': 'parallel_actions', 'count': 0, 'data': []}]
    assert not actual['data']["logs"][0]['config']['data']

    response = client.get(
        f"/api/bot/{pytest.bot}/action/httpaction",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 17


@patch(
    "kairon.shared.importer.processor.DataImporterLogProcessor.is_limit_exceeded",
    autospec=True,
)
@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_upload_multiflow_stories(mock_is_limit_exceeded, mock_event_server):
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    files = (
        (
            "training_files",
            (
                "domain.yml",
                open("tests/testing_data/yml_training_files/domain.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "nlu.yml",
                open("tests/testing_data/yml_training_files/data/nlu.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "stories.yml",
                open("tests/testing_data/yml_training_files/data/stories.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "rules.yml",
                open("tests/testing_data/yml_training_files/data/rules.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "actions.yml",
                open("tests/testing_data/yml_training_files/actions.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open(
                    "tests/testing_data/yml_training_files/chat_client_config.yml", "rb"
                ),
            ),
        ),
        (
            "training_files",
            (
                "config.yml",
                open("tests/testing_data/yml_training_files/config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "multiflow_stories.yml",
                open(
                    "tests/testing_data/yml_training_files/multiflow_stories.yml", "rb"
                ),
            ),
        ),
    )
    mock_is_limit_exceeded.return_value = False
    response = client.post(
        f"/api/bot/{pytest.bot}/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "test_user", EventClass.data_importer
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/importer/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert set(actual["data"]["logs"][0]["files_received"]) == {
        "rules",
        "stories",
        "nlu",
        "domain",
        "config",
        "actions",
        "chat_client_config",
        "multiflow_stories",
    }


def test_get_editable_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not DeepDiff(
        actual["data"],
        {
            "nlu_confidence_threshold": 0.75,
            "action_fallback": "action_small_talk",
            "action_fallback_threshold": 0.3,
            "ted_epochs": 5,
            "nlu_epochs": 5,
            "response_epochs": 5,
        },
        ignore_order=True,
    )


def test_set_epoch_and_fallback():
    request = {
        "nlu_epochs": 200,
        "response_epochs": 100,
        "ted_epochs": 150,
        "nlu_confidence_threshold": 0.7,
        "action_fallback_threshold": 0.3,
        "action_fallback": "action_default_fallback",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_default",
        json={"data": "Sorry I didnt get that. Can you rephrase?"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"

    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved"


def test_get_config_all():
    response = client.get(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]


def test_set_epoch_and_fallback_modify_action_only():
    request = {"nlu_confidence_threshold": 0.3, "action_fallback": "utter_default"}
    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved"


def test_set_epoch_and_fallback_empty_pipeline_and_policies():
    request = {"nlu_confidence_threshold": 20}
    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=request,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "nlu_confidence_threshold"],
            "msg": "Please choose a threshold between 0.3 and 0.9",
            "type": "value_error",
        }
    ]


def test_set_epoch_and_fallback_empty_request():
    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "At least one field is required"


def test_set_epoch_and_fallback_negative_epochs():
    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"nlu_epochs": 0},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "nlu_epochs"],
            "msg": "Choose a positive number as epochs",
            "type": "value_error",
        }
    ]

    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"response_epochs": -1, "ted_epochs": 0, "nlu_epochs": 200},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0] == {
        "loc": ["body", "response_epochs"],
        "msg": "Choose a positive number as epochs",
        "type": "value_error",
    }
    assert actual["message"][1] == {
        "loc": ["body", "ted_epochs"],
        "msg": "Choose a positive number as epochs",
        "type": "value_error",
    }


def test_set_epoch_and_fallback_max_epochs():
    epoch_max_limit = Utility.environment["model"]["config_properties"][
        "epoch_max_limit"
    ]
    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"nlu_epochs": epoch_max_limit + 1},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "nlu_epochs"],
            "msg": f"Please choose a epoch between 1 and {epoch_max_limit}",
            "type": "value_error",
        }
    ]

    response = client.put(
        f"/api/bot/{pytest.bot}/config/properties",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={
            "response_epochs": -1,
            "ted_epochs": epoch_max_limit + 1,
            "nlu_epochs": 200,
        },
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0] == {
        "loc": ["body", "response_epochs"],
        "msg": "Choose a positive number as epochs",
        "type": "value_error",
    }
    assert actual["message"][1] == {
        "loc": ["body", "ted_epochs"],
        "msg": f"Please choose a epoch between 1 and {epoch_max_limit}",
        "type": "value_error",
    }


def test_get_synonyms():
    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonyms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 0
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_synonym_values():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym",
        json={"data": "bot_add"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym added!"
    assert actual["data"]["_id"]

    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        json={"value": ["any"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym values added!"
    assert all(
        key in item.keys() for item in actual["data"] for key in ["_id", "value"]
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/value",
        json={"data": "any1"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym value added!"
    assert actual["data"]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert all(item["value"] in ["any", "any1"] for item in actual["data"])
    assert all(
        key in item.keys()
        for item in actual["data"]
        for key in ["_id", "synonym", "value"]
    )


def test_get_specific_synonym_values():
    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 2


def test_add_synonyms_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        json={"value": ["any"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Synonym value already exists"


def test_add_synonyms_value_empty():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        json={"value": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0]["msg"] == "value field cannot be empty"


def test_add_synonyms_empty():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/%20/values",
        json={"value": ["h"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Synonym name cannot be an empty!"


def test_edit_synonyms():
    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    response = client.put(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/value/{actual['data'][0]['_id']}",
        json={"data": "any4"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym value updated!"

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"])
    assert any(item["value"] == "any4" for item in actual["data"])


def test_delete_synonym_one_value():
    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    response = client.delete(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/value/{actual['data'][0]['_id']}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym value removed!"

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 1


def test_delete_synonym():
    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonyms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert all(
        key in item.keys() for item in actual["data"] for key in ["_id", "synonym"]
    )

    synonym_id = actual["data"][0]["_id"]
    synonym_name = actual["data"][0]["synonym"]
    response = client.delete(
        f"/api/bot/{pytest.bot}/entity/synonym/{synonym_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym removed!"

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonyms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == []

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/{synonym_name}/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["data"] == []


def test_add_synonyms_empty_value_element():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/bot_add/values",
        json={"value": ["df", ""]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0]["msg"] == "value cannot be an empty string"


def test_get_training_data_count(monkeypatch):
    def _mock_training_data_count(*args, **kwargs):
        return {
            "intents": [{"name": "greet", "count": 5}, {"name": "affirm", "count": 3}],
            "utterances": [
                {"name": "utter_greet", "count": 4},
                {"name": "utter_affirm", "count": 11},
            ],
        }

    monkeypatch.setattr(
        MongoProcessor, "get_training_data_count", _mock_training_data_count
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/data/count",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == _mock_training_data_count()


@responses.activate
def test_chat(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": "Hi"}
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        match=[responses.matchers.json_params_matcher(chat_json)],
        json={
            "success": True,
            "error_code": 0,
            "data": {"response": [{"bot": "Hi"}]},
            "message": None,
        },
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json=chat_json,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["response"]


@responses.activate
def test_chat_user(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": "Hi"}
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        match=[responses.matchers.json_params_matcher(chat_json)],
        json={
            "success": True,
            "error_code": 0,
            "data": {"response": [{"bot": "Hi"}]},
            "message": None,
        },
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json=chat_json,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["response"]


@responses.activate
def test_chat_with_data_empty(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": ""}
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json=chat_json,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "data cannot be empty"
    assert actual["error_code"] == 422
    assert actual["data"] is None


@responses.activate
def test_chat_augment_user_with_data_empty(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": ""}
    response = client.post(
        f"/api/bot/{pytest.bot}/chat/testUser",
        json=chat_json,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["message"] == "data cannot be empty"
    assert actual["error_code"] == 422
    assert actual["data"] is None


@responses.activate
def test_chat_augment_user(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": "Hi"}
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        match=[responses.matchers.json_params_matcher(chat_json)],
        json={
            "success": True,
            "error_code": 0,
            "data": {"response": [{"bot": "Hi"}]},
            "message": None,
        },
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/chat/testUser",
        json=chat_json,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["response"]


def test_get_client_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"]["whitelist"] == ["*"]


def test_get_client_config_url():
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config/url",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    pytest.url = actual["data"]


@responses.activate
def test_refresh_token(monkeypatch):
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"]["headers"]["authorization"]["token_type"] == "Bearer"
    ate = actual["data"]["headers"]["authorization"]["access_token_expiry"]
    rte = actual["data"]["headers"]["authorization"]["refresh_token_expiry"]
    assert (
            31
            >= round(
        (datetime.utcfromtimestamp(ate) - datetime.utcnow()).total_seconds() / 60
    )
            >= 29
    )
    assert (
            61
            >= round(
        (datetime.utcfromtimestamp(rte) - datetime.utcnow()).total_seconds() / 60
    )
            >= 59
    )
    refresh_token = actual["data"]["headers"]["authorization"]["refresh_token"]

    response = client.get(
        f"/api/auth/{pytest.bot}/token/refresh",
        headers={"Authorization": pytest.token_type + " " + refresh_token},
    )
    actual = response.json()
    # assert 1 == 0
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["access_token"]
    assert actual["data"]["token_type"]
    assert actual["data"]["refresh_token"]
    assert (
            actual["message"]
            == "This token will be shown only once. Please copy this somewhere safe."
               "It is your responsibility to keep the token secret. "
               "If leaked, others may have access to your system."
    )
    new_token = actual["data"]["access_token"]
    token_type = actual["data"]["token_type"]

    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        json={
            "success": True,
            "error_code": 0,
            "data": {"response": [{"bot": "Hi"}]},
            "message": None,
        },
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json={"data": "Hi"},
        headers={"Authorization": token_type + " " + new_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["response"]

    response = client.post(
        f"/api/bot/{pytest.bot}/metric/user/logs/user_metrics",
        json={"data": {"location": "india"}},
        headers={"Authorization": token_type + " " + new_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/model/reload",
        headers={"Authorization": token_type + " " + new_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_refresh_token_from_dynamic_token():
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    chat_token = actual["data"]["headers"]["authorization"]["access_token"]

    response = client.get(
        f"/api/auth/{pytest.bot}/token/refresh",
        headers={"Authorization": pytest.token_type + " " + chat_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Access denied for this endpoint"
    assert not actual["data"]


def test_trigger_api_server_using_refresh_token():
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    token_type = actual["data"]["headers"]["authorization"]["token_type"]
    refresh_token = actual["data"]["headers"]["authorization"]["refresh_token"]

    response = client.get(
        f"/api/bot/{pytest.bot}/model/reload",
        headers={"Authorization": token_type + " " + refresh_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Access denied for this endpoint"
    assert not actual["data"]


def test_get_client_config_using_invalid_uid():
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config/ecmkfnufjsufysfbksjnfaksn"
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]


def test_save_client_config():
    config_path = "./template/chat-client/default-config.json"
    config = json.load(open(config_path))
    config["headers"] = {}
    config["headers"]["X-USER"] = "kairon-user"
    response = client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": config},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved"

    config = ChatClientConfig.objects(bot=pytest.bot).get()
    assert config.config
    assert config.config["headers"]["X-USER"]
    assert not config.config["headers"].get("authorization")


@responses.activate
def test_get_client_config_using_uid(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": "Hi"}
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        match=[responses.matchers.json_params_matcher(chat_json)],
        json={
            "success": True,
            "error_code": 0,
            "data": None,
            "message": "Bot has not been trained yet!",
        },
    )
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert None == actual.get("data").get("whitelist")

    access_token = actual["data"]["headers"]["authorization"]["access_token"]
    token_type = actual["data"]["headers"]["authorization"]["token_type"]
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json=chat_json,
        headers={"Authorization": f"{token_type} {access_token}", "X-USER": "hacker"},
    )
    actual = response.json()
    assert actual["message"] == "Bot has not been trained yet!"

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={"Authorization": f"{token_type} {access_token}", "X-USER": "hacker"},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "Access denied for this endpoint"


@responses.activate
def test_get_client_config_refresh(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    chat_json = {"data": "Hi"}
    responses.add(
        responses.POST,
        f"http://localhost/api/bot/{pytest.bot}/chat",
        status=200,
        match=[responses.matchers.json_params_matcher(chat_json)],
        json={
            "success": True,
            "error_code": 0,
            "data": None,
            "message": "Bot has not been trained yet!",
        },
    )
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"]["headers"]["X-USER"] == "kairon-user"
    assert None == actual.get("data").get("whitelist")

    access_token = actual["data"]["headers"]["authorization"]["access_token"]
    token_type = actual["data"]["headers"]["authorization"]["token_type"]
    user = actual["data"]["headers"]["X-USER"]
    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json=chat_json,
        headers={"Authorization": f"{token_type} {access_token}", "X-USER": user},
    )
    actual = response.json()
    assert actual["message"] == "Bot has not been trained yet!"

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={"Authorization": f"{token_type} {access_token}", "X-USER": user},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "Access denied for this endpoint"


def test_get_chat_client_config_multilingual_enabled_no_bots_enabled():
    from bson import ObjectId

    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["multilingual"]["enable"] = True
    actual["data"]["multilingual"]["bots"] = [
        {"id": ObjectId().__str__(), "is_enabled": True}
    ]

    response = client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": actual["data"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved"

    response = client.get(pytest.url)
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Bot is disabled. Please use a valid bot."

    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0


def test_save_chat_client_config_enable_multilingual_bots():
    AccountProcessor.add_bot(
        name="demo-hi",
        account=pytest.account,
        user="integ1@gmail.com",
        metadata={
            "language": "hi",
            "source_bot_id": pytest.bot,
            "source_language": "en",
        },
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["multilingual"]["enable"]
    actual["data"]["multilingual"]["bots"][0]["is_enabled"] = True

    response = client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": actual["data"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Config saved"


def test_save_chat_client_config_enable_multilingual_bots_no_bot_enabled():
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["multilingual"]["enable"]
    actual["data"]["multilingual"]["bots"][0]["is_enabled"] = False

    response = client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": actual["data"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "At least one bot should be enabled!"


def test_get_chat_client_config_multilingual_enabled():
    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["multilingual"]["bots"]) == 1
    assert actual["data"]["multilingual"]["bots"][0]["is_enabled"]

    AccountProcessor.add_bot(
        name="demo-mr",
        account=pytest.account,
        user="integ1@gmail.com",
        metadata={
            "language": "hi",
            "source_bot_id": pytest.bot,
            "source_language": "en",
        },
    )

    response = client.get(pytest.url)
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["multilingual"]["bots"]) == 1
    assert actual["data"]["multilingual"]["bots"][0]["is_enabled"]

    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["multilingual"]["bots"]) == 3
    assert actual["data"]["multilingual"]["bots"][0]["is_enabled"]
    assert not actual["data"]["multilingual"]["bots"][1]["is_enabled"]


def test_get_metering():
    response = client.get(
        f"/api/bot/{pytest.bot}/metric/test_chat",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual == {"success": True, "message": None, "data": 0, "error_code": 0}
    response = client.get(
        f"/api/bot/{pytest.bot}/metric/prod_chat",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual == {"success": True, "message": None, "data": 0, "error_code": 0}


def test_add_story_with_no_type():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_add_story_with_no_type",
            "type": "STORY",
            "steps": [
                {"name": "greet", "type": "INTENT"},
                {"name": "utter_greet", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow added successfully"

    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "test_path",
            "type": "STORY",
            "steps": [
                {"name": "test_greet", "type": "INTENT"},
                {"name": "utter_test_greet", "type": "ACTION"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_get_stories_another_bot():
    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"][0]["template_type"] == "CUSTOM"
    assert actual["data"][1]["template_type"] == "CUSTOM"
    assert actual["data"][8]["template_type"] == "CUSTOM"
    assert actual["data"][8]["name"] == "ask the user to rephrase whenever they send a message with low nlu confidence"
    assert actual["data"][9]["template_type"] == "Q&A"
    assert actual["data"][9]["name"] == "test_path"


def test_add_regex_invalid():
    response = client.post(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "bot_add", "pattern": "[0-9]++"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "invalid regular expression"


def test_add_regex_empty_name():
    response = client.post(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "", "pattern": "q"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0]["msg"] == "Regex name cannot be empty or a blank space"


def test_add_regex_empty_pattern():
    response = client.post(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "b", "pattern": ""},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"][0]["msg"] == "Regex pattern cannot be empty or a blank space"
    )


def test_add_regex_():
    response = client.post(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "b", "pattern": "bb"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Regex pattern added successfully!"


def test_get_regex():
    response = client.get(
        f"/api/bot/{pytest.bot}/regex",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 1
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert "b" in actual["data"][0].values()
    assert "bb" in actual["data"][0].values()


def test_edit_regex():
    response = client.put(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "b", "pattern": "bbb"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Regex pattern modified successfully!"

    response = client.get(
        f"/api/bot/{pytest.bot}/regex",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 1
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert "b" in actual["data"][0].values()
    assert "bbb" in actual["data"][0].values()


def test_delete_regex():
    response = client.delete(
        f"/api/bot/{pytest.bot}/regex/b",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Regex pattern deleted!"

    response = client.get(
        f"/api/bot/{pytest.bot}/regex",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 0
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_and_move_training_examples_to_different_intent():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        json={"data": ["hey, there [bot](bot)!!"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 7

    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "test_add_and_move"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"

    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/move/test_add_and_move",
        json={
            "data": [
                "this will be moved",
                "this is a new [example](example)",
                " ",
                "",
                "hey, there [bot](bot)!!",
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/test_add_and_move",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 3


def test_add_and_move_training_examples_to_different_intent_not_exists():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/move/greeting",
        json={
            "data": [
                "this will be moved",
                "this is a new [example](example)",
                " ",
                "",
                "hey, there [bot](bot)!!",
            ]
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Intent does not exists"


def test_get_lookup_tables():
    response = client.get(
        f"/api/bot/{pytest.bot}/lookups",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"]) == 0
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])


def test_add_lookup_tables():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup",
        json={"data": "country"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup added!"
    assert actual["data"]["_id"]

    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        json={"value": ["india", "australia"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup values added!"
    assert all(
        key in item.keys() for item in actual["data"] for key in ["_id", "value"]
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/lookup",
        json={"data": "number"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup added!"
    assert actual["data"]["_id"]

    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/number/values",
        json={"value": ["one", "two"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup values added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/number/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert all(item["value"] in ["one", "two"] for item in actual["data"])
    assert all(
        key in item.keys()
        for item in actual["data"]
        for key in ["_id", "lookup", "value"]
    )


def test_get_lookup_table_values():
    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 2


def test_add_lookup_duplicate():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        json={"value": ["india"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Lookup value already exists"


def test_add_lookup_empty():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        json={"value": []},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"][0]["msg"] == "value field cannot be empty"


def test_edit_lookup():
    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    response = client.put(
        f"/api/bot/{pytest.bot}/lookup/country/value/{actual['data'][0]['_id']}",
        json={"data": "japan"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup value updated!"


def test_add_lookup_empty_name():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/%20/values",
        json={"value": ["h"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Lookup cannot be an empty string"


def test_delete_lookup_one_value():
    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    response = client.delete(
        f"/api/bot/{pytest.bot}/lookup/country/value/{actual['data'][0]['_id']}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup value removed!"

    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 1


def test_delete_lookup():
    response = client.get(
        f"/api/bot/{pytest.bot}/lookups",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    lookup = actual["data"][0]

    response = client.delete(
        f"/api/bot/{pytest.bot}/lookup/{lookup['_id']}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup removed!"

    response = client.get(
        f"/api/bot/{pytest.bot}/lookups",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 1


def test_add_lookup_empty_value_element():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/country/values",
        json={"value": ["df", ""]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"][0]["msg"] == "lookup value cannot be empty or a blank space"
    )


def test_list_form_none_exists():
    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_add_form_invalid_parameters():
    path = [
        {
            "ask_questions": [],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "settings", 0, "ask_questions"],
            "msg": "Questions cannot be empty or contain spaces",
            "type": "value_error",
        }
    ]

    path = [
        {
            "ask_questions": [" "],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "settings", 0, "ask_questions"],
            "msg": "Questions cannot be empty or contain spaces",
            "type": "value_error",
        }
    ]

    path = [
        {
            "ask_questions": ["name ?"],
            "slot": "",
            "slot_set": {"type": "custom", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "settings", 0, "slot"],
            "msg": "Slot is required",
            "type": "value_error",
        }
    ]


def test_get_slot_mapping_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/slots/mapping",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["data"] == []


def test_add_slot_mapping():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "name", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    assert actual["error_code"] == 0
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "name",
            "mapping": {"type": "from_text", "value": "user", "entity": "name"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_empty_slot_mapping():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={"slot": "num_people", "mapping": {}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == [
        {
            "loc": ["body", "mapping", 'type'],
            "msg": "field required",
            "type": "value_error.missing",
        }
    ]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={"slot": "num_people",
              "mapping": {"type": "from_text", "conditions": [{"requested_slot": "num_people"}]}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == [{'loc': ['body', 'mapping', 'conditions', 0],
                                  'msg': 'active_loop is required to add requested_slot as condition!',
                                  'type': 'value_error'}]


def test_add_form_with_invalid_slot_set_type():
    path = [
        {
            "ask_questions": ["what is your name?", "name?"],
            "slot": "name",
            "slot_set": {"type": "invalid_type", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert str(actual["message"]).__contains__(
        "value is not a valid enumeration member"
    )


def test_add_form():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "num_people", "type": "float"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "num_people",
            "mapping":
                {
                    "type": "from_entity",
                    "intent": ["inform", "request_restaurant"],
                    "entity": "number",
                }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "cuisine", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "cuisine",
            "mapping": {"type": "from_entity", "entity": "cuisine"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "outdoor_seating", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "outdoor_seating",
            "mapping":
                {"type": "from_text", "not_intent": ["affirm"],
                 "conditions": [{"active_loop": "booking", "requested_slot": "outdoor_seating"}]}
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "preferences", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "preferences",
            "mapping":
                {"type": "from_text", "not_intent": ["affirm"],
                 "conditions": [{"active_loop": "booking", "requested_slot": "preferences"}]}
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "feedback", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "feedback",
            "mapping":
                {"type": "from_entity", "entity": "feedback"}
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    path = [
        {
            "ask_questions": ["please give us your name?"],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "current", "value": "Indian Cuisine"},
        },
        {"ask_questions": ["outdoor seating required?"], "slot": "outdoor_seating"},
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
        },
        {
            "ask_questions": ["Please give your feedback on your experience so far"],
            "slot": "feedback",
            "slot_set": {"type": "custom", "value": "Very Nice!"},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form added"


def test_add_slot_mapping_2():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "na", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    assert actual["error_code"] == 0
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "na",
            "mapping": {"type": "from_text", "value": "user", "entity": "na"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_delete_slot_mapping_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/mapping/na",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Slot mapping deleted"


def test_delete_slots_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/na",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot deleted!"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_form_with_any_slot():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "user_feedback", "type": "any"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "user_feedback",
            "mapping":
                {"type": "from_text"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "user_feedback",
            "mapping":
                {"type": "from_entity", "entity": "user_feedback"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    path = [
        {
            "ask_questions": ["please give us your name?"],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "current", "value": "Indian Cuisine"},
        },
        {"ask_questions": ["outdoor seating required?"], "slot": "outdoor_seating"},
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
        },
        {
            "ask_questions": ["Please give your feedback on your experience so far"],
            "slot": "user_feedback",
            "slot_set": {"type": "custom", "value": "Very Nice!"},
        }
    ]
    request = {"name": "restaurant_booking_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "form will not accept any type slots: {'user_feedback'}"


def test_add_utterance_to_form():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_ask_restaurant_form_num_people?form_attached=restaurant_form",
        json={"data": "num people?"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"


def test_delete_utterance_in_form():
    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_ask_restaurant_form_num_people",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]
    assert actual["success"]
    assert actual["error_code"] == 0
    id = actual["data"][0]["_id"]
    response = client.delete(
        f"/api/bot/{pytest.bot}/response/{id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response removed!"


def test_create_rule_with_form_invalid_step():
    steps = [
        {"name": None, "type": "INTENT"},
        {"name": "know_user", "type": "FORM_ACTION"},
        {"name": "know_user", "type": "FORM_START"},
        {"type": "FORM_END"},
        {"name": "utter_submit", "type": "BOT"},
    ]
    story_dict = {
        "name": "activate form",
        "steps": steps,
        "type": "RULE",
        "template_type": "CUSTOM",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json=story_dict,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Only FORM_END step type can have empty name",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422

    steps = [
        {"name": "greet", "type": "INTENT"},
        {"name": "   ", "type": "FORM_ACTION"},
        {"name": "know_user", "type": "FORM_START"},
        {"type": "FORM_END"},
        {"name": "utter_submit", "type": "BOT"},
    ]
    story_dict = {
        "name": "activate form",
        "steps": steps,
        "type": "RULE",
        "template_type": "CUSTOM",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json=story_dict,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "steps"],
            "msg": "Only FORM_END step type can have empty name",
            "type": "value_error",
        }
    ]
    assert not actual["data"]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_create_rule_with_form():
    steps = [
        {"name": "greet", "type": "INTENT"},
        {"name": "know_user", "type": "FORM_ACTION"},
        {"name": "know_user", "type": "FORM_START"},
        {"type": "FORM_END"},
        {"name": "utter_submit", "type": "BOT"},
    ]
    story_dict = {
        "name": "activate form",
        "steps": steps,
        "type": "RULE",
        "template_type": "CUSTOM",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json=story_dict,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0


def test_create_stories_with_form():
    steps = [
        {"name": "greet", "type": "INTENT"},
        {"name": "know_user", "type": "FORM_ACTION"},
        {"name": "know_user", "type": "FORM_START"},
        {"name": "deny", "type": "INTENT"},
        {"name": "utter_ask_continue", "type": "BOT"},
        {"name": "affirm", "type": "INTENT"},
        {"type": "FORM_END"},
        {"name": "utter_submit", "type": "BOT"},
    ]
    story_dict = {
        "name": "stop form - continue",
        "steps": steps,
        "type": "STORY",
        "template_type": "CUSTOM",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json=story_dict,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0


def test_get_form_with_no_validations():
    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form_id = actual["data"][0]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/forms/{form_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form = actual["data"]
    assert len(form["settings"]) == 6
    assert form["settings"][0]["slot"] == "name"
    assert form["settings"][1]["slot"] == "num_people"
    assert form["settings"][2]["slot"] == "cuisine"
    assert form["settings"][3]["slot"] == "outdoor_seating"
    assert form["settings"][4]["slot"] == "preferences"
    assert form["settings"][5]["slot"] == "feedback"
    assert form["settings"][0]["ask_questions"][0]["_id"]
    assert form["settings"][1]["ask_questions"][0]["_id"]
    assert form["settings"][2]["ask_questions"][0]["_id"]
    assert form["settings"][3]["ask_questions"][0]["_id"]
    assert form["settings"][4]["ask_questions"][0]["_id"]
    assert form["settings"][5]["ask_questions"][0]["_id"]
    assert (
            form["settings"][0]["ask_questions"][0]["value"]["text"]
            == "please give us your name?"
    )
    assert form["settings"][1]["ask_questions"][0]["value"]["text"] == "seats required?"
    assert (
            form["settings"][2]["ask_questions"][0]["value"]["text"] == "type of cuisine?"
    )
    assert (
            form["settings"][3]["ask_questions"][0]["value"]["text"]
            == "outdoor seating required?"
    )
    assert (
            form["settings"][4]["ask_questions"][0]["value"]["text"] == "any preferences?"
    )
    assert (
            form["settings"][5]["ask_questions"][0]["value"]["text"]
            == "Please give your feedback on your experience so far"
    )
    assert form["settings"][0]["slot_set"] == {"type": "custom", "value": "Mahesh"}
    assert form["settings"][1]["slot_set"] == {"type": "current", "value": 10}
    assert form["settings"][2]["slot_set"] == {
        "type": "current",
        "value": "Indian Cuisine",
    }
    assert form["settings"][3]["slot_set"] == {"type": "current", "value": None}
    assert form["settings"][4]["slot_set"] == {"type": "slot", "value": "preferences"}
    assert form["settings"][5]["slot_set"] == {"type": "custom", "value": "Very Nice!"}

    response = client.get(
        f"/api/bot/{pytest.bot}/response/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    saved_responses = {response["name"] for response in actual["data"]}
    assert (
            len(
                {
                    "utter_ask_restaurant_form_name",
                    "utter_ask_restaurant_form_num_people",
                    "utter_ask_restaurant_form_cuisine",
                    "utter_ask_restaurant_form_outdoor_seating",
                    "utter_ask_restaurant_form_preferences",
                    "utter_ask_restaurant_form_feedback",
                }.difference(saved_responses)
            )
            == 0
    )
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_form_slot_not_present():
    path = [
        {
            "ask_questions": ["please give us your location?"],
            "slot": "location",
            "slot_set": {"type": "custom", "value": "Bangalore"},
            "mapping": [
                {"type": "from_text", "value": "user", "entity": "name"},
                {"type": "from_entity", "entity": "name"},
            ],
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
            "mapping": [
                {
                    "type": "from_entity",
                    "intent": ["inform", "request_restaurant"],
                    "entity": "number",
                }
            ],
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "current", "value": "Indian Cuisine"},
            "mapping": [{"type": "from_entity", "entity": "cuisine"}],
        },
        {
            "ask_questions": ["outdoor seating required?"],
            "slot": "outdoor_seating",
            "slot_set": {"type": "custom", "value": True},
            "mapping": [
                {"type": "from_entity", "entity": "seating"},
                {"type": "from_intent", "intent": ["affirm"], "value": True},
                {"type": "from_intent", "intent": ["deny"], "value": False},
            ],
        },
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
            "mapping": [
                {"type": "from_text", "not_intent": ["affirm"]},
                {
                    "type": "from_intent",
                    "intent": ["affirm"],
                    "value": "no additional preferences",
                },
            ],
        },
        {
            "ask_questions": ["Please give your feedback on your experience so far"],
            "slot": "feedback",
            "slot_set": {"type": "custom", "value": "Very Nice!"},
            "mapping": [
                {"type": "from_text"},
                {"type": "from_entity", "entity": "feedback"},
            ],
        },
    ]
    request = {"name": "know_user", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"].__contains__("slots not exists: {")


def test_add_form_with_validations():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "age", "type": "float"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "age",
            "mapping":
                {
                    "type": "from_intent",
                    "intent": ["get_age"],
                    "entity": "age",
                    "value": "18",
                }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "location", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "location",
            "mapping": {"type": "from_entity", "entity": "location"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "occupation", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "occupation",
            "mapping":
                {
                    "type": "from_intent",
                    "intent": ["get_occupation"],
                    "entity": "occupation",
                    "value": "business",
                }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "occupation",
            "mapping":
                {"type": "from_text", "entity": "occupation", "value": "engineer"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "occupation",
            "mapping": {"type": "from_entity", "entity": "occupation"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "occupation",
            "mapping":
                {
                    "type": "from_trigger_intent",
                    "entity": "occupation",
                    "value": "tester",
                    "intent": ["get_business", "is_engineer", "is_tester"],
                    "not_intent": ["get_age", "get_name"],
                }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    name_validation = (
        "if (&& name.contains('i') && name.length() > 4 || !name.contains("
        ")) "
        "{return true;} else {return false;}"
    )

    age_validation = "if (age > 10 && age < 70) {return true;} else {return false;}"

    occupation_validation = (
        "if (occupation in ['teacher', 'programmer', 'student', 'manager'] "
        "&& !occupation.contains("
        ") && occupation.length() > 20) "
        "{return true;} else {return false;}"
    )

    path = [
        {
            "ask_questions": ["what is your name?", "name?"],
            "slot": "name",
            "validation_semantic": name_validation,
            "is_required": True,
            "slot_set": {"type": "custom", "value": "Mahesh"},
            "valid_response": "got it",
            "invalid_response": "please rephrase",
        },
        {
            "ask_questions": ["what is your age?", "age?"],
            "slot": "age",
            "validation_semantic": age_validation,
            "is_required": True,
            "slot_set": {"type": "current", "value": 22},
            "valid_response": "valid entry",
            "invalid_response": "please enter again",
        },
        {
            "ask_questions": ["what is your location?", "location?"],
            "slot": "location",
            "slot_set": {"type": "custom", "value": "Bangalore"},
        },
        {
            "ask_questions": ["what is your occupation?", "occupation?"],
            "slot": "occupation",
            "slot_set": {"type": "slot", "value": "occupation"},
            "validation_semantic": occupation_validation,
            "is_required": False,
        },
    ]
    request = {"name": "know_user_form", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form added"


def test_get_form_with_validations():
    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form_id = actual["data"][1]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/forms/{form_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form = actual["data"]
    assert len(form["settings"]) == 4
    assert form["settings"][0]["slot"] == "name"
    assert form["settings"][1]["slot"] == "age"
    assert form["settings"][2]["slot"] == "location"
    assert form["settings"][3]["slot"] == "occupation"
    assert form["settings"][0]["ask_questions"][0]["_id"]
    assert form["settings"][1]["ask_questions"][0]["_id"]
    assert form["settings"][2]["ask_questions"][0]["_id"]
    assert form["settings"][0]["ask_questions"][0]["value"]["text"]
    assert form["settings"][1]["ask_questions"][0]["value"]["text"]
    assert form["settings"][2]["ask_questions"][0]["value"]["text"]
    assert form["settings"][3]["ask_questions"][0]["value"]["text"]
    assert (
            form["settings"][0]["validation_semantic"]
            == "if (&& name.contains('i') && name.length() > 4 || "
               "!name.contains("
               ")) {return true;} else {return false;}"
    )
    assert form["settings"][0]["is_required"]
    assert form["settings"][0]["slot_set"] == {"type": "custom", "value": "Mahesh"}
    assert (
            form["settings"][1]["validation_semantic"]
            == "if (age > 10 && age < 70) {return true;} else {return false;}"
    )
    assert form["settings"][1]["is_required"]
    assert form["settings"][1]["slot_set"] == {"type": "current", "value": 22}
    assert not form["settings"][2]["validation_semantic"]
    assert form["settings"][2]["is_required"]
    assert form["settings"][2]["slot_set"] == {"type": "custom", "value": "Bangalore"}
    assert (
            form["settings"][3]["validation_semantic"]
            == "if (occupation in ['teacher', 'programmer', 'student', 'manager'] "
               "&& !occupation.contains("
               ") && occupation.length() > 20) "
               "{return true;} else {return false;}"
    )
    assert not form["settings"][3]["is_required"]
    assert form["settings"][3]["slot_set"] == {"type": "slot", "value": "occupation"}


def test_edit_form_add_validations():
    name_validation = (
        "if (&& name.contains('i') && name.length() > 4 || "
        "!name.contains("
        ")) {return true;} else {return false;}"
    )
    num_people_validation = (
        "if (num_people > 1 && num_people < 10) {return true;} else {return false;}"
    )
    path = [
        {
            "ask_questions": ["please give us your name?"],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
            "mapping": [
                {"type": "from_text", "value": "user", "entity": "name"},
                {"type": "from_entity", "entity": "name"},
            ],
            "validation_semantic": name_validation,
            "is_required": True,
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "mapping": [
                {
                    "type": "from_entity",
                    "intent": ["inform", "request_restaurant"],
                    "entity": "number",
                }
            ],
            "validation_semantic": num_people_validation,
            "is_required": False,
            "valid_response": "valid value",
            "invalid_response": "invalid value. please enter again",
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "custom", "value": "Indian Cuisine"},
            "mapping": [{"type": "from_entity", "entity": "cuisine"}],
        },
        {
            "ask_questions": ["outdoor seating required?"],
            "slot": "outdoor_seating",
            "mapping": [
                {"type": "from_entity", "entity": "seating"},
                {"type": "from_intent", "intent": ["affirm"], "value": True},
                {"type": "from_intent", "intent": ["deny"], "value": False},
            ],
        },
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
            "mapping": [
                {"type": "from_text", "not_intent": ["affirm"]},
                {
                    "type": "from_intent",
                    "intent": ["affirm"],
                    "value": "no additional preferences",
                },
            ],
        },
        {
            "ask_questions": ["Please give your feedback on your experience so far"],
            "slot": "feedback",
            "slot_set": {"type": "custom", "value": "Very Nice!"},
            "mapping": [
                {"type": "from_text"},
                {"type": "from_entity", "entity": "feedback"},
            ],
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.put(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form updated"


def test_edit_form_remove_validations():
    path = [
        {
            "ask_questions": ["what is your name?", "name?"],
            "slot": "name",
            "valid_response": "got it",
            "slot_set": {"type": "custom", "value": "Mahesh"},
            "invalid_response": "please rephrase",
        },
        {
            "ask_questions": ["what is your age?", "age?"],
            "slot": "age",
            "slot_set": {"type": "current", "value": 22},
            "valid_response": "valid entry",
            "invalid_response": "please enter again",
        },
        {
            "ask_questions": ["what is your location?", "location?"],
            "slot": "location",
            "slot_set": {"type": "custom", "value": "Bangalore"},
        },
        {
            "ask_questions": ["what is your occupation?", "occupation?"],
            "slot": "occupation",
            "slot_set": {"type": "slot", "value": "occupation"},
        },
    ]
    request = {"name": "know_user_form", "settings": path}
    response = client.put(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form updated"


def test_list_form():
    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"][0]["name"] == "restaurant_form"
    assert actual["data"][0]["required_slots"] == [
        "name",
        "num_people",
        "cuisine",
        "outdoor_seating",
        "preferences",
        "feedback",
    ]
    assert actual["data"][1]["name"] == "know_user_form"
    assert actual["data"][1]["required_slots"] == [
        "name",
        "age",
        "location",
        "occupation",
    ]


def test_get_form_after_edit():
    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form_1 = actual["data"][0]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/forms/{form_1}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form = actual["data"]
    assert len(form["settings"]) == 6
    assert form["settings"][0]["slot"] == "name"
    assert form["settings"][1]["slot"] == "num_people"
    assert form["settings"][2]["slot"] == "cuisine"
    assert form["settings"][3]["slot"] == "outdoor_seating"
    assert form["settings"][4]["slot"] == "preferences"
    assert form["settings"][5]["slot"] == "feedback"
    assert form["settings"][0]["ask_questions"][0]["_id"]
    assert form["settings"][1]["ask_questions"][0]["_id"]
    assert form["settings"][2]["ask_questions"][0]["_id"]
    assert form["settings"][3]["ask_questions"][0]["_id"]
    assert form["settings"][4]["ask_questions"][0]["_id"]
    assert form["settings"][5]["ask_questions"][0]["_id"]
    assert (
            form["settings"][0]["ask_questions"][0]["value"]["text"]
            == "please give us your name?"
    )
    assert form["settings"][1]["ask_questions"][0]["value"]["text"] == "seats required?"
    assert (
            form["settings"][2]["ask_questions"][0]["value"]["text"] == "type of cuisine?"
    )
    assert (
            form["settings"][3]["ask_questions"][0]["value"]["text"]
            == "outdoor seating required?"
    )
    assert (
            form["settings"][4]["ask_questions"][0]["value"]["text"] == "any preferences?"
    )
    assert (
            form["settings"][5]["ask_questions"][0]["value"]["text"]
            == "Please give your feedback on your experience so far"
    )
    assert (
            form["settings"][0]["validation_semantic"]
            == "if (&& name.contains('i') && name.length() > 4 || "
               "!name.contains("
               ")) {return true;} else {return false;}"
    )
    assert form["settings"][0]["is_required"]
    assert form["settings"][0]["slot_set"] == {"type": "custom", "value": "Mahesh"}
    assert (
            form["settings"][1]["validation_semantic"]
            == "if (num_people > 1 && num_people < 10) {return true;} else {return false;}"
    )
    assert not form["settings"][1]["is_required"]
    assert form["settings"][1]["slot_set"] == {"type": "current", "value": None}
    assert not form["settings"][2]["validation_semantic"]
    assert form["settings"][2]["slot_set"] == {
        "type": "custom",
        "value": "Indian Cuisine",
    }
    assert not form["settings"][3]["validation_semantic"]
    assert form["settings"][3]["slot_set"] == {"type": "current", "value": None}
    assert not form["settings"][4]["validation_semantic"]
    assert form["settings"][4]["slot_set"] == {"type": "slot", "value": "preferences"}

    response = client.get(
        f"/api/bot/{pytest.bot}/response/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    saved_responses = {response["name"] for response in actual["data"]}
    assert (
            len(
                {
                    "utter_ask_restaurant_form_name",
                    "utter_ask_restaurant_form_num_people",
                    "utter_ask_restaurant_form_cuisine",
                    "utter_ask_restaurant_form_outdoor_seating",
                    "utter_ask_restaurant_form_preferences",
                    "utter_ask_restaurant_form_feedback",
                }.difference(saved_responses)
            )
            == 0
    )
    assert actual["success"]
    assert actual["error_code"] == 0


def test_edit_form():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "ac_required", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "ac_required",
            "mapping": {"type": "from_intent", "intent": ["affirm"], "value": True}
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "ac_required",
            "mapping":
                {"type": "from_intent", "intent": ["deny"], "value": False}
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    path = [
        {
            "ask_questions": ["which location would you prefer?"],
            "slot": "location",
            "slot_set": {"type": "custom", "value": "Bangalore"},
            "mapping": [
                {"type": "from_text", "value": "user", "entity": "location"},
                {"type": "from_entity", "entity": "location"},
            ],
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
            "mapping": [
                {
                    "type": "from_entity",
                    "intent": ["inform", "request_restaurant"],
                    "entity": "number",
                }
            ],
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "custom", "value": "Indian Cuisine"},
            "mapping": [{"type": "from_entity", "entity": "cuisine"}],
        },
        {
            "ask_questions": ["outdoor seating required?"],
            "slot": "outdoor_seating",
            "slot_set": {"type": "custom", "value": True},
            "mapping": [
                {"type": "from_entity", "entity": "seating"},
                {"type": "from_intent", "intent": ["affirm"], "value": True},
                {"type": "from_intent", "intent": ["deny"], "value": False},
            ],
        },
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
            "mapping": [
                {"type": "from_text", "not_intent": ["affirm"]},
                {
                    "type": "from_intent",
                    "intent": ["affirm"],
                    "value": "no additional preferences",
                },
            ],
        },
        {
            "ask_questions": ["do you want to go with an AC room?"],
            "slot": "ac_required",
            "slot_set": {"type": "current", "value": True},
        },
        {
            "ask_questions": ["Please give your feedback on your experience so far"],
            "slot": "feedback",
            "slot_set": {"type": "custom", "value": "Very Nice!"},
            "mapping": [
                {"type": "from_text"},
                {"type": "from_entity", "entity": "feedback"},
            ],
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.put(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form updated"


def test_edit_form_with_any_slot():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "account_required", "type": "any"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "account_required",
            "mapping":
                {"type": "from_intent", "intent": ["affirm"], "value": True},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "account_required",
            "mapping":
                {"type": "from_intent", "intent": ["deny"], "value": False},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]

    path = [
        {
            "ask_questions": ["which location would you prefer?"],
            "slot": "location",
            "slot_set": {"type": "custom", "value": "Bangalore"},
            "mapping": [
                {"type": "from_text", "value": "user", "entity": "location"},
                {"type": "from_entity", "entity": "location"},
            ],
        },
        {
            "ask_questions": ["seats required?"],
            "slot": "num_people",
            "slot_set": {"type": "current", "value": 10},
            "mapping": [
                {
                    "type": "from_entity",
                    "intent": ["inform", "request_restaurant"],
                    "entity": "number",
                }
            ],
        },
        {
            "ask_questions": ["type of cuisine?"],
            "slot": "cuisine",
            "slot_set": {"type": "custom", "value": "Indian Cuisine"},
            "mapping": [{"type": "from_entity", "entity": "cuisine"}],
        },
        {
            "ask_questions": ["outdoor seating required?"],
            "slot": "outdoor_seating",
            "slot_set": {"type": "custom", "value": True},
            "mapping": [
                {"type": "from_entity", "entity": "seating"},
                {"type": "from_intent", "intent": ["affirm"], "value": True},
                {"type": "from_intent", "intent": ["deny"], "value": False},
            ],
        },
        {
            "ask_questions": ["any preferences?"],
            "slot": "preferences",
            "slot_set": {"type": "slot", "value": "preferences"},
            "mapping": [
                {"type": "from_text", "not_intent": ["affirm"]},
                {
                    "type": "from_intent",
                    "intent": ["affirm"],
                    "value": "no additional preferences",
                },
            ],
        },
        {
            "ask_questions": ["do you want to go with an AC room?"],
            "slot": "account_required",
            "slot_set": {"type": "current", "value": True},
        },
    ]
    request = {"name": "restaurant_form", "settings": path}
    response = client.put(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "form will not accept any type slots: {'account_required'}"


def test_edit_slot_mapping():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "cuisine",
            "mapping":
                {"type": "from_intent", "intent": ["order", "menu"], "value": "cuisine"}
            ,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    assert actual["error_code"] == 0
    mapping_id = actual["data"]["id"]
    response = client.put(
        f"/api/bot/{pytest.bot}/slots/mapping/{mapping_id}",
        json={
            "slot": "cuisine",
            "mapping":
                {"type": "from_intent", "intent": ["order", "menu"], "value": "cuisine"}
            ,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping updated"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_get_slot_mapping():
    response = client.get(
        f"/api/bot/{pytest.bot}/slots/mapping",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    for obj in actual['data']:
        for m in obj['mapping']:
            m.pop('_id')

    assert not DeepDiff(
        actual["data"],
        [{'slot': 'ac_required',
          'mapping': [{'type': 'from_intent', 'value': True, 'intent': ['affirm']},
                      {'type': 'from_intent', 'value': False, 'intent': ['deny']}]},
         {'slot': 'account_required',
          'mapping': [{'type': 'from_intent', 'value': True, 'intent': ['affirm']},
                      {'type': 'from_intent', 'value': False, 'intent': ['deny']}]},
         {'slot': 'age', 'mapping': [
             {'type': 'from_intent', 'value': '18', 'intent': ['get_age'], }]},
         {'slot': 'cuisine',
          'mapping': [{'type': 'from_entity', 'entity': 'cuisine'},
                      {'type': 'from_intent', 'value': 'cuisine', 'intent': ['order', 'menu'],
                       }]},
         {'slot': 'feedback', 'mapping': [
             {'type': 'from_entity', 'entity': 'feedback'}]}, {'slot': 'location',
                                                               'mapping': [{
                                                                   'type': 'from_entity',
                                                                   'entity': 'location',
                                                               }]},
         {'slot': 'name', 'mapping': [{'type': 'from_text', 'value': 'user'}]},
         {'slot': 'num_people', 'mapping': [
             {'type': 'from_entity', 'entity': 'number', 'intent': ['inform', 'request_restaurant'],
              }]}, {'slot': 'occupation', 'mapping': [
            {'type': 'from_intent', 'value': 'business', 'intent': ['get_occupation'],
             },
            {'type': 'from_text', 'value': 'engineer'},
            {'type': 'from_entity', 'entity': 'occupation'},
            {'type': 'from_trigger_intent', 'value': 'tester', 'intent': ['get_business', 'is_engineer', 'is_tester'],
             'not_intent': ['get_age', 'get_name']}]},
         {'slot': 'outdoor_seating',
          'mapping': [
              {'type': 'from_text',
               'not_intent': [
                   'affirm'],
               'conditions': [{
                   'active_loop': 'booking',
                   'requested_slot': 'outdoor_seating'}],
               }]},
         {'slot': 'preferences', 'mapping': [{'type': 'from_text', 'not_intent': ['affirm'], 'conditions': [
             {'active_loop': 'booking', 'requested_slot': 'preferences'}]}]},
         {'slot': 'user_feedback', 'mapping': [{'type': 'from_text'},
                                               {'type': 'from_entity', 'entity': 'user_feedback',
                                                }]}]
        ,
        ignore_order=True,
    )

    response = client.get(
        f"/api/bot/{pytest.bot}/slots/mapping?form=booking",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    for obj in actual['data']:
        for m in obj['mapping']:
            m.pop('_id')
    assert actual["success"]
    assert actual["data"] == [{'slot': 'outdoor_seating', 'mapping': [{'type': 'from_text', 'not_intent': ['affirm'],
                                                                       'conditions': [{'active_loop': 'booking',
                                                                                       'requested_slot': 'outdoor_seating'}]}]},
                              {'slot': 'preferences', 'mapping': [{'type': 'from_text', 'not_intent': ['affirm'],
                                                                   'conditions': [{'active_loop': 'booking',
                                                                                   'requested_slot': 'preferences'}]}]}]

    assert actual["error_code"] == 0


def test_delete_form():
    response = client.delete(
        f"/api/bot/{pytest.bot}/forms/restaurant_form",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form deleted"


def test_delete_form_already_deleted():
    response = client.delete(
        f"/api/bot/{pytest.bot}/forms/restaurant_form",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Form "restaurant_form" does not exists'


def test_delete_form_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/forms/form_not_exists",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Form "form_not_exists" does not exists'


def test_delete_slot_mapping():
    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/mapping/ac_required",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Slot mapping deleted"


def test_delete_slot_mapping_non_existing():
    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/mapping/ac_required",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "No slot mapping exists for slot: ac_required"


def test_add_slot_set_action():
    request = {
        "name": "action_set_name_slot",
        "set_slots": [
            {"name": "name", "type": "from_value", "value": 5},
            {"name": "age", "type": "reset_slot"},
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/slotset",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


def test_add_slot_set_action_slot_not_exists():
    request = {
        "name": "action_set_new_user_slot",
        "set_slots": [{"name": "new_user", "type": "from_value", "value": False}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/slotset",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Slot with name "new_user" not found'


def test_list_slot_set_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/slotset",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1
    actual["data"][0].pop("_id")
    assert actual["data"][0] == {
        "name": "action_set_name_slot",
        "set_slots": [
            {"name": "name", "type": "from_value", "value": 5},
            {"name": "age", "type": "reset_slot"},
        ],
    }


def test_edit_slot_set_action():
    request = {
        "name": "action_set_name_slot",
        "set_slots": [{"name": "name", "type": "from_value", "value": "age"}],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/slotset",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


def test_edit_slot_set_action_slot_not_exists():
    request = {
        "name": "action_set_name_slot",
        "set_slots": [{"name": "non_existant", "type": "from_value", "value": "age"}],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/slotset",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Slot with name "non_existant" not found'


def test_delete_slot_set_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/non_existant",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "non_existant" not found'


def test_delete_slot_set_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/action_set_name_slot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_list_slot_set_action_none_present():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/slotset",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_add_intent_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "CASE_INSENSITIVE_INTENT"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Intent added successfully!"

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    intents_added = [i["name"] for i in actual["data"]]
    assert "CASE_INSENSITIVE_INTENT" not in intents_added
    assert "case_insensitive_intent" in intents_added
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/CASE_INSENSITIVE_INTENT",
        json={"data": ["IS THIS CASE_INSENSITIVE_INTENT?"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"][0]["message"] == "Training Example added"

    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/case_insensitive_intent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    training_examples = [t["text"] for t in actual["data"]]
    assert "IS THIS CASE_INSENSITIVE_INTENT?" in training_examples
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_training_example_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/training_examples/CASE_INSENSITIVE_TRAINING_EX_INTENT",
        json={"data": ["IS THIS CASE_INSENSITIVE_TRAINING_EX_INTENT?"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"][0]["message"] == "Training Example added"

    response = client.get(
        f"/api/bot/{pytest.bot}/training_examples/case_insensitive_training_ex_intent",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "IS THIS CASE_INSENSITIVE_TRAINING_EX_INTENT?" in [
        t["text"] for t in actual["data"]
    ]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_utterances_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/utterance",
        json={"data": "utter_CASE_INSENSITIVE_UTTERANCE"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Utterance added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/utterance",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    utterances_added = [u["name"] for u in actual["data"]["utterances"]]
    assert "utter_CASE_INSENSITIVE_UTTERANCE" not in utterances_added
    assert "utter_case_insensitive_utterance" in utterances_added


def test_add_responses_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/response/utter_CASE_INSENSITIVE_RESPONSE",
        json={"data": "yes, this is utter_CASE_INSENSITIVE_RESPONSE"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Response added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_CASE_INSENSITIVE_RESPONSE",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"][0]["value"] == {
        "text": "yes, this is utter_CASE_INSENSITIVE_RESPONSE"
    }

    response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_case_insensitive_response",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1


def test_add_story_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "CASE_INSENSITIVE_STORY",
            "type": "STORY",
            "template_type": "Q&A",
            "steps": [
                {"name": "case_insensitive_training_ex_intent", "type": "INTENT"},
                {"name": "utter_case_insensitive_response", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.story_id = actual["data"]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])
    stories_added = [s["name"] for s in actual["data"]]
    assert "CASE_INSENSITIVE_STORY" not in stories_added
    assert "case_insensitive_story" in stories_added

    response = client.delete(
        f"/api/bot/{pytest.bot}/stories/{pytest.story_id}/STORY",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Flow deleted successfully"


def test_add_rule_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/stories",
        json={
            "name": "CASE_INSENSITIVE_RULE",
            "type": "RULE",
            "steps": [
                {"name": "case_insensitive_training_ex_intent", "type": "INTENT"},
                {"name": "utter_case_insensitive_response", "type": "BOT"},
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Flow added successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/stories",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert Utility.check_empty_string(actual["message"])
    stories_added = [s["name"] for s in actual["data"]]
    assert "CASE_INSENSITIVE_RULE" not in stories_added
    assert "case_insensitive_rule" in stories_added


def test_add_regex_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/regex",
        json={"name": "CASE_INSENSITIVE_REGEX", "pattern": "b*b"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Regex pattern added successfully!"

    response = client.get(
        f"/api/bot/{pytest.bot}/regex",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert Utility.check_empty_string(actual["message"])
    assert "CASE_INSENSITIVE_REGEX" != actual["data"][0]["name"]
    assert "case_insensitive_regex" == actual["data"][0]["name"]


def test_add_lookup_single_value():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup",
        json={"data": "single_value"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup added!"

    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/single_value/value",
        json={"data": "test"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup value added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/single_value/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 1
    assert all(
        key in item.keys()
        for item in actual["data"]
        for key in ["_id", "value", "lookup"]
    )


def test_add_lookup_table_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/lookup",
        json={"data": "CASE_INSENSITIVE_LOOKUP"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup added!"

    response = client.post(
        f"/api/bot/{pytest.bot}/lookup/CASE_INSENSITIVE_LOOKUP/values",
        json={"value": ["test1", "test2"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Lookup values added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/lookup/CASE_INSENSITIVE_LOOKUP/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert len(actual["data"]) == 2
    assert any("case_insensitive_lookup" == item["lookup"] for item in actual["data"])

    response = client.get(
        f"/api/bot/{pytest.bot}/lookups",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert any("case_insensitive_lookup" == item["lookup"] for item in actual["data"])


def test_add_entity_synonym_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym",
        json={"data": "CASE_INSENSITIVE"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym added!"

    response = client.post(
        f"/api/bot/{pytest.bot}/entity/synonym/CASE_INSENSITIVE/values",
        json={"value": ["CASE_INSENSITIVE_SYNONYM"]},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Synonym values added!"

    response = client.get(
        f"/api/bot/{pytest.bot}/entity/synonym/case_insensitive/values",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert any(
        item["value"] == "CASE_INSENSITIVE_SYNONYM"
        and item["synonym"] == "case_insensitive"
        for item in actual["data"]
    )


def test_add_slot_case_insensitivity():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={
            "name": "CASE_INSENSITIVE_SLOT",
            "type": "any",
            "initial_value": "bot",
            "influence_conversation": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert "data" in actual
    assert actual["message"] == "Slot added successfully!"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/slots",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert "data" in actual
    assert len(actual["data"])
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_form_case_insensitivity():
    path = [
        {
            "ask_questions": ["please give us your name?"],
            "slot": "name",
            "slot_set": {"type": "custom", "value": "Mahesh"},
            "mapping": [
                {"type": "from_text", "value": "user", "entity": "name"},
                {"type": "from_entity", "entity": "name"},
            ],
        },
    ]
    request = {"name": "CASE_INSENSITIVE_FORM", "settings": path}
    response = client.post(
        f"/api/bot/{pytest.bot}/forms",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Form added"

    response = client.get(
        f"/api/bot/{pytest.bot}/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    form_1 = actual["data"][1]["_id"]

    response = client.get(
        f"/api/bot/{pytest.bot}/forms/{form_1}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["name"] == "case_insensitive_form"


def test_add_slot_set_action_case_insensitivity():
    request = {
        "name": "CASE_INSENSITIVE_SLOT_SET_ACTION",
        "set_slots": [{"name": "name", "type": "from_value", "value": 5}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/slotset",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"

    response = client.get(
        f"/api/bot/{pytest.bot}/action/slotset",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1
    actual["data"][0].pop("_id")
    assert actual["data"][0] == {
        "name": "case_insensitive_slot_set_action",
        "set_slots": [{"name": "name", "type": "from_value", "value": 5}],
    }


def test_add_http_action_case_insensitivity():
    request_body = {
        "action_name": "CASE_INSENSITIVE_HTTP_ACTION",
        "response": {"value": "string"},
        "http_url": "http://www.google.com",
        "request_method": "GET",
        "params_list": [
            {"key": "testParam1", "parameter_type": "value", "value": "testValue1"}
        ],
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/httpaction",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/CASE_INSENSITIVE_HTTP_ACTION",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["data"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/httpaction/case_insensitive_http_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["success"]


def test_add_slot_mapping_1():
    response = client.post(
        f"/api/bot/{pytest.bot}/slots",
        json={"name": "name_slot", "type": "text"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["message"] == "Slot added successfully!"
    assert actual["success"]
    assert actual["error_code"] == 0
    response = client.post(
        f"/api/bot/{pytest.bot}/slots/mapping",
        json={
            "slot": "name_slot",
            "mapping": {"type": "from_text", "value": "user", "entity": "name_slot"},
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Slot mapping added"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_delete_slot_mapping_1():
    response = client.get(
        f"/api/bot/{pytest.bot}/slots/mapping",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    for slot_mapping in actual["data"]:
        if slot_mapping['slot'] == "name_slot":
            mapping_id = slot_mapping['mapping'][0]['_id']
            break
    assert len(actual["data"]) == 12

    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/mapping_id/{mapping_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["message"] == "Slot mapping deleted"
    assert actual["error_code"] == 0
    assert not actual["data"]

    response = client.get(
        f"/api/bot/{pytest.bot}/slots/mapping",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 11


def test_delete_slot_mapping_does_not_exist():
    response = client.delete(
        f"/api/bot/{pytest.bot}/slots/mapping_id/{pytest.bot}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert not actual["data"]
    assert actual["message"] == 'No slot mapping exists'
    assert actual["error_code"] == 422


def test_get_ui_config_empty():
    response = client.get(
        url=f"/api/account/config/ui",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"] == {}
    assert actual["success"]


def test_add_ui_config():
    response = client.put(
        url=f"/api/account/config/ui",
        json={"data": {"has_stepper": True, "has_tour": False, "theme": "white"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["success"]
    assert actual["message"] == "Config saved!"

    response = client.put(
        url=f"/api/account/config/ui",
        json={"data": {"has_stepper": True, "has_tour": False, "theme": "black"}},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["success"]
    assert actual["message"] == "Config saved!"


def test_get_ui_config():
    response = client.get(
        url=f"/api/account/config/ui",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["data"] == {"has_stepper": True, "has_tour": False, "theme": "black"}
    assert actual["success"]


def test_sso_redirect_url_invalid_type():
    response = client.get(url=f"/api/auth/login/sso/ethereum")
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "ethereum login is not supported"
    assert not actual["success"]


def test_list_sso_not_enabled(monkeypatch):
    monkeypatch.setitem(Utility.environment["app"], "enable_sso_only", True)
    response = client.get(url=f"/api/system/properties", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"] == {
        "sso": {"facebook": False, "linkedin": False, "google": False},
        "enable_sso_only": True,
        "validate_trusted_device": False,
        "enable_apm": False,
        "enable_notifications": False,
        "validate_recaptcha": False,
        "enable_multilingual": False,
        "properties": {"bot": {"enable_onboarding": True}},
    }


def test_sso_redirect_url_not_enabled():
    response = client.get(url=f"/api/auth/login/sso/google", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "google login is not enabled"
    assert not actual["success"]

    response = client.get(url=f"/api/auth/login/sso/linkedin", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "linkedin login is not enabled"
    assert not actual["success"]

    response = client.get(url=f"/api/auth/login/sso/facebook", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "facebook login is not enabled"
    assert not actual["success"]


def test_sso_redirect_url(monkeypatch):
    discovery_url = (
        "https://accounts.google.com/o/oauth2/v2/auth?response_type=code&client_id="
    )

    async def _mock_get_discovery_doc(*args, **kwargs):
        return {"authorization_endpoint": discovery_url}

    Utility.environment["sso"]["linkedin"]["enable"] = True
    Utility.environment["sso"]["google"]["enable"] = True
    Utility.environment["sso"]["facebook"]["enable"] = True
    monkeypatch.setattr(GoogleSSO, "get_discovery_document", _mock_get_discovery_doc)

    response = client.get(url=f"/api/auth/login/sso/google", allow_redirects=False)
    assert response.status_code == 303
    assert response.headers["location"].__contains__(discovery_url)

    response = client.get(url=f"/api/auth/login/sso/linkedin", allow_redirects=False)
    assert response.status_code == 303
    assert response.headers["location"].__contains__(
        "https://www.linkedin.com/oauth/v2/authorization?response_type=code&client_id="
    )

    response = client.get(url=f"/api/auth/login/sso/facebook", allow_redirects=False)
    assert response.status_code == 303
    assert response.headers["location"].__contains__(
        "https://www.facebook.com/v9.0/dialog/oauth?response_type=code&client_id="
    )


def test_list_sso_enabled():
    Utility.environment["sso"]["linkedin"]["enable"] = True
    Utility.environment["sso"]["google"]["enable"] = True

    response = client.get(url=f"/api/system/properties", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert actual["data"] == {
        "sso": {"facebook": False, "linkedin": True, "google": True},
        "enable_apm": False,
        "enable_notifications": False,
        "validate_recaptcha": False,
        "enable_sso_only": False,
        "validate_trusted_device": False,
        "enable_multilingual": False,
        "properties": {"bot": {"enable_onboarding": True}},
    }


def test_sso_get_login_token_invalid_type():
    response = client.get(url=f"/api/auth/login/sso/callback/ethereum")
    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == "ethereum login is not supported"
    assert not actual["success"]


def test_sso_get_login_token(monkeypatch):
    token = "fgyduhsaifusijfisofwh87eyfhw98yqwhfc8wufchwufehwncj"

    async def __mock_verify_and_process(*args, **kwargs):
        return (
            False,
            {
                "email": "new_user@digite.com",
                "first_name": "new",
                "password": SecretStr("123456789"),
            },
            token,
        )

    monkeypatch.setattr(Authentication, "verify_and_process", __mock_verify_and_process)
    response = client.get(
        url=f"/api/auth/login/sso/callback/google?code=123456789", allow_redirects=False
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0
    values = list(AuditLogData.objects(user="new_user@digite.com", action='activity', entity='social_login').order_by(
        "-timestamp"))
    audit_log_data = values[0].to_mongo().to_dict()
    assert audit_log_data['user'] == 'new_user@digite.com'
    assert audit_log_data["attributes"] == [{'key': 'email', 'value': 'new_user@digite.com'}]
    assert audit_log_data["action"] == 'activity'
    assert audit_log_data['entity'] == 'social_login'
    assert audit_log_data['data']['username'] == 'new_user@digite.com'
    assert audit_log_data['data']['sso_type'] == 'google'

    response = client.get(
        url=f"/api/auth/login/sso/callback/linkedin?code=123456789",
        allow_redirects=False,
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0
    values = list(AuditLogData.objects(user="new_user@digite.com", action='activity', entity='social_login').order_by(
        "-timestamp"))
    audit_log_data = values[0].to_mongo().to_dict()
    assert audit_log_data['user'] == 'new_user@digite.com'
    assert audit_log_data["attributes"] == [{'key': 'email', 'value': 'new_user@digite.com'}]
    assert audit_log_data["action"] == 'activity'
    assert audit_log_data['entity'] == 'social_login'
    assert audit_log_data['data']['username'] == 'new_user@digite.com'
    assert audit_log_data['data']['sso_type'] == 'linkedin'

    response = client.get(
        url=f"/api/auth/login/sso/callback/facebook?code=123456789",
        allow_redirects=False,
    )
    actual = response.json()
    assert all(
        [
            True if actual["data"][key] else False
            for key in ["access_token", "token_type"]
        ]
    )
    assert actual["success"]
    assert actual["error_code"] == 0
    values = list(AuditLogData.objects(user="new_user@digite.com", action='activity', entity='social_login').order_by(
        "-timestamp"))
    audit_log_data = values[0].to_mongo().to_dict()
    assert audit_log_data['user'] == 'new_user@digite.com'
    assert audit_log_data["attributes"] == [{'key': 'email', 'value': 'new_user@digite.com'}]
    assert audit_log_data["action"] == 'activity'
    assert audit_log_data['entity'] == 'social_login'
    assert audit_log_data['data']['username'] == 'new_user@digite.com'
    assert audit_log_data['data']['sso_type'] == 'facebook'


def test_trigger_mail_on_new_signup_with_sso(monkeypatch):
    token = "fgyduhsaifusijfisofwh87eyfhw98yqwhfc8wufchwufehwncj"

    async def __mock_verify_and_process(*args, **kwargs):
        return (
            False,
            {
                "email": "new_user@digite.com",
                "first_name": "new",
                "password": SecretStr("123456789"),
            },
            token,
        )

    monkeypatch.setattr(Authentication, "verify_and_process", __mock_verify_and_process)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    Utility.email_conf["email"]["enable"] = True
    response = client.get(
        url=f"/api/auth/login/sso/callback/google?code=123456789", allow_redirects=False
    )
    actual = response.json()
    Utility.email_conf["email"]["enable"] = False
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not Utility.check_empty_string(actual["message"])
    actual = response.json()
    assert actual["data"]["access_token"] == token
    assert actual["data"]["token_type"] == "bearer"


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_add_email_action(mock_smtp):
    request = {
        "action_name": "email_config",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test"},
        "from_email": {"value": "from_email", "parameter_type": "slot"},
        "to_email": {"value": ["test@test.com", "test1@test.com"], "parameter_type": "value"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_add_email_action_from_different_parameter_type(mock_smtp):
    request = {
        "action_name": "email_config_with_slot",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test", "parameter_type": "slot"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"

    request = {
        "action_name": "email_config_with_key_vault",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test", "parameter_type": "key_vault"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_add_email_action_from_invalid_parameter_type(mock_smtp):
    request = {
        "action_name": "email_config_invalid_parameter_type",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test", "parameter_type": "intent"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {
        "action_name": "email_config_invalid_parameter_type",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "", "parameter_type": "slot"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {
        "action_name": "email_config_invalid_parameter_type",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "", "parameter_type": "key_vault"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_add_email_action_from_invalid_parameter_type_1(mock_smtp):
    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "to_email", "parameter_type": "intent"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "", "parameter_type": "slot"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'to_email', '__root__'],
                                  'msg': 'Provide name of the slot as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide name of the slot as value")

    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "key_vault"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "", "parameter_type": "value"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'to_email', '__root__'],
                                  'msg': 'Provide list of emails as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide list of emails as value")

    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "intent"},
               "to_email": {"value": "to_email", "parameter_type": "slot"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "", "parameter_type": "slot"},
               "to_email": {"value": ["test@demo.com"], "parameter_type": "value"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'from_email', '__root__'],
                                  'msg': 'Provide name of the slot as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide name of the slot as value")

    request = {"action_name": "email_config_invalid_parameter_type",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "key_vault"},
               "from_email": {"value": "", "parameter_type": "value"},
               "to_email": {"value": ["test@demo.com"], "parameter_type": "value"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Invalid From or To email address'


def test_list_email_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/email",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 3
    [action.pop("_id") for action in actual["data"]]
    assert actual["data"] == [
        {
            "action_name": "email_config",
            "smtp_url": "test.test.com",
            "smtp_port": 25,
            'dispatch_bot_response': True,
            "smtp_password": {
                "_cls": "CustomActionRequestParameters",
                "key": "smtp_password",
                "encrypt": False,
                "value": "test",
                "parameter_type": "value",
            },
           'from_email': {'_cls': 'CustomActionRequestParameters', 'encrypt': False,
                          'value': 'from_email', 'parameter_type': 'slot'},
           'subject': 'Test Subject',
           'to_email': {'_cls': 'CustomActionParameters', 'encrypt': False,
                        'value': ['test@test.com', 'test1@test.com'], 'parameter_type': 'value'},
           'response': 'Test Response',
            'tls': False
        },
        {
            "action_name": "email_config_with_slot",
            "smtp_url": "test.test.com",
            "smtp_port": 25,
            'dispatch_bot_response': True,
            "smtp_password": {
                "_cls": "CustomActionRequestParameters",
                "key": "smtp_password",
                "encrypt": False,
                "value": "test",
                "parameter_type": "slot",
            },
           'from_email': {'_cls': 'CustomActionRequestParameters', 'encrypt': False,
                          'value': 'test@demo.com', 'parameter_type': 'value'},
           'subject': 'Test Subject',
           'to_email': {'_cls': 'CustomActionParameters', 'encrypt': False, 'value': 'to_email',
                        'parameter_type': 'slot'},
            'response': 'Test Response',
            "tls": False,
        },
        {
            "action_name": "email_config_with_key_vault",
            "smtp_url": "test.test.com",
            "smtp_port": 25,
            'dispatch_bot_response': True,
            "smtp_password": {
                "_cls": "CustomActionRequestParameters",
                "key": "smtp_password",
                "encrypt": False,
                "value": "test",
                "parameter_type": "key_vault",
            },
            'from_email': {'_cls': 'CustomActionRequestParameters', 'encrypt': False,
                           'value': 'test@demo.com', 'parameter_type': 'value'},
            'subject': 'Test Subject',
            'to_email': {'_cls': 'CustomActionParameters', 'encrypt': False, 'value': 'to_email',
                         'parameter_type': 'slot'},
            'response': 'Test Response',
            "tls": False,
        },
    ]


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_edit_email_action(mock_smtp):
    request = {
        "action_name": "email_config",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_edit_email_action_different_parameter_type(mock_smtp):
    request = {
        "action_name": "email_config_with_slot",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test", "parameter_type": "slot"},
        "from_email": {"value": "from_email", "parameter_type": "slot"},
        "to_email": {"value": ["test@test.com", "test1@test.com"], "parameter_type": "value"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"

    request = {
        "action_name": "email_config_with_key_vault",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test", "parameter_type": "key_vault"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_edit_email_action_invalid_parameter_type(mock_smtp):
    request = {
        "action_name": "email_config_with_slot",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {'value': "test", "parameter_type": "slot"},
        "from_email": {"value": "test@demo.com", "parameter_type": "intent"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_edit_email_action_invalid_parameter_type_1(mock_smtp):
    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "to_email", "parameter_type": "intent"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "", "parameter_type": "slot"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'to_email', '__root__'],
                                  'msg': 'Provide name of the slot as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide name of the slot as value")

    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "key_vault"},
               "from_email": {"value": "test@demo.com", "parameter_type": "value"},
               "to_email": {"value": "test@demo.com", "parameter_type": "value"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'to_email', '__root__'],
                                  'msg': 'Provide list of emails as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide list of emails as value")

    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "test@demo.com", "parameter_type": "intent"},
               "to_email": {"value": "to_email", "parameter_type": "slot"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422

    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "slot"},
               "from_email": {"value": "", "parameter_type": "slot"},
               "to_email": {"value": ["test@demo.com"], "parameter_type": "value"},
               "subject": "Test Subject",
               "response": "Test Response",
               "tls": False
               }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'from_email', '__root__'],
                                  'msg': 'Provide name of the slot as value', 'type': 'value_error'}]
    assert str(actual['message']).__contains__("Provide name of the slot as value")

    request = {"action_name": "email_config_with_slot",
               "smtp_url": "test.test.com",
               "smtp_port": 25,
               "smtp_userid": None,
               "smtp_password": {'value': "test", "parameter_type": "key_vault"},
               "from_email": {"value": "", "parameter_type": "value"},
               "to_email": {"value": ["test@demo.com"], "parameter_type": "value"},
               "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Invalid From or To email address'


@patch("kairon.shared.utils.SMTP", autospec=True)
def test_edit_email_action_does_not_exists(mock_smtp):
    request = {
        "action_name": "email_config1",
        "smtp_url": "test.test.com",
        "smtp_port": 25,
        "smtp_userid": None,
        "smtp_password": {"value": "test"},
        "from_email": {"value": "test@demo.com", "parameter_type": "value"},
        "to_email": {"value": "to_email", "parameter_type": "slot"},
        "subject": "Test Subject",
        "response": "Test Response",
        "tls": False,
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/email",
        json=request,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "email_config1" not found'


def test_delete_email_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/non_existant",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "non_existant" not found'


def test_delete_email_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/email_config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_list_google_search_action_one():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1


def test_add_google_search_action():
    action = {
        "name": "google_custom_search",
        "api_key": {"value": "12345678"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
        "website": "https://www.google.com",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


def test_add_google_search_exists():
    action = {
        "name": "google_custom_search",
        "api_key": {"value": "12345678"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"


def test_add_google_search_invalid_parameters():
    action = {
        "name": "google_custom_search",
        "api_key": {"value": "12345678"},
        "search_engine_id": "asdfg:123456",
        "num_results": 0,
        "failure_response": "I have failed to process your request",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "num_results"],
            "msg": "num_results must be greater than or equal to 1!",
            "type": "value_error",
        }
    ]


def test_add_google_search_different_parameter_types():
    action = {
        "name": "google_custom_search_slot",
        "api_key": {"value": "12345678", "parameter_type": "slot"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"

    action = {
        "name": "google_custom_search_key_vault",
        "api_key": {"value": "12345678", "parameter_type": "key_vault"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


def test_add_google_search_invalid_parameter_types():
    action = {
        "name": "google_custom_search_slot",
        "api_key": {"value": "12345678", "parameter_type": "chat_log"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_edit_google_search_action_not_exists():
    action = {
        "name": "custom_search",
        "api_key": {"value": "12345678"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"] == 'Google search action with name "custom_search" not found'
    )


def test_edit_google_search_action():
    action = {
        "name": "google_custom_search",
        "api_key": {"value": "1234567889"},
        "search_engine_id": "asdfg:12345689",
        "failure_response": "Failed to perform search",
        "website": "https://nimblework.com",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


def test_edit_google_search_action_different_parameter_types():
    action = {
        "name": "google_custom_search_slot",
        "api_key": {"value": "1234567889", "parameter_type": "key_vault"},
        "search_engine_id": "asdfg:12345689",
        "failure_response": "Failed to perform search",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"

    action = {
        "name": "google_custom_search_key_vault",
        "api_key": {"value": "1234567889", "parameter_type": "slot"},
        "search_engine_id": "asdfg:12345689",
        "failure_response": "Failed to perform search",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


def test_edit_google_search_action_invalid_parameter_type():
    action = {
        "name": "google_custom_search_key_vault",
        "api_key": {"value": "12345678", "parameter_type": "user_message"},
        "search_engine_id": "asdfg:123456",
        "failure_response": "I have failed to process your request",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_list_google_search_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/googlesearch",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 4
    actual["data"][0].pop("_id")
    assert actual["data"][1]["name"] == "google_custom_search"
    assert actual["data"][1]["api_key"] == {
        "_cls": "CustomActionRequestParameters",
        "encrypt": False,
        "key": "api_key",
        "parameter_type": "value",
        "value": "1234567889",
    }
    assert actual["data"][1]["search_engine_id"] == "asdfg:12345689"
    assert actual["data"][1]["failure_response"] == "Failed to perform search"
    assert actual["data"][1]["website"] == "https://nimblework.com"
    assert actual["data"][1]["num_results"] == 1
    assert actual["data"][1]["dispatch_response"]
    assert not actual["data"][1].get("set_slot")


def test_delete_google_search_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/google_custom_search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_delete_google_search_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/google_custom_search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "google_custom_search" not found'


def test_add_web_search_action():
    action = {
        "name": "public_custom_search",
        "dispatch_response": False,
        "set_slot": "public_search_result",
        "failure_response": "I have failed to process your request",
        "website": "https://www.google.com",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


def test_add_web_search_exists():
    action = {
        "name": "public_custom_search",
        "dispatch_response": False,
        "set_slot": "public_search_result",
        "failure_response": "I have failed to process your request",
        "website": "https://www.google.com",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"


def test_add_web_search_invalid_parameters_top_n():
    action = {
        "name": "public_custom_search_two",
        "topn": 0,
        "dispatch_response": False,
        "set_slot": "public_search_result",
        "failure_response": "I have failed to process your request",
        "website": "https://www.google.com",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "topn"],
            "msg": "topn must be greater than or equal to 1!",
            "type": "value_error",
        }
    ]


def test_add_web_search_invalid_parameters_name():
    action = {
        "name": "",
        "topn": 1,
        "dispatch_response": False,
        "set_slot": "public_search_result",
        "failure_response": "I have failed to process your request",
        "website": "https://www.google.com",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "name"], "msg": "name is required", "type": "value_error"}
    ]


def test_edit_web_search_action_not_exists():
    action = {
        "name": "custom_search",
        "failure_response": "I have failed to process your request",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"] == 'Public search action with name "custom_search" not found'
    )


def test_edit_web_search_action():
    action = {
        "name": "public_custom_search",
        "dispatch_response": False,
        "set_slot": "public_search_result",
        "failure_response": "Failed to perform public search",
        "website": "https://nimblework.com",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/websearch",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


def test_list_web_search_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/websearch",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1
    actual["data"][0].pop("_id")
    assert actual["data"][0]["name"] == "public_custom_search"
    assert actual["data"][0]["failure_response"] == "Failed to perform public search"
    assert actual["data"][0]["website"] == "https://nimblework.com"
    assert actual["data"][0]["topn"] == 1
    assert not actual["data"][0]["dispatch_response"]
    assert actual["data"][0].get("set_slot")


def test_delete_web_search_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/public_custom_search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_delete_web_search_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/public_custom_search",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "public_custom_search" not found'


def test_list_hubspot_forms_action_no_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 0


def test_add_hubspot_forms_action():
    action = {
        "name": "action_hubspot_forms",
        "portal_id": "12345678",
        "form_guid": "asdfg:123456",
        "fields": [
            {"key": "email", "value": "email_slot", "parameter_type": "slot"},
            {"key": "firstname", "value": "firstname_slot", "parameter_type": "slot"},
        ],
        "response": "Form submitted",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


def test_add_hubspot_forms_action_invalid_param_type():
    action = {
        "name": "action_hubspot_forms",
        "portal_id": "12345678",
        "form_guid": "asdfg:123456",
        "fields": [
            {"key": "email", "value": "email_slot", "parameter_type": "header"},
            {"key": "firstname", "value": "firstname_slot", "parameter_type": "slot"},
        ],
        "response": "Form submitted",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'fields', 0, 'parameter_type'],
                                  'msg': "value is not a valid enumeration member; permitted: 'value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log', 'key_vault'",
                                  'type': 'type_error.enum', 'ctx': {
            'enum_values': ['value', 'slot', 'sender_id', 'user_message', 'latest_message', 'intent', 'chat_log',
                            'key_vault']}}]


def test_add_hubspot_forms_exists():
    action = {
        "name": "action_hubspot_forms",
        "portal_id": "12345678",
        "form_guid": "asdfg:123456",
        "fields": [
            {"key": "email", "value": "email_slot", "parameter_type": "slot"},
            {"key": "firstname", "value": "firstname_slot", "parameter_type": "slot"},
        ],
        "response": "Form submitted",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"


def test_edit_hubspot_forms_action_not_exists():
    action = {
        "name": "hubspot_forms_action",
        "portal_id": "12345678",
        "form_guid": "asdfg:123456",
        "fields": [
            {"key": "email", "value": "email_slot", "parameter_type": "slot"},
            {"key": "firstname", "value": "firstname_slot", "parameter_type": "slot"},
        ],
        "response": "Form submitted",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "hubspot_forms_action" not found'


def test_edit_hubspot_forms_action():
    action = {
        "name": "action_hubspot_forms",
        "portal_id": "123456785787",
        "form_guid": "asdfg:12345678787",
        "fields": [
            {"key": "email", "value": "email_slot", "parameter_type": "slot"},
            {"key": "fullname", "value": "fullname_slot", "parameter_type": "slot"},
            {"key": "company", "value": "digite", "parameter_type": "value"},
            {"key": "phone", "value": "phone_slot", "parameter_type": "slot"},
        ],
        "response": "Hubspot Form submitted",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


def test_list_hubspot_forms_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/hubspot/forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 1
    actual["data"][0].pop("_id")
    assert actual["data"][0]["name"] == "action_hubspot_forms"
    assert actual["data"][0]["portal_id"] == "123456785787"
    assert actual["data"][0]["form_guid"] == "asdfg:12345678787"
    assert actual["data"][0]["fields"] == [
        {
            "_cls": "HttpActionRequestBody",
            "key": "email",
            "value": "email_slot",
            "parameter_type": "slot",
            "encrypt": False,
        },
        {
            "_cls": "HttpActionRequestBody",
            "key": "fullname",
            "value": "fullname_slot",
            "parameter_type": "slot",
            "encrypt": False,
        },
        {
            "_cls": "HttpActionRequestBody",
            "key": "company",
            "value": "digite",
            "parameter_type": "value",
            "encrypt": False,
        },
        {
            "_cls": "HttpActionRequestBody",
            "key": "phone",
            "value": "phone_slot",
            "parameter_type": "slot",
            "encrypt": False,
        },
    ]
    assert actual["data"][0]["response"] == "Hubspot Form submitted"


def test_delete_hubspot_forms_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/action_hubspot_forms",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_get_kairon_two_stage_fallback_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []
    assert not actual["message"]


def test_add_kairon_two_stage_fallback_action_error():
    action = {"trigger_rules": []}
    response = client.post(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "One of text_recommendations or trigger_rules should be defined",
            "type": "value_error",
        }
    ]

    action = {
        "text_recommendations": {"count": -1},
        "trigger_rules": [{"text": "hi", "payload": "greet"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "count cannot be negative",
            "type": "value_error",
        }
    ]


def test_edit_kairon_two_stage_fallback_action_not_exists():
    action = {
        "trigger_rules": [{"text": "Hi", "payload": "kairon_two_stage_fallback_action"}]
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"] == f'Action with name "{KAIRON_TWO_STAGE_FALLBACK}" not found'
    )


def test_add_kairon_two_stage_fallback_action():
    action = {
        "fallback_message": "I could not understand you! Did you mean any of the suggestions below?"
                            " Or else please rephrase your question.",
        "text_recommendations": {"count": 0, "use_intent_ranking": True},
        "trigger_rules": [{"text": "Hi", "payload": "greet"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"


def test_add_kairon_two_stage_fallback_action_exists():
    action = {"trigger_rules": [{"text": "Hi", "payload": "greet"}]}
    response = client.post(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Action exists!"


def test_edit_kairon_two_stage_fallback_action_action():
    action = {
        "fallback_message": "I could not understand you! Did you mean any of the suggestions below?"
                            " Or else please rephrase your question.",
        "text_recommendations": {"count": 4},
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"


def test_get_kairon_two_stage_fallback_action_1():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"][0].get("timestamp") is None
    actual["data"][0].pop("_id")
    assert actual["data"] == [
        {
            "name": "kairon_two_stage_fallback",
            "text_recommendations": {"count": 4, "use_intent_ranking": False},
            "trigger_rules": [],
            "fallback_message": "I could not understand you! Did you mean any of the suggestions"
                                " below? Or else please rephrase your question.",
        }
    ]


def test_delete_kairon_two_stage_fallback_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/{KAIRON_TWO_STAGE_FALLBACK}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"


def test_get_kairon_two_stage_fallback_action_2():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/fallback/two_stage",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_disable_integration_token():
    response = client.put(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 3", "status": "inactive"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Integration status updated!"


def test_list_integrations_after_disable():
    response = client.get(
        f"/api/auth/{pytest.bot}/integration/token/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["name"] == "integration 1"
    assert actual["data"][0]["user"] == "integ1@gmail.com"
    assert actual["data"][0]["iat"]
    assert actual["data"][0]["status"] == "active"
    assert actual["data"][0]["role"] == "designer"
    assert actual["data"][1]["name"] == "integration 3"
    assert actual["data"][1]["user"] == "integ1@gmail.com"
    assert actual["data"][1]["iat"]
    assert actual["data"][1]["status"] == "inactive"
    assert actual["data"][1]["role"] == "designer"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_use_inactive_token():
    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": pytest.disable_token,
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert actual["message"] == "Access to bot is denied"
    assert not actual["success"]
    assert actual["error_code"] == 401

    response = client.put(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 3", "status": "active", "role": "tester"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": pytest.disable_token,
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]


def test_delete_integration_token():
    response = client.put(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 3", "status": "deleted"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Integration status updated!"

    response = client.get(
        f"/api/auth/{pytest.bot}/integration/token/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert len(actual["data"]) == 1


def test_integration_token_from_one_bot_on_another_bot():
    response = client.post(
        "/api/account/bot",
        json={"name": "demo-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["message"] == "Bot created"
    assert response["error_code"] == 0
    assert response["success"]

    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert len(response["data"]["account_owned"]) == 1
    assert len(response["data"]["shared"]) == 3
    bot1 = response["data"]["account_owned"][0]["_id"]
    bot2 = response["data"]["shared"][0]["_id"]

    response = client.post(
        f"/api/auth/{bot2}/integration/token",
        json={"name": "integration 4", "expiry_minutes": 1440},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    token = response.json()
    assert token["success"]
    assert token["error_code"] == 0
    assert token["data"]["access_token"]
    assert token["data"]["token_type"]

    response = client.get(
        f"/api/bot/{bot1}/intents",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert actual["message"] == "Access to bot is denied"
    assert not actual["success"]
    assert actual["error_code"] == 401

    response = client.get(
        f"/api/bot/{pytest.bot}/intents",
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert (
            actual["message"]
            == "['owner', 'admin', 'designer', 'tester'] access is required to perform this operation on the bot"
    )
    assert not actual["success"]
    assert actual["error_code"] == 401

    response = client.post(
        f"/api/bot/{pytest.bot}/chat",
        json={"data": "hi"},
        headers={
            "Authorization": token["data"]["token_type"]
                             + " "
                             + token["data"]["access_token"],
            "X-USER": "integration",
        },
    )
    actual = response.json()
    assert actual["error_code"] != 401


def test_integration_limit_reached(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(bot=pytest.bot, user="integration@demo.ai", integrations_per_user_limit=2)

    monkeypatch.setattr(MongoProcessor, 'get_bot_settings', _mock_get_bot_settings)

    response = client.post(
        f"/api/auth/{pytest.bot}/integration/token",
        json={"name": "integration 4", "expiry_minutes": 1440},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    token = response.json()
    assert not token["success"]
    assert token["error_code"] == 422
    assert token["message"] == "Integrations limit reached!"
    assert not token["data"]


def test_list_integrations():
    response = client.get(
        f"/api/auth/{pytest.bot}/integration/token/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"][0]["name"] == "integration 1"
    assert actual["data"][0]["user"] == "integ1@gmail.com"
    assert actual["data"][0]["iat"]
    assert actual["data"][0]["status"] == "active"
    assert actual["data"][1]["name"] == "integration 4"
    assert actual["data"][1]["user"] == "integ1@gmail.com"
    assert actual["data"][1]["iat"]
    assert actual["data"][1]["expiry"]
    assert actual["data"][1]["status"] == "active"
    assert actual["success"]
    assert actual["error_code"] == 0


def test_add_channel_config_error():
    data = {
        "connector_type": "custom",
        "config": {
            "bot_user_oAuth_token": "xoxb-801939352912-801478018484-v3zq6MYNu62oSs8vammWOY8K",
            "slack_signing_secret": "79f036b9894eef17c064213b90d1042b",
            "client_id": "3396830255712.3396861654876869879",
            "client_secret": "cf92180a7634d90bf42a217408376878",
        },
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "Invalid channel type custom",
            "type": "value_error",
        }
    ]

    data = {
        "connector_type": "slack",
        "config": {"slack_signing_secret": "79f036b9894eef17c064213b90d1042b"},
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "Missing ['bot_user_oAuth_token', 'slack_signing_secret', 'client_id', 'client_secret'] all or any in config",
            "type": "value_error",
        }
    ]

    data = {
        "connector_type": "slack",
        "config": {
            "bot_user_oAuth_token": "xoxb-801939352912-801478018484-v3zq6MYNu62oSs8vammWOY8K"
        },
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "Missing ['bot_user_oAuth_token', 'slack_signing_secret', 'client_id', 'client_secret'] all or any in config",
            "type": "value_error",
        }
    ]

    data = {
        "connector_type": "slack",
        "config": {
            "bot_user_oAuth_token": "xoxb-801939352912-801478018484-v3zq6MYNu62oSs8vammWOY8K",
            "slack_signing_secret": "79f036b9894eef17c064213b90d1042b",
            "client_id": "3396830255712.3396861654876869879",
            "client_secret": "cf92180a7634d90bf42a217408376878",
            "is_primary": False,
        },
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json=data,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == "Cannot edit secondary slack app. Please delete and install the app again using oAuth."
    )


def test_add_bot_with_template_name(monkeypatch):
    from kairon.shared.admin.data_objects import BotSecrets

    def mock_reload_model(*args, **kwargs):
        mock_reload_model.called_with = (args, kwargs)
        return None

    monkeypatch.setattr(Utility, "reload_model", mock_reload_model)
    monkeypatch.setitem(Utility.environment["llm"], "key", "secret_value")

    response = client.post(
        "/api/account/bot",
        json={"name": "hi-hello-gpt-bot", "from_template": "Hi-Hello-GPT"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response["message"] == "Bot created"
    assert response["error_code"] == 0
    assert response["success"]
    assert response["data"]["bot_id"]
    bot_id = response["data"]["bot_id"]
    response = client.get(
        url=f"/api/bot/{bot_id}/actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not DeepDiff(
        actual["data"],
        {
            "prompt_action": ["kairon_faq_action"],
            "web_search_action": ["google_search_action"],
            "utterances": ["utter_please_rephrase", "utter_default"],
            "http_action": [],
            "slot_set_action": [],
            "form_validation_action": [],
            "email_action": [],
            "google_search_action": [],
            "jira_action": [],
            "zendesk_action": [],
            "pipedrive_leads_action": [],
            "hubspot_forms_action": [],
            "two_stage_fallback": [],
            "kairon_bot_response": [],
            "razorpay_action": [],
            "database_action": [],
            "actions": [],
            "pyscript_action": [],
            "live_agent_action": [],
            "callback_action": [],
            "schedule_action": [],
            "parallel_action": []
        },
        ignore_order=True,
    )
    bot_secret = (
        BotSecrets.objects(bot=bot_id, secret_type="gpt_key").get().to_mongo().to_dict()
    )
    assert bot_secret["secret_type"] == "gpt_key"
    assert Utility.decrypt_message(bot_secret["value"]) == "secret_value"
    assert len(mock_reload_model.called_with[0]) == 2
    assert mock_reload_model.called_with[0][0] == bot_id
    assert mock_reload_model.called_with[0][1] == "integ1@gmail.com"


def test_set_templates_with_sysadmin_as_user():
    response = client.post(
        f"/api/bot/{pytest.bot}/templates/use-case",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": "Hi-Hello-GPT"},
    )

    actual = response.json()
    assert actual["data"] is None
    assert actual["error_code"] == 0
    assert actual["message"] == "Data applied!"
    assert actual["success"]

    stories = Stories.objects(bot=pytest.bot)
    stories = [{k: v for k, v in story.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
               story in stories]

    assert stories == [
        {'block_name': 'greet', 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': 'greet', 'type': 'user', 'entities': []},
                    {'name': 'google_search_action', 'type': 'action'},
                    {'name': 'kairon_faq_action', 'type': 'action'}],
         'user': 'sysadmin', 'status': True, 'template_type': 'CUSTOM'},
        {'block_name': 'goodbye', 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': 'goodbye', 'type': 'user', 'entities': []},
                    {'name': 'google_search_action', 'type': 'action'},
                    {'name': 'kairon_faq_action', 'type': 'action'}],
         'user': 'sysadmin', 'status': True, 'template_type': 'CUSTOM'}
    ]

    intents = Intents.objects(bot=pytest.bot)
    intents = [{k: v for k, v in intent.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
               intent in intents]

    assert intents == [
        {'name': 'greet', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False},
        {'name': 'goodbye', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False},
        {'name': 'nlu_fallback', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False}
    ]

    training_examples = TrainingExamples.objects(bot=pytest.bot)
    training_examples = [{k: v for k, v in example.to_mongo().to_dict().items() if k not in
                          ['_id', 'bot', 'timestamp']} for example in training_examples]

    assert training_examples == [
        {'intent': 'goodbye', 'text': 'bye', 'user': 'sysadmin', 'status': True},
        {'intent': 'goodbye', 'text': 'goodbye', 'user': 'sysadmin', 'status': True},
        {'intent': 'goodbye', 'text': 'see you around', 'user': 'sysadmin', 'status': True},
        {'intent': 'goodbye', 'text': 'see you later', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'hey', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'hello', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'hi', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'good morning', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'good evening', 'user': 'sysadmin', 'status': True},
        {'intent': 'greet', 'text': 'hey there', 'user': 'sysadmin', 'status': True}
    ]


def test_add_channel_config(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost:5056"
    )
    data = {
        "connector_type": "slack",
        "config": {
            "bot_user_oAuth_token": "xoxb-801939352912-801478018484-v3zq6MYNu62oSs8vammWOY8K",
            "slack_signing_secret": "79f036b9894eef17c064213b90d1042b",
            "client_id": "3396830255712.3396861654876869879",
            "client_secret": "cf92180a7634d90bf42a217408376878",
        },
    }
    with patch("slack_sdk.web.client.WebClient.team_info") as mock_slack_resp:
        mock_slack_resp.return_value = SlackResponse(
            client=None,
            http_verb="POST",
            api_url="https://slack.com/api/team.info",
            req_args={},
            data={
                "ok": True,
                "team": {
                    "id": "T03BNQE7HLX",
                    "name": "helicopter",
                    "avatar_base_url": "https://ca.slack-edge.com/",
                    "is_verified": False,
                },
            },
            headers=dict(),
            status_code=200,
        ).validate()
        response = client.post(
            f"/api/bot/{pytest.bot}/channels/add",
            json=data,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Channel added"
    assert actual["data"].startswith(
        f"http://localhost:5056/api/bot/slack/{pytest.bot}/e"
    )


def test_add_bot_with_template_with_sysadmin_as_user(monkeypatch):
    def mock_reload_model(*args, **kwargs):
        mock_reload_model.called_with = (args, kwargs)
        return None

    monkeypatch.setattr(Utility, "reload_model", mock_reload_model)
    monkeypatch.setitem(Utility.environment["llm"], "key", "secret_value")

    response = client.post(
        "/api/account/bot",
        json={"name": "gpt-bot", "from_template": "Hi-Hello-GPT"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response["message"] == "Bot created"
    assert response["data"] is not None
    assert response["error_code"] == 0
    assert response["success"]
    bot_id = response["data"]["bot_id"]

    stories = Stories.objects(bot=bot_id)
    stories = [{k: v for k, v in story.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
               story in stories]

    assert stories == [
        {'block_name': 'greet', 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': 'greet', 'type': 'user', 'entities': []},
                    {'name': 'google_search_action', 'type': 'action'},
                    {'name': 'kairon_faq_action', 'type': 'action'}],
         'user': 'sysadmin', 'status': True, 'template_type': 'CUSTOM'},
        {'block_name': 'goodbye', 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': 'goodbye', 'type': 'user', 'entities': []},
                    {'name': 'google_search_action', 'type': 'action'},
                    {'name': 'kairon_faq_action', 'type': 'action'}],
         'user': 'sysadmin', 'status': True, 'template_type': 'CUSTOM'}
    ]

    rules = Rules.objects(bot=bot_id)
    rules = [{k: v for k, v in rule.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
             rule in rules]

    assert rules == [
        {'block_name': 'ask the user to rephrase whenever they send a message with low nlu confidence',
         'condition_events_indices': [], 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': '...', 'type': 'action'},
                    {'name': 'nlu_fallback', 'type': 'user', 'entities': []},
                    {'name': 'google_search_action', 'type': 'action'},
                    {'name': 'kairon_faq_action', 'type': 'action'}],
         'user': 'sysadmin', 'status': True, 'template_type': 'CUSTOM', 'flow_tags': ['chatbot_flow']}
    ]

    utterances = Utterances.objects(bot=bot_id)
    utterances = [{k: v for k, v in utterance.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
                  utterance in utterances]

    assert utterances == [
        {'name': 'utter_please_rephrase', 'user': 'sysadmin', 'status': True},
        {'name': 'utter_default', 'user': 'sysadmin', 'status': True}
    ]

    intents = Intents.objects(bot=bot_id)
    intents = [{k: v for k, v in intent.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
               intent in intents]

    assert intents == [
        {'name': 'greet', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False},
        {'name': 'goodbye', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False},
        {'name': 'nlu_fallback', 'user': 'sysadmin', 'status': True, 'is_integration': False, 'use_entities': False}
    ]

    responses = Responses.objects(bot=bot_id)
    responses = [{k: v for k, v in response.to_mongo().to_dict().items() if k not in
                  ['_id', 'bot', 'timestamp']} for response in responses]

    assert responses == [
        {'name': 'utter_please_rephrase',
         'text': {'text': "I'm sorry, I didn't quite understand that. Could you rephrase?"},
         'user': 'sysadmin', 'status': True},
        {'name': 'utter_default', 'text': {'text': "Sorry I didn't get that. Can you rephrase?"},
         'user': 'sysadmin', 'status': True}
    ]


def test_add_bot_without_template(monkeypatch):
    def mock_reload_model(*args, **kwargs):
        mock_reload_model.called_with = (args, kwargs)
        return None

    monkeypatch.setattr(Utility, "reload_model", mock_reload_model)
    monkeypatch.setitem(Utility.environment["llm"], "key", "secret_value")

    response = client.post(
        "/api/account/bot",
        json={"name": "normal-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response["message"] == "Bot created"
    assert response["data"] is not None
    assert response["error_code"] == 0
    assert response["success"]
    bot_id = response["data"]["bot_id"]

    rules = Rules.objects(bot=bot_id)
    rules = [{k: v for k, v in rule.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
             rule in rules]

    assert rules == [
        {'block_name': 'ask the user to rephrase whenever they send a message with low nlu confidence',
         'condition_events_indices': [], 'start_checkpoints': ['STORY_START'], 'end_checkpoints': [],
         'events': [{'name': '...', 'type': 'action'}, {'name': 'nlu_fallback', 'type': 'user'},
                    {'name': 'utter_please_rephrase', 'type': 'action'}],
         'user': 'integ1@gmail.com', 'status': True, 'template_type': 'CUSTOM', 'flow_tags': ['chatbot_flow']},
        {'block_name': 'bye', 'condition_events_indices': [], 'start_checkpoints': ['STORY_START'],
         'end_checkpoints': [],
         'events': [{'name': '...', 'type': 'action'}, {'name': 'bye', 'type': 'user'},
                    {'name': 'utter_bye', 'type': 'action'}], 'user': 'integ1@gmail.com',
         'status': True, 'template_type': 'Q&A',  'flow_tags': ['chatbot_flow']},
        {'block_name': 'greet', 'condition_events_indices': [], 'start_checkpoints': ['STORY_START'],
         'end_checkpoints': [],
         'events': [{'name': '...', 'type': 'action'}, {'name': 'greet', 'type': 'user'},
                    {'name': 'utter_greet', 'type': 'action'}],
         'user': 'integ1@gmail.com', 'status': True, 'template_type': 'Q&A',  'flow_tags': ['chatbot_flow']}
    ]

    utterances = Utterances.objects(bot=bot_id)
    utterances = [{k: v for k, v in utterance.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
                  utterance in utterances]

    assert utterances == [
        {'name': 'utter_please_rephrase', 'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_default', 'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_bye', 'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_greet', 'user': 'integ1@gmail.com', 'status': True}
    ]

    intents = Intents.objects(bot=bot_id)
    intents = [{k: v for k, v in intent.to_mongo().to_dict().items() if k not in ['_id', 'bot', 'timestamp']} for
               intent in intents]

    assert intents == [
        {'name': 'bye', 'user': 'integ1@gmail.com', 'status': True, 'is_integration': False, 'use_entities': False},
        {'name': 'greet', 'user': 'integ1@gmail.com', 'status': True, 'is_integration': False, 'use_entities': False}
    ]

    training_examples = TrainingExamples.objects(bot=bot_id)
    training_examples = [{k: v for k, v in training_example.to_mongo().to_dict().items() if k not in
                          ['_id', 'bot', 'timestamp']} for training_example in training_examples]

    assert training_examples == [
        {'intent': 'bye', 'text': 'good bye', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'bye', 'text': 'bye', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'bye', 'text': 'See you later!', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'bye', 'text': 'Goodbye!', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Hi', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Hello', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Greetings', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Hi there', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Good day', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Howdy', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Hey there', 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': "What's up?", 'user': 'integ1@gmail.com', 'status': True},
        {'intent': 'greet', 'text': 'Hullo', 'user': 'integ1@gmail.com', 'status': True}
    ]

    responses = Responses.objects(bot=bot_id)
    responses = [{k: v for k, v in response.to_mongo().to_dict().items() if k not in
                  ['_id', 'bot', 'timestamp']} for response in responses]

    assert responses == [
        {'name': 'utter_please_rephrase',
         'text': {'text': "I'm sorry, I didn't quite understand that. Could you rephrase?"},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_default', 'text': {'text': "Sorry I didn't get that. Can you rephrase?"},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_bye', 'text': {'text': "Take care, I'm here for you if you need anything."},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_bye', 'text': {'text': 'Adieu, always here for you.'},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_bye', 'text': {'text': "See you later, I'm here to help."},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_greet', 'text': {'text': "I'm your AI Assistant, ready to assist"},
         'user': 'integ1@gmail.com', 'status': True},
        {'name': 'utter_greet', 'text': {'text': 'Let me be your AI Assistant and provide you with service'},
         'user': 'integ1@gmail.com', 'status': True}
    ]


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_partner_auth_token", autospec=True)
def test_add_template_error(mock_get_partner_auth_token):
    mock_get_partner_auth_token.return_value = "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIs.ImtpZCI6Ik1EZEZOVFk1UVVVMU9FSXhPRGN3UVVZME9EUTFRVFJDT1.RSRU9VUTVNVGhDTURWRk9UUTNPQSJ9"
    data = {
        "name": "Introduction template",
        "category": "UTILITY",
        "components": [
            {
                "format": "TEXT",
                "text": "New request",
                "type": "HEADER"
            },
            {
                "type": "BODY",
                "text": "Hi {{1}}, thanks for getting in touch with {{2}}. We will process your request get back to you shortly",
                "example": {
                    "body_text": [
                        [
                            "Nupur",
                            "360dialog"
                        ]
                    ]
                }
            },
            {
                "text": "WhatsApp Business API provided by 360dialog",
                "type": "FOOTER"
            }
        ],
        "language": "es_ES",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog",
        json={'data': data},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Channel not found!"
    assert actual["data"] == None


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_partner_auth_token", autospec=True)
def test_edit_template_error(mock_get_partner_auth_token):
    mock_get_partner_auth_token.return_value = "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIs.ImtpZCI6Ik1EZEZOVFk1UVVVMU9FSXhPRGN3UVVZME9EUTFRVFJDT1.RSRU9VUTVNVGhDTURWRk9UUTNPQSJ9"
    data = {
        "components": [
            {
                "format": "TEXT",
                "text": "New request",
                "type": "HEADER"
            },
            {
                "type": "BODY",
                "text": "Hi {{1}}, thanks for getting in touch with {{2}}. Let us know your queries!",
                "example": {
                    "body_text": [
                        [
                            "Nupur",
                            "360dialog"
                        ]
                    ]
                }
            },
            {
                "text": "WhatsApp Business API provided by 360dialog",
                "type": "FOOTER"
            }
        ],
        "allow_category_change": False
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/test_one_id",
        json={'data': data},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Channel not found!"
    assert actual["data"] == None


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_partner_auth_token", autospec=True)
def test_delete_template_error(mock_get_partner_auth_token):
    mock_get_partner_auth_token.return_value = "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIs.ImtpZCI6Ik1EZEZOVFk1UVVVMU9FSXhPRGN3UVVZME9EUTFRVFJDT1.RSRU9VUTVNVGhDTURWRk9UUTNPQSJ9"
    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/test_one_id",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Channel not found!"
    assert actual["data"] == None


def test_list_whatsapp_templates_error():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Channel not found!"


def test_get_channel_logs():
    from kairon.shared.chat.data_objects import ChannelLogs
    ChannelLogs(
        type=ChannelTypes.WHATSAPP.value,
        status='read',
        data={'id': 'CONVERSATION_ID', 'expiration_timestamp': '1691598412',
              'origin': {'type': 'business_initated'}},
        initiator='business_initated',
        campaign_id='6779002886649302',
        message_id='wamid.HBgLMTIxMTU1NTc5NDcVAgARGBIyRkQxREUxRDJFQUJGMkQ3NDIZ',
        bot=pytest.bot,
        user='integration@demo.ai'
    ).save()
    ChannelLogs(
        type=ChannelTypes.WHATSAPP.value,
        status='delivered',
        data={'id': 'CONVERSATION_ID', 'expiration_timestamp': '1621598412',
              'origin': {'type': 'business_initated'}},
        initiator='business_initated',
        campaign_id='6779002886649302',
        message_id='wamid.HBgLMTIxMTU1NTc5NDcVAgARGBIyRkQxREUxRDJFQUJGMkQ3NDIZ',
        bot=pytest.bot,
        user='integration@demo.ai'
    ).save()
    ChannelLogs(
        type=ChannelTypes.WHATSAPP.value,
        status='sent',
        data={'id': 'CONVERSATION_ID', 'expiration_timestamp': '1631598412',
              'origin': {'type': 'business_initated'}},
        initiator='business_initated',
        campaign_id='6779002886649302',
        message_id='wamid.HBgLMTIxMTU1NTc5NDcVAgARGBIyRkQxREUxRDJFQUJGMkQ3NDIZ',
        bot=pytest.bot,
        user='integration@demo.ai'
    ).save()
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/whatsapp/metrics",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == [
        {
            'campaign_metrics': [
                {
                    'retry_count': 0,
                    'statuses': {'delivered': 1, 'read': 1, 'sent': 1}
                }
            ],
            'campaign_id': '6779002886649302'
        }
    ]


@responses.activate
def test_initiate_bsp_onboarding_without_channels(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(whatsapp="360dialog", bot=pytest.bot, user="test_user")

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://kairon-api.digite.com"
    )
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )
    url = "https://hub.360dialog.io/api/v2/token"
    responses.add("POST", json={}, url=url, status=500)

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/onboarding?clientId=kairon&client=sdfgh5678&channels=[]",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"].startswith(
        "Failed to save channel config, onboarding unsuccessful!"
    )
    assert actual["data"] is None


@responses.activate
def test_initiate_bsp_onboarding_failure(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(whatsapp="360dialog", bot=pytest.bot, user="test_user")

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://kairon-api.digite.com"
    )
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )
    url = "https://hub.360dialog.io/api/v2/token"
    responses.add("POST", json={}, url=url, status=500)

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/onboarding?clientId=kairon&client=sdfgh5678&channels=['sdfghjk678']",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"].startswith("Failed to get partner auth token: ")
    assert actual["data"] is None


def test_initiate_bsp_onboarding_disabled(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/onboarding?clientId=kairon&client=sdfgh5678&channels=['sdfghjk678']",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == "Feature disabled for this account. Please contact support!"
    )
    assert actual["data"] is None


def test_initiate_bsp_onboarding(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(whatsapp="360dialog", bot=pytest.bot, user="test_user")

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://kairon-api.digite.com"
    )
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )

    with patch(
            "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_account"
    ) as mock_get_account:
        mock_get_account.return_value = "dfghj5678"
        with patch(
                "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.generate_waba_key"
        ) as mock_generate_waba_key:
            mock_generate_waba_key.return_value = "dfghjk5678"
            response = client.post(
                f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/onboarding?clientId=kairon&client=sdfgh5678&channels=['sdfghjk678']",
                headers={
                    "Authorization": pytest.token_type + " " + pytest.access_token
                },
            )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Channel added"
    assert actual["data"].startswith(
        f"http://kairon-api.digite.com/api/bot/whatsapp/{pytest.bot}/e"
    )


def test_post_process(monkeypatch):
    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(whatsapp="360dialog", bot=pytest.bot, user="test_user")

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://kairon-api.digite.com"
    )
    monkeypatch.setitem(
        Utility.environment["channels"]["360dialog"], "partner_id", "f167CmPA"
    )

    with patch(
            "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.get_account"
    ) as mock_get_account:
        mock_get_account.return_value = "dfghj5678"
        with patch(
                "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.generate_waba_key"
        ) as mock_generate_waba_key:
            mock_generate_waba_key.return_value = "dfghjk5678"
            with patch(
                    "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.set_webhook_url",
                    autospec=True,
            ):
                response = client.post(
                    f"/api/bot/{pytest.bot}/channels/whatsapp/360dialog/post_process",
                    headers={
                        "Authorization": pytest.token_type + " " + pytest.access_token
                    },
                )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Credentials refreshed!"
    assert actual["data"].startswith(
        f"http://kairon-api.digite.com/api/bot/whatsapp/{pytest.bot}/e"
    )


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.add_template", autospec=True)
def test_add_template(mock_add_template):
    data = {
        "name": "Introduction template",
        "category": "MARKETING",
        "components": [
            {
                "format": "TEXT",
                "text": "New request",
                "type": "HEADER"
            },
            {
                "type": "BODY",
                "text": "Hi {{1}}, thanks for getting in touch with {{2}}. We will process your request get back to you shortly",
                "example": {
                    "body_text": [
                        [
                            "Nupur",
                            "360dialog"
                        ]
                    ]
                }
            },
            {
                "text": "WhatsApp Business API provided by 360dialog",
                "type": "FOOTER"
            }
        ],
        "language": "es_ES",
        "allow_category_change": True
    }
    api_resp = {
        "id": "594425479261596",
        "status": "PENDING",
        "category": "MARKETING"
    }
    mock_add_template.return_value = api_resp

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog",
        json={'data': data},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == {'id': '594425479261596', 'status': 'PENDING', 'category': 'MARKETING'}


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.edit_template", autospec=True)
def test_edit_template(mock_edit_template):
    data = {
        "components": [
            {
                "format": "TEXT",
                "text": "New request",
                "type": "HEADER"
            },
            {
                "type": "BODY",
                "text": "Hi {{1}}, thanks for getting in touch with {{2}}. Let us know your queries!",
                "example": {
                    "body_text": [
                        [
                            "Nupur",
                            "360dialog"
                        ]
                    ]
                }
            },
            {
                "text": "WhatsApp Business API provided by 360dialog",
                "type": "FOOTER"
            }
        ],
        "allow_category_change": False
    }
    api_resp = {
        "success": True
    }
    mock_edit_template.return_value = api_resp

    response = client.put(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/test_id",
        json={'data': data},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == [{'success': True}]


@patch("kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.delete_template", autospec=True)
def test_delete_template(mock_delete_template):
    api_resp = {
        "meta": {
            "developer_message": "template name=Introduction template was deleted",
            "http_code": 200,
            "success": True
        }
    }
    mock_delete_template.return_value = api_resp

    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/test_id",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == api_resp


@patch(
    "kairon.shared.channels.whatsapp.bsp.dialog360.BSP360Dialog.list_templates",
    autospec=True,
)
def test_list_templates(mock_list_templates):
    api_resp = {
        "waba_templates": [
            {
                "category": "MARKETING",
                "components": [
                    {
                        "example": {"body_text": [["Peter"]]},
                        "text": "Hi {{1}},\n\nWe are thrilled to share that *kAIron* has now been integrated with WhatsApp through the *WhatsApp Business Solution Provide*r (BSP). \n\nThis integration will expand kAIron's ability to engage with a larger audience, increase sales acceleration, and provide better customer support.\n\nWith this integration, sending customized templates and broadcasting general, sales, or marketing information over WhatsApp will be much quicker and more efficient. \n\nStay tuned for more exciting updates from Team kAIron!",
                        "type": "BODY",
                    }
                ],
                "id": "GVsEkeI2PIiARwVXQEDVWT",
                "language": "en",
                "modified_at": "2023-03-02T13:39:27Z",
                "modified_by": {"user_id": "system", "user_name": "system"},
                "name": "kairon_new_features",
                "namespace": "092819ec_f801_461b_b975_3a2d464f50a8",
                "partner_id": "9Mg0AiPA",
                "waba_account_id": "Cyih7GWA",
            }
        ]
    }
    mock_list_templates.return_value = api_resp["waba_templates"]

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/whatsapp/templates/360dialog/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["templates"] == api_resp["waba_templates"]


def test_get_channel_endpoint(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost:5056"
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/slack/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"].startswith(
        f"http://localhost:5056/api/bot/slack/{pytest.bot}/e"
    )


def test_get_channels_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    assert len(actual["data"]) == 2
    pytest.slack_channel_id = actual["data"][0]["_id"]
    actual["data"][0].pop("_id")
    actual["data"][1].pop("_id")
    assert actual["data"] == [
        {
            "bot": pytest.bot,
            "connector_type": "slack",
            "config": {
                "bot_user_oAuth_token": "xoxb-801939352912-801478018484-v3zq6MYNu62oSs8vamm*****",
                "slack_signing_secret": "79f036b9894eef17c064213b90d*****",
                "client_id": "3396830255712.33968616548768*****",
                "client_secret": "cf92180a7634d90bf42a2174083*****",
                "is_primary": True,
                "team": {"id": "T03BNQE7HLX", "name": "helicopter"},
            },
            "meta_config": {},
        },
        {
            "bot": pytest.bot,
            "connector_type": "whatsapp",
            "config": {
                "client_name": "k*****",
                "client_id": "sdfgh5678",
                "channel_id": "sdfghjk678",
                "partner_id": "f167CmPA",
                "waba_account_id": "dfghj5678",
                "api_key": "dfghjk5678",
                "bsp_type": "360dialog",
            },
            "meta_config": {},
        },
    ]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_scheduled_broadcast(mock_event_server):
    config = {
        "name": "first_scheduler",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "57 22 * * *",
            "timezone": "UTC",
        },
        "recipients_config": {"recipients": "918958030541, "},
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.first_scheduler_id = actual["data"]["msg_broadcast_id"]
    assert pytest.first_scheduler_id


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_scheduled_broadcast_with_invalid_cron(mock_event_server):
    config = {
        "name": "first_scheduler",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "mayank",
            "timezone": "UTC",
        },
        "recipients_config": {"recipients": "918958030541,"},
        "template_config": [
            {"template_id": "brochure_pdf"}
        ],
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["success"] is False

    assert any(
        "Invalid cron expression: 'mayank'" in str(msg.get("msg", ""))
        for msg in actual["message"]
    )


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_broadcast(mock_event_server):
    config = {
        "name": "one_time_schedule",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "918958030541,"},
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.one_time_schedule_id = actual["data"]["msg_broadcast_id"]
    assert pytest.one_time_schedule_id


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_broadcast(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())

    config = {
        "name": "one_time_schedule_broadcast",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": run_at,
            "expression_type": "epoch",
            "timezone": "Asia/Calcutta"
        },
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast added!"
    pytest.one_time_schedule_broadcast_id = actual["data"]["msg_broadcast_id"]
    assert pytest.one_time_schedule_broadcast_id

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_missing_run_at(mock_event_server):
    config = {
        "name": "missing_run_at",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "expression_type": "epoch",
            "timezone": "Asia/Calcutta"
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response=response.json()
    print(response)
    assert response["error_code"]== 422
    errors = response["message"]

    assert any("schedule time is required for all schedules!" in err.get("msg", "") for err in errors)

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_past_run_at(mock_event_server):
    past_epoch = int((datetime.utcnow() - timedelta(hours=1)).timestamp())
    config = {
        "name": "past_run_at",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": past_epoch,
            "expression_type": "epoch",
            "timezone": "Asia/Calcutta"
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    response=response.json()
    assert response["error_code"]== 422
    errors = response["message"]
    assert any("epoch time (schedule) must be in the future relative to the provided timezone" in err["msg"] for err in errors)


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_missing_timezone(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())
    config = {
        "name": "missing_timezone",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "expression_type":"epoch",
            "schedule": run_at,
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    response=response.json()
    assert response["error_code"]== 422
    errors = response["message"]
    assert any("timezone is required for all schedules!" in err["msg"] for err in errors)

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_with_invalid_expression_type(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())
    config = {
        "name": "missing_timezone",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": run_at,
            "timezone": "Asia/Calcutta",
            "expression_type":"mayank"
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    response=response.json()
    assert response["error_code"]== 422
    errors = response["message"]
    assert any("expression_type must be either cron or epoch" in err["msg"] for err in errors)

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_with_invalid_epoch_string(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())
    config = {
        "name": "missing_timezone",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": "mayank",
            "timezone": "Asia/Calcutta",
            "expression_type":"epoch"
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    response=response.json()
    assert response["error_code"]== 422
    errors = response["message"]
    assert any("schedule must be a valid integer epoch time for 'epoch' expression_type" in err["msg"] for err in errors)



@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_one_time_schedule_with_invalid_timezone(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())
    config = {
        "name": "missing_timezone",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": run_at,
            "timezone": "mayank",
            "expression_type":"epoch"
        },
        "template_config": [{"template_id": "brochure_pdf"}],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    print(response.json())
    response=response.json()
    assert response["error_code"]== 422
    errors = response["message"]
    assert any("Unknown timezone: mayank" in err["msg"] for err in errors)


@patch("kairon.shared.utils.Utility.request_event_server", side_effect=Exception("Event server failed"))
def test_add_one_time_schedule_integration_failure(mock_request_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(minutes=10)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())

    config = {
        "name": "one_time_schedule_broadcast_error",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": run_at,
            "expression_type": "epoch",
            "timezone": "Asia/Calcutta"
        },
        "template_config": [
            {"template_id": "brochure_pdf"}
        ],
    }


    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    body = response.json()
    print(body)
    assert body["success"] is False
    assert "Event server failed" in body["message"]


def test_broadcast_config_error():
    config = {
        "name": "one_time_schedule",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "* * * * *",
            "timezone": "UTC",
        },
        "recipients_config": {"recipients": "918958030541,"},
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "scheduler_config", "__root__"],
            "msg": "Recurrence interval must be at least 86340 seconds!",
            "type": "value_error",
        }
    ]

    config["scheduler_config"] = {
        "expression_type": "cron",
        "schedule": "57 22 * * *",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "scheduler_config", "__root__"],
            "msg": "timezone is required for all schedules!",
            "type": "value_error",
        }
    ]

    config["scheduler_config"]["schedule"] = ""
    config["scheduler_config"]["timezone"] = "UTC"
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "scheduler_config", "__root__"],
            "msg": f"schedule time is required for all schedules!",
            "type": "value_error",
        }
    ]

    config["scheduler_config"] = {
        "expression_type": "cron",
        "schedule": "30 5 * * *",
        "timezone": "UTC",
    }
    config["broadcast_type"] = "dynamic"
    config["template_name"] = "consent"
    config["language_code"] = "en"
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "pyscript is required for dynamic broadcasts!",
            "type": "value_error",
        },
    ]

    config["broadcast_type"] = "static"
    config.pop("template_config")
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {
            "loc": ["body", "__root__"],
            "msg": "recipients_config and template_config is required for static broadcasts!",
            "type": "value_error",
        }
    ]


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_update_broadcast(mock_event_server):
    config = {
        "name": "first_scheduler_dynamic",
        "broadcast_type": "dynamic",
        "connector_type": "whatsapp",
        "template_name": "consent",
        "language_code": "en",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "21 11 * * *",
            "timezone": "Asia/Kolkata",
        },
        "pyscript": "send_msg('template_name', '9876543210')",
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.first_scheduler_id}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast updated!"

@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_update_one_time_scheduled_broadcast(mock_event_server):
    ist = pytz.timezone("Asia/Kolkata")
    dt_ist = datetime.now(ist) + timedelta(hours=1)
    run_at = int(dt_ist.astimezone(pytz.UTC).timestamp())
    config = {
        "name": "one_time_schedule_broadcast",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "916200035185,"},
        "scheduler_config": {
            "schedule": run_at,
            "expression_type": "epoch",
            "timezone": "Asia/Calcutta"
        },
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.one_time_schedule_broadcast_id}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(response.json())
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast updated!"


def test_update_one_time_broadcast_failure():
    config = {
        "name": "one_time_schedule",
        "broadcast_type": "static",
        "connector_type": "whatsapp",
        "recipients_config": {"recipients": "918958030541,"},
        "template_config": [
            {
                "template_id": "brochure_pdf",
            }
        ],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.one_time_schedule_id}",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "scheduler_config with a valid schedule is required!"


def test_list_broadcast_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)

    assert actual["success"]
    assert actual["error_code"] == 0

    for sched in actual["data"]["schedules"]:
        sched.pop("_id", None)
        sched.pop("timestamp", None)
        sched.pop("bot", None)
        sched.pop("user", None)
        if sched.get("scheduler_config") and sched["scheduler_config"].get("expression_type") == "epoch":
            sched["scheduler_config"].pop("schedule", None)

    assert actual["data"] == {
        "schedules": [
            {
                "name": "first_scheduler_dynamic",
                "connector_type": "whatsapp",
                "broadcast_type": "dynamic",
                "collection_config": {},
                "scheduler_config": {
                    "expression_type": "cron",
                    "schedule": "21 11 * * *",
                    "timezone": "Asia/Kolkata",
                },
                "retry_count": 0,
                "pyscript": "send_msg('template_name', '9876543210')",
                "status": True,
                "template_config": [],
            },
            {
                "name": "one_time_schedule",
                "connector_type": "whatsapp",
                "broadcast_type": "static",
                "collection_config": {},
                "recipients_config": {"recipients": "918958030541,"},
                "retry_count": 0,
                "template_config": [{"template_id": "brochure_pdf", "language": "en"}],
                "status": True,
            },
            {
                "name": "one_time_schedule_broadcast",
                "connector_type": "whatsapp",
                "broadcast_type": "static",
                "collection_config": {},
                "recipients_config": {"recipients": "916200035185,"},
                "retry_count": 0,
                "status": True,
                "template_config": [{"template_id": "brochure_pdf", "language": "en"}],
                "scheduler_config": {"expression_type":"epoch",
                                     "timezone": "Asia/Calcutta"},
            },
        ]
    }


@patch("kairon.shared.utils.Utility.delete_scheduled_event", autospec=True)
def test_delete_broadcast(mock_event_server):
    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.first_scheduler_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast removed!"
    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.one_time_schedule_broadcast_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Broadcast removed!"


def test_delete_broadcast_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/{pytest.first_scheduler_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Notification settings not found!"


def test_list_broadcast_():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["schedules"][0].pop("timestamp")
    actual["data"]["schedules"][0].pop("user")
    assert actual["data"] == {
        "schedules": [
            {
                "_id": pytest.one_time_schedule_id,
                "name": "one_time_schedule",
                "connector_type": "whatsapp",
                "broadcast_type": "static",
                "collection_config": {},
                "recipients_config": {"recipients": "918958030541,"},
                "retry_count": 0,
                "template_config": [{"template_id": "brochure_pdf", "language": "en"}],
                "bot": pytest.bot,
                "status": True,
            }
        ]
    }


def test_list_broadcast_logs():
    from kairon.shared.chat.broadcast.data_objects import MessageBroadcastLogs

    ref_id = ObjectId().__str__()
    timestamp = datetime.utcnow()
    MessageBroadcastLogs(
        **{
            "reference_id": ref_id,
            "log_type": "common",
            "bot": pytest.bot,
            "status": EVENT_STATUS.COMPLETED.value,
            "user": "test_user",
            "broadcast_id": pytest.first_scheduler_id,
            "recipients": ["918958030541", ""],
            "timestamp": timestamp,
        }
    ).save()
    timestamp = timestamp + timedelta(minutes=2)
    MessageBroadcastLogs(
        **{
            "reference_id": ref_id,
            "log_type": "send",
            "bot": pytest.bot,
            "status": STATUSES.SUCCESS.value,
            "api_response": {
                "contacts": [
                    {"input": "+55123456789", "status": "valid", "wa_id": "55123456789"}
                ]
            },
            "recipient": "9876543210",
            "template_params": [
                {
                    "type": "header",
                    "parameters": [
                        {
                            "type": "document",
                            "document": {
                                "link": "https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm",
                                "filename": "Brochure.pdf",
                            },
                        }
                    ],
                }
            ],
            "timestamp": timestamp,
        }
    ).save()
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/logs?log_type=common",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["logs"][0].pop("timestamp")
    assert actual["data"]["logs"] == [
        {
            "reference_id": ref_id,
            "log_type": "common",
            "bot": pytest.bot,
            "status": EVENT_STATUS.COMPLETED.value,
            "user": "test_user",
            "broadcast_id": pytest.first_scheduler_id,
            "recipients": ["918958030541", ""],
        }
    ]
    assert actual["data"]["total_count"] == 1

    response = client.get(
        f"/api/bot/{pytest.bot}/channels/broadcast/message/logs?reference_id={ref_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    actual["data"]["logs"][0].pop("timestamp")
    actual["data"]["logs"][1].pop("timestamp")
    assert actual["data"] == {
        "logs": [
            {
                "reference_id": ref_id,
                "log_type": "send",
                "bot": pytest.bot,
                "status": STATUSES.SUCCESS.value,
                "api_response": {
                    "contacts": [
                        {
                            "input": "+55123456789",
                            "status": "valid",
                            "wa_id": "55123456789",
                        }
                    ]
                },
                "recipient": "9876543210",
                "template_params": [
                    {
                        "type": "header",
                        "parameters": [
                            {
                                "type": "document",
                                "document": {
                                    "link": "https://drive.google.com/uc?export=download&id=1GXQ43jilSDelRvy1kr3PNNpl1e21dRXm",
                                    "filename": "Brochure.pdf",
                                },
                            }
                        ],
                    }
                ],
            },
            {
                "reference_id": ref_id,
                "log_type": "common",
                "bot": pytest.bot,
                "status": EVENT_STATUS.COMPLETED.value,
                "user": "test_user",
                "broadcast_id": pytest.first_scheduler_id,
                "recipients": ["918958030541", ""],
            },
        ],
        "total_count": 2,
    }


def test_get_bot_settings():
    response = client.get(
        f"/api/bot/{pytest.bot}/settings",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    actual["data"].pop("bot")
    actual["data"].pop("user")
    actual["data"].pop("timestamp")
    actual["data"].pop("status")
    assert actual['data'] == {'is_billed': False, 'chat_token_expiry': 30,
                              'data_generation_limit_per_day': 3,
                              'data_importer_limit_per_day': 5,
                              'force_import': False,
                              'ignore_utterances': False,
                              'llm_settings': {'enable_faq': False, 'provider': 'openai'},
                              'analytics': {'fallback_intent': 'nlu_fallback'},
                              'multilingual_limit_per_day': 2,
                              'max_actions_per_parallel_action': 5,
                              'notification_scheduling_limit': 4,
                              'refresh_token_expiry': 60,
                              'rephrase_response': False,
                              'live_agent_enabled': False,
                              'pos_enabled': False,
                              'test_limit_per_day': 5,
                              'training_limit_per_day': 5, 'dynamic_broadcast_execution_timeout': 21600,
                              'website_data_generator_depth_search_limit': 2,
                              'whatsapp': 'meta',
                              'cognition_collections_limit': 3,
                              'cognition_columns_per_collection_limit': 5,
                              'content_importer_limit_per_day': 5,
                              'system_limits': {'file_upload_limit': 5},
                              'integrations_per_user_limit': 3,
                              'retry_broadcasting_limit': 3,
                              'catalog_sync_limit_per_day': 5,
                              'max_instagram_user_posts': 5}


@patch("kairon.shared.utils.Utility.request_event_server", autospec=True)
def test_add_scheduled_dynamic_broadcast(mock_event_server):
    config = {
        "name": "first_scheduler_dynamic",
        "broadcast_type": "dynamic",
        "connector_type": "whatsapp",
        "template_name": "consent",
        "language_code": "en",
        "scheduler_config": {
            "expression_type": "cron",
            "schedule": "21 11 * * *",
            "timezone": "Asia/Kolkata",
        },
        "pyscript": "send_msg('template_name', '9876543210')",
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/broadcast/message",
        json=config,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == 'Broadcast added!'
    assert actual["data"]


def test_update_analytics_settings_with_empty_value():
    bot_settings = {
        "analytics": {'fallback_intent': ''},
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/settings",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=bot_settings
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'analytics', 'fallback_intent'],
                                  'msg': 'fallback_intent field cannot be empty', 'type': 'value_error'}]


def test_update_analytics_settings_with_none():
    bot_settings = {
        "analytics": {'fallback_intent': None},
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/settings",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=bot_settings
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [{'loc': ['body', 'analytics', 'fallback_intent'],
                                  'msg': 'none is not an allowed value', 'type': 'type_error.none.not_allowed'}]


def test_update_analytics_settings():
    bot_settings = {
        "analytics": {'fallback_intent': 'utter_please_rephrase'},
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/settings",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=bot_settings
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Bot Settings updated"
    response = client.get(
        f"/api/bot/{pytest.bot}/settings",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] is None
    actual["data"].pop("bot")
    actual["data"].pop("user")
    actual["data"].pop("timestamp")
    actual["data"].pop("status")
    assert actual['data'] == {'is_billed': False, 'chat_token_expiry': 30,
                              'data_generation_limit_per_day': 3,
                              'data_importer_limit_per_day': 5,
                              'force_import': False,
                              'ignore_utterances': False,
                              'llm_settings': {'enable_faq': False, 'provider': 'openai'},
                              'analytics': {'fallback_intent': 'utter_please_rephrase'},
                              'multilingual_limit_per_day': 2,
                              'max_actions_per_parallel_action': 5,
                              'notification_scheduling_limit': 4,
                              'refresh_token_expiry': 60,
                              'rephrase_response': False,
                              'test_limit_per_day': 5,
                              'training_limit_per_day': 5, 'dynamic_broadcast_execution_timeout': 21600,
                              'website_data_generator_depth_search_limit': 2,
                              'whatsapp': 'meta',
                              'live_agent_enabled': False,
                              'pos_enabled': False,
                              'cognition_collections_limit': 3,
                              'content_importer_limit_per_day': 5,
                              'system_limits': {'file_upload_limit': 5},
                              'cognition_columns_per_collection_limit': 5,
                              'integrations_per_user_limit': 3,
                              'retry_broadcasting_limit': 3,
                              'catalog_sync_limit_per_day': 5,
                              'max_instagram_user_posts': 5}


def test_delete_channels_config():
    response = client.delete(
        f"/api/bot/{pytest.bot}/channels/{pytest.slack_channel_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Channel deleted"


def _mock_error(*args, **kwargs):
    raise JIRAError(status_code=404, url="https://test1-digite.atlassian.net")


def test_add_jira_action_invalid_config(monkeypatch):
    url = "https://test_add_jira_action_invalid_config.net"
    action = {
        "name": "jira_action_new",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }
    monkeypatch.setattr(ActionUtility, "get_jira_client", _mock_error)
    response = client.post(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == "JiraError HTTP 404 url: https://test1-digite.atlassian.net\n\t"
    )


def test_list_jira_action_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/jira",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


@responses.activate
def test_add_jira_action():
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }
    responses.add(
        "GET",
        f"{url}/rest/api/2/serverInfo",
        json={
            "baseUrl": "https://udit-pandey.atlassian.net",
            "version": "1001.0.0-SNAPSHOT",
            "versionNumbers": [1001, 0, 0],
            "deploymentType": "Cloud",
            "buildNumber": 100191,
            "buildDate": "2022-02-11T05:35:40.000+0530",
            "serverTime": "2022-02-15T10:54:09.906+0530",
            "scmInfo": "831671b3b59f40b5108ef3f9491df89a1317ecaa",
            "serverTitle": "Jira",
            "defaultLocale": {"locale": "en_US"},
        },
    )
    responses.add(
        "GET",
        f"{url}/rest/api/2/project/HEL",
        json={
            "expand": "description,lead,issueTypes,url,projectKeys,permissions,insight",
            "self": "https://udit-pandey.atlassian.net/rest/api/2/project/10000",
            "id": "10000",
            "key": "HEL",
            "description": "",
            "lead": {
                "self": "https://udit-pandey.atlassian.net/rest/api/2/user?accountId=6205e1585d18ad00729aa75f",
                "accountId": "6205e1585d18ad00729aa75f",
                "avatarUrls": {
                    "48x48": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "24x24": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "16x16": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "32x32": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                },
                "displayName": "Udit Pandey",
                "active": True,
            },
            "components": [],
            "issueTypes": [
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10001",
                    "id": "10001",
                    "description": "A small, distinct piece of work.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10318?size=medium",
                    "name": "Task",
                    "subtask": False,
                    "avatarId": 10318,
                    "hierarchyLevel": 0,
                },
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10002",
                    "id": "10002",
                    "description": "A collection of related bugs, stories, and tasks.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10307?size=medium",
                    "name": "Epic",
                    "subtask": False,
                    "avatarId": 10307,
                    "hierarchyLevel": 1,
                },
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10003",
                    "id": "10003",
                    "description": "Subtasks track small pieces of work that are part of a larger task.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10316?size=medium",
                    "name": "Bug",
                    "subtask": True,
                    "avatarId": 10316,
                    "hierarchyLevel": -1,
                },
            ],
            "assigneeType": "UNASSIGNED",
            "versions": [],
            "name": "helicopter",
            "roles": {
                "atlassian-addons-project-access": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10007",
                "Administrator": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10004",
                "Viewer": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10006",
                "Member": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10005",
            },
            "avatarUrls": {
                "48x48": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408",
                "24x24": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=small",
                "16x16": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=xsmall",
                "32x32": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=medium",
            },
            "projectTypeKey": "software",
            "simplified": True,
            "style": "next-gen",
            "isPrivate": False,
            "properties": {},
            "entityId": "8a851ebf-72eb-461d-be68-4c2c28805440",
            "uuid": "8a851ebf-72eb-461d-be68-4c2c28805440",
        },
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


@patch("kairon.shared.actions.utils.ActionUtility.get_jira_client", autospec=True)
@patch("kairon.shared.actions.utils.ActionUtility.validate_jira_action", autospec=True)
def test_add_jira_action_different_parameter_type(mock_jira_client, mock_validate):
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action_slot",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL", "parameter_type": "slot"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"

    action = {
        "name": "jira_action_key_vault",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added"


@patch("kairon.shared.actions.data_objects.JiraAction.validate", autospec=True)
def test_add_jira_action_invalid_parameter_type(moack_jira):
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action_slot",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL", "parameter_type": "user_message"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_list_jira_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/jira",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    [action.pop("_id") for action in actual["data"]]
    assert actual["data"] == [
        {
            "name": "jira_action",
            "url": "https://test-digite.atlassian.net",
            "user_name": "test@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "ASDFGHJKL",
                "parameter_type": "value",
            },
            "project_key": "HEL",
            "issue_type": "Bug",
            "summary": "new user",
            "response": "We have logged a ticket",
        },
        {
            "name": "jira_action_slot",
            "url": "https://test-digite.atlassian.net",
            "user_name": "test@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "ASDFGHJKL",
                "parameter_type": "slot",
            },
            "project_key": "HEL",
            "issue_type": "Bug",
            "summary": "new user",
            "response": "We have logged a ticket",
        },
        {
            "name": "jira_action_key_vault",
            "url": "https://test-digite.atlassian.net",
            "user_name": "test@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "AWS_KEY",
                "parameter_type": "key_vault",
            },
            "project_key": "HEL",
            "issue_type": "Bug",
            "summary": "new user",
            "response": "We have logged a ticket",
        },
    ]


@responses.activate
def test_edit_jira_action():
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL"},
        "project_key": "HEL",
        "issue_type": "Subtask",
        "parent_key": "HEL-4",
        "summary": "new user",
        "response": "We have logged a ticket",
    }
    responses.add(
        "GET",
        f"{url}/rest/api/2/serverInfo",
        json={
            "baseUrl": "https://udit-pandey.atlassian.net",
            "version": "1001.0.0-SNAPSHOT",
            "versionNumbers": [1001, 0, 0],
            "deploymentType": "Cloud",
            "buildNumber": 100191,
            "buildDate": "2022-02-11T05:35:40.000+0530",
            "serverTime": "2022-02-15T10:54:09.906+0530",
            "scmInfo": "831671b3b59f40b5108ef3f9491df89a1317ecaa",
            "serverTitle": "Jira",
            "defaultLocale": {"locale": "en_US"},
        },
    )
    responses.add(
        "GET",
        f"{url}/rest/api/2/project/HEL",
        json={
            "expand": "description,lead,issueTypes,url,projectKeys,permissions,insight",
            "self": "https://udit-pandey.atlassian.net/rest/api/2/project/10000",
            "id": "10000",
            "key": "HEL",
            "description": "",
            "lead": {
                "self": "https://udit-pandey.atlassian.net/rest/api/2/user?accountId=6205e1585d18ad00729aa75f",
                "accountId": "6205e1585d18ad00729aa75f",
                "avatarUrls": {
                    "48x48": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "24x24": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "16x16": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                    "32x32": "https://secure.gravatar.com/avatar/6864b14113f03cbe6d55af5006b12efe?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FUP-0.png",
                },
                "displayName": "Udit Pandey",
                "active": True,
            },
            "components": [],
            "issueTypes": [
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10001",
                    "id": "10001",
                    "description": "A small, distinct piece of work.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10318?size=medium",
                    "name": "Task",
                    "subtask": False,
                    "avatarId": 10318,
                    "hierarchyLevel": 0,
                },
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10002",
                    "id": "10002",
                    "description": "A collection of related bugs, stories, and tasks.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10307?size=medium",
                    "name": "Epic",
                    "subtask": False,
                    "avatarId": 10307,
                    "hierarchyLevel": 1,
                },
                {
                    "self": "https://udit-pandey.atlassian.net/rest/api/2/issuetype/10003",
                    "id": "10003",
                    "description": "Subtasks track small pieces of work that are part of a larger task.",
                    "iconUrl": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/issuetype/avatar/10316?size=medium",
                    "name": "Subtask",
                    "subtask": True,
                    "avatarId": 10316,
                    "hierarchyLevel": -1,
                },
            ],
            "assigneeType": "UNASSIGNED",
            "versions": [],
            "name": "helicopter",
            "roles": {
                "atlassian-addons-project-access": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10007",
                "Administrator": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10004",
                "Viewer": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10006",
                "Member": "https://udit-pandey.atlassian.net/rest/api/2/project/10000/role/10005",
            },
            "avatarUrls": {
                "48x48": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408",
                "24x24": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=small",
                "16x16": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=xsmall",
                "32x32": "https://udit-pandey.atlassian.net/rest/api/2/universal_avatar/view/type/project/avatar/10408?size=medium",
            },
            "projectTypeKey": "software",
            "simplified": True,
            "style": "next-gen",
            "isPrivate": False,
            "properties": {},
            "entityId": "8a851ebf-72eb-461d-be68-4c2c28805440",
            "uuid": "8a851ebf-72eb-461d-be68-4c2c28805440",
        },
    )
    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


@patch("kairon.shared.actions.utils.ActionUtility.get_jira_client", autospec=True)
@patch("kairon.shared.actions.utils.ActionUtility.validate_jira_action", autospec=True)
def test_edit_jira_action_different_parameter_type(mock_jira_client, mock_validate):
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action_slot",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"

    action = {
        "name": "jira_action_key_vault",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL", "parameter_type": "slot"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated"


@patch("kairon.shared.actions.utils.ActionUtility", autospec=True)
def test_edit_jira_action_invalid_parameter_type(mock_jira):
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action_slot",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL", "parameter_type": "chat_log"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_edit_jira_action_invalid_config(monkeypatch):
    url = "https://test_edit_jira_action_invalid_config.net"
    action = {
        "name": "jira_action",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    monkeypatch.setattr(ActionUtility, "get_jira_client", _mock_error)
    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == "JiraError HTTP 404 url: https://test1-digite.atlassian.net\n\t"
    )


def test_edit_jira_action_not_found():
    url = "https://test-digite.atlassian.net"
    action = {
        "name": "jira_action_new",
        "url": url,
        "user_name": "test@digite.com",
        "api_token": {"value": "ASDFGHJKL"},
        "project_key": "HEL",
        "issue_type": "Bug",
        "summary": "new user",
        "response": "We have logged a ticket",
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/jira",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "jira_action_new" not found'


def test_add_zendesk_action_invalid_config(monkeypatch):
    def __mock_zendesk_error(*args, **kwargs):
        from zenpy.lib.exception import APIException

        raise APIException(
            {"error": {"title": "No help desk at digite751.zendesk.com"}}
        )

    action = {
        "name": "zendesk_action_1",
        "subdomain": "digite751",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy") as mock:
        mock.side_effect = __mock_zendesk_error
        response = client.post(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422
        assert (
                actual["message"]
                == "{'error': {'title': 'No help desk at digite751.zendesk.com'}}"
        )


def test_list_zendesk_action_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/zendesk",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_add_zendesk_action():
    action = {
        "name": "zendesk_action",
        "subdomain": "digite751",
        "api_token": {"value": "123456789"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"


@patch("kairon.shared.actions.data_objects.ZendeskAction.validate", autospec=True)
def test_add_zendesk_action_different_parameter_type(mock_zedesk):
    action = {
        "name": "zendesk_action_slot",
        "subdomain": "digite751",
        "api_token": {"value": "123456789", "parameter_type": "slot"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"

    action = {
        "name": "zendesk_action_key_vault",
        "subdomain": "digite751",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"


def test_add_zendesk_action_invalid_parameter_type():
    action = {
        "name": "zendesk_action_intent",
        "subdomain": "digite751",
        "api_token": {"value": "123456789", "parameter_type": "intent"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422


def test_list_zendesk_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/zendesk",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    [action.pop("_id") for action in actual["data"]]
    assert actual["data"] == [
        {
            "name": "zendesk_action",
            "subdomain": "digite751",
            "user_name": "udit.pandey@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "123456789",
                "parameter_type": "value",
            },
            "subject": "new ticket",
            "response": "ticket filed",
        },
        {
            "name": "zendesk_action_slot",
            "subdomain": "digite751",
            "user_name": "udit.pandey@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "encrypt": False,
                "value": "123456789",
                "parameter_type": "slot",
            },
            "subject": "new ticket",
            "response": "ticket filed",
        },
        {
            "name": "zendesk_action_key_vault",
            "subdomain": "digite751",
            "user_name": "udit.pandey@digite.com",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "encrypt": False,
                "value": "AWS_KEY",
                "parameter_type": "key_vault",
            },
            "subject": "new ticket",
            "response": "ticket filed",
        },
    ]


def test_edit_zendesk_action():
    action = {
        "name": "zendesk_action",
        "subdomain": "digite756",
        "api_token": {"value": "123456789999"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed here",
    }
    with patch("zenpy.Zenpy"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"


@patch("kairon.shared.actions.data_objects.ZendeskAction.validate", autospec=True)
def test_edit_zendesk_action_different_parameter_type(mock_zendesk):
    action = {
        "name": "zendesk_action_slot",
        "subdomain": "digite751",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"

    action = {
        "name": "zendesk_action_key_vault",
        "subdomain": "digite751",
        "api_token": {"value": "123456789", "parameter_type": "slot"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"


def test_edit_zendesk_action_invalid_parameter_type():
    action = {
        "name": "zendesk_action_intent",
        "subdomain": "digite751",
        "api_token": {"value": "123456789", "parameter_type": "intent"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }
    with patch("zenpy.Zenpy"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422


def test_edit_zendesk_action_invalid_config(monkeypatch):
    action = {
        "name": "zendesk_action",
        "subdomain": "digite751",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }

    def __mock_zendesk_error(*args, **kwargs):
        from zenpy.lib.exception import APIException

        raise APIException(
            {"error": {"title": "No help desk at digite751.zendesk.com"}}
        )

    with patch("zenpy.Zenpy") as mock:
        mock.side_effect = __mock_zendesk_error
        response = client.put(
            f"/api/bot/{pytest.bot}/action/zendesk",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422
        assert (
                actual["message"]
                == "{'error': {'title': 'No help desk at digite751.zendesk.com'}}"
        )


def test_edit_zendesk_action_not_found():
    action = {
        "name": "zendesk_action_1",
        "subdomain": "digite751",
        "api_token": {"value": "123456789"},
        "subject": "new ticket",
        "user_name": "udit.pandey@digite.com",
        "response": "ticket filed",
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/zendesk",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "zendesk_action_1" not found'


def test_add_pipedrive_leads_action_invalid_config(monkeypatch):
    def __mock_exception(*args, **kwargs):
        raise UnauthorizedError("Invalid authentication", {"error_code": 401})

    action = {
        "name": "pipedrive_leads",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }
    with patch("pipedrive.client.Client._request", __mock_exception) as mock:
        response = client.post(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422
        assert actual["message"] == "Invalid authentication"


def test_add_pipedrive_leads_name_not_filled(monkeypatch):
    action = {
        "name": "pipedrive_leads",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {"org_name": "organization", "email": "email", "phone": "phone"},
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/pipedrive",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == [
        {"loc": ["body", "metadata"], "msg": "name is required", "type": "value_error"}
    ]


def test_list_pipedrive_actions_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/pipedrive",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_add_pipedrive_action():
    action = {
        "name": "pipedrive_leads",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }
    with patch("pipedrive.client.Client"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"


def test_add_pipedrive_action_different_parameter_types():
    action = {
        "name": "pipedrive_leads_slot",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678", "parameter_type": "slot"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }
    with patch("pipedrive.client.Client"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"

    action = {
        "name": "pipedrive_leads_slot_key_vault",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }
    with patch("pipedrive.client.Client"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action added"


def test_add_pipedrive_action_invalid_parameter_types():
    action = {
        "name": "pipedrive_leads_sender_id",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678", "parameter_type": "intent"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }
    with patch("pipedrive.client.Client"):
        response = client.post(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422


def test_list_pipedrive_action():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/pipedrive",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    [action.pop("_id") for action in actual["data"]]
    assert actual["data"] == [
        {
            "name": "pipedrive_leads",
            "domain": "https://digite751.pipedrive.com/",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "12345678",
                "parameter_type": "value",
            },
            "title": "new lead",
            "metadata": {
                "name": "name",
                "org_name": "organization",
                "email": "email",
                "phone": "phone",
            },
            "response": "I have failed to create lead for you",
        },
        {
            "name": "pipedrive_leads_slot",
            "domain": "https://digite751.pipedrive.com/",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "12345678",
                "parameter_type": "slot",
            },
            "title": "new lead",
            "metadata": {
                "name": "name",
                "org_name": "organization",
                "email": "email",
                "phone": "phone",
            },
            "response": "I have failed to create lead for you",
        },
        {
            "name": "pipedrive_leads_slot_key_vault",
            "domain": "https://digite751.pipedrive.com/",
            "api_token": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_token",
                "encrypt": False,
                "value": "AWS_KEY",
                "parameter_type": "key_vault",
            },
            "title": "new lead",
            "metadata": {
                "name": "name",
                "org_name": "organization",
                "email": "email",
                "phone": "phone",
            },
            "response": "I have failed to create lead for you",
        },
    ]


def test_edit_pipedrive_action():
    action = {
        "name": "pipedrive_leads",
        "domain": "https://digite7.pipedrive.com/",
        "api_token": {"value": "1asdfghjklqwertyuio"},
        "title": "new lead generated",
        "response": "Failed to create lead for you",
        "metadata": {"name": "name"},
    }

    with patch("pipedrive.client.Client"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"


@patch(
    "kairon.shared.actions.data_objects.PipedriveLeadsAction.validate", autospec=True
)
def test_edit_pipedrive_action_different_parameter_type(mock_pipedrive):
    action = {
        "name": "pipedrive_leads_slot",
        "domain": "https://digite7.pipedrive.com/",
        "api_token": {"value": "AWS_KEY", "parameter_type": "key_vault"},
        "title": "new lead generated",
        "response": "Failed to create lead for you",
        "metadata": {"name": "name"},
    }

    with patch("pipedrive.client.Client"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"

    action = {
        "name": "pipedrive_leads_slot_key_vault",
        "domain": "https://digite7.pipedrive.com/",
        "api_token": {"value": "1asdfghjklqwertyuio", "parameter_type": "slot"},
        "title": "new lead generated",
        "response": "Failed to create lead for you",
        "metadata": {"name": "name"},
    }

    with patch("pipedrive.client.Client"):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert actual["success"]
        assert actual["error_code"] == 0
        assert actual["message"] == "Action updated"


def test_edit_pipedrive_action_invalid_parameter_type():
    action = {
        "name": "pipedrive_leads_slot_key_vault",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678", "parameter_type": "intent"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/pipedrive",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_edit_pipedrive_action_invalid_config(monkeypatch):
    action = {
        "name": "pipedrive_leads",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }

    def __mock_exception(*args, **kwargs):
        raise UnauthorizedError("Invalid authentication", {"error_code": 401})

    with patch("pipedrive.client.Client._request", __mock_exception):
        response = client.put(
            f"/api/bot/{pytest.bot}/action/pipedrive",
            json=action,
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        )
        actual = response.json()
        assert not actual["success"]
        assert actual["error_code"] == 422
        assert actual["message"] == "Invalid authentication"


def test_edit_pipedrive_action_not_found():
    action = {
        "name": "pipedrive_action",
        "domain": "https://digite751.pipedrive.com/",
        "api_token": {"value": "12345678"},
        "title": "new lead",
        "response": "I have failed to create lead for you",
        "metadata": {
            "name": "name",
            "org_name": "organization",
            "email": "email",
            "phone": "phone",
        },
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/pipedrive",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "pipedrive_action" not found'


def test_list_razorpay_actions_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/razorpay",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == []


def test_add_razorpay_action():
    action_name = "razorpay_action"
    action = {
        "name": action_name,
        "api_key": {"value": "API_KEY", "parameter_type": "key_vault"},
        "api_secret": {"value": "API_SECRET", "parameter_type": "key_vault"},
        "amount": {"value": "amount", "parameter_type": "slot"},
        "currency": {"value": "INR", "parameter_type": "value"},
        "username": {"parameter_type": "sender_id"},
        "email": {"parameter_type": "sender_id"},
        "contact": {"value": "contact", "parameter_type": "slot"},
        "notes": [
            {"key": "order_id", "parameter_type": "slot", "value": "order_id"},
            {"key": "phone_number", "parameter_type": "value", "value": "9876543210"}
        ]
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"


def test_add_razorpay_action_with_required_values_only():
    action_name = "razorpay_action_required_values_only"
    action = {
        "name": action_name,
        "api_key": {"value": "API_KEY", "parameter_type": "value"},
        "api_secret": {"value": "API_SECRET", "parameter_type": "value"},
        "amount": {"value": "amount", "parameter_type": "value"},
        "currency": {"value": "INR", "parameter_type": "slot"},
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"


def test_add_razorpay_action_without_required_values():
    action_name = "razorpay_action_required_values_only"
    action = {
        "name": action_name,
        "amount": {"value": "amount", "parameter_type": "value"},
        "currency": {"value": "INR", "parameter_type": "slot"},
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "api_key"],
            "msg": "field required",
            "type": "value_error.missing",
        },
        {
            "loc": ["body", "api_secret"],
            "msg": "field required",
            "type": "value_error.missing",
        },
    ]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_list_razorpay_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/razorpay",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    [v.pop("timestamp") for v in actual["data"]]
    [action.pop("_id") for action in actual["data"]]
    assert actual["data"] == [
        {
            "name": "razorpay_action",
            "api_key": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_key",
                "encrypt": False,
                "value": "API_KEY",
                "parameter_type": "key_vault",
            },
            "api_secret": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_secret",
                "encrypt": False,
                "value": "API_SECRET",
                "parameter_type": "key_vault",
            },
            "amount": {
                "_cls": "CustomActionRequestParameters",
                "key": "amount",
                "encrypt": False,
                "value": "amount",
                "parameter_type": "slot",
            },
            "currency": {
                "_cls": "CustomActionRequestParameters",
                "key": "currency",
                "encrypt": False,
                "value": "INR",
                "parameter_type": "value",
            },
            "username": {
                "_cls": "CustomActionRequestParameters",
                "key": "username",
                "encrypt": False,
                "parameter_type": "sender_id",
            },
            "email": {
                "_cls": "CustomActionRequestParameters",
                "key": "email",
                "encrypt": False,
                "parameter_type": "sender_id",
            },
            "contact": {
                "_cls": "CustomActionRequestParameters",
                "key": "contact",
                "encrypt": False,
                "value": "contact",
                "parameter_type": "slot",
            },
            "notes": [
                {
                    '_cls': 'CustomActionRequestParameters',
                    'key': 'order_id',
                    'encrypt': False,
                    'value': 'order_id',
                    'parameter_type': 'slot'
                },
                {
                    '_cls': 'CustomActionRequestParameters',
                    'key': 'phone_number',
                    'encrypt': False,
                    'value': '9876543210',
                    'parameter_type': 'value'
                }
            ]
        },
        {
            "name": "razorpay_action_required_values_only",
            "api_key": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_key",
                "encrypt": False,
                "value": "API_KEY",
                "parameter_type": "value",
            },
            "api_secret": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_secret",
                "encrypt": False,
                "value": "API_SECRET",
                "parameter_type": "value",
            },
            "amount": {
                "_cls": "CustomActionRequestParameters",
                "key": "amount",
                "encrypt": False,
                "value": "amount",
                "parameter_type": "value",
            },
            "currency": {
                "_cls": "CustomActionRequestParameters",
                "key": "currency",
                "encrypt": False,
                "value": "INR",
                "parameter_type": "slot",
            },
            "notes": []
        },
    ]
    assert actual["success"]
    assert actual["error_code"] == 0


def test_edit_razorpay_action():
    action_name = "razorpay_action"
    action = {
        "name": action_name,
        "api_key": {"value": "API_KEY", "parameter_type": "key_vault"},
        "api_secret": {"value": "API_SECRET", "parameter_type": "key_vault"},
        "amount": {"value": "amount", "parameter_type": "value"},
        "currency": {"value": "INR", "parameter_type": "slot"},
        "email": {"parameter_type": "sender_id"},
        "contact": {"value": "contact", "parameter_type": "value"},
        "notes": [
            {"key": "phone_number", "parameter_type": "value", "value": "9876543210"}
        ]
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"


def test_list_razorpay_actions_after_update():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/razorpay",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    [v.pop("timestamp") for v in actual["data"]]
    [action.pop("_id") for action in actual["data"]]
    print(actual["data"])
    assert actual["data"] == [
        {
            "name": "razorpay_action",
            "api_key": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_key",
                "encrypt": False,
                "value": "API_KEY",
                "parameter_type": "key_vault",
            },
            "api_secret": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_secret",
                "encrypt": False,
                "value": "API_SECRET",
                "parameter_type": "key_vault",
            },
            "amount": {
                "_cls": "CustomActionRequestParameters",
                "key": "amount",
                "encrypt": False,
                "value": "amount",
                "parameter_type": "value",
            },
            "currency": {
                "_cls": "CustomActionRequestParameters",
                "key": "currency",
                "encrypt": False,
                "value": "INR",
                "parameter_type": "slot",
            },
            "email": {
                "_cls": "CustomActionRequestParameters",
                "key": "email",
                "encrypt": False,
                "parameter_type": "sender_id",
            },
            "contact": {
                "_cls": "CustomActionRequestParameters",
                "key": "contact",
                "encrypt": False,
                "value": "contact",
                "parameter_type": "value",
            },
            "notes": [
                {
                    '_cls': 'CustomActionRequestParameters',
                    'key': 'phone_number',
                    'encrypt': False,
                    'value': '9876543210',
                    'parameter_type': 'value'
                }
            ]
        },
        {
            "name": "razorpay_action_required_values_only",
            "api_key": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_key",
                "encrypt": False,
                "value": "API_KEY",
                "parameter_type": "value",
            },
            "api_secret": {
                "_cls": "CustomActionRequestParameters",
                "key": "api_secret",
                "encrypt": False,
                "value": "API_SECRET",
                "parameter_type": "value",
            },
            "amount": {
                "_cls": "CustomActionRequestParameters",
                "key": "amount",
                "encrypt": False,
                "value": "amount",
                "parameter_type": "value",
            },
            "currency": {
                "_cls": "CustomActionRequestParameters",
                "key": "currency",
                "encrypt": False,
                "value": "INR",
                "parameter_type": "slot",
            },
            "notes": []
        },
    ]
    assert actual["success"]
    assert actual["error_code"] == 0

def test_edit_razorpay_action_required_config_missing():
    action_name = "razorpay_action"
    action = {
        "name": action_name,
        "email": {"parameter_type": "sender_id"},
        "contact": {"value": "contact", "parameter_type": "value"},
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "api_key"],
            "msg": "field required",
            "type": "value_error.missing",
        },
        {
            "loc": ["body", "api_secret"],
            "msg": "field required",
            "type": "value_error.missing",
        },
        {
            "loc": ["body", "amount"],
            "msg": "field required",
            "type": "value_error.missing",
        },
        {
            "loc": ["body", "currency"],
            "msg": "field required",
            "type": "value_error.missing",
        },
    ]
    assert not actual["success"]
    assert actual["error_code"] == 422


def test_edit_razorpay_action_not_found():
    action_name = "new_razorpay_action"
    action = {
        "name": action_name,
        "api_key": {"value": "API_KEY", "parameter_type": "key_vault"},
        "api_secret": {"value": "API_SECRET", "parameter_type": "key_vault"},
        "amount": {"value": "amount", "parameter_type": "value"},
        "currency": {"value": "INR", "parameter_type": "slot"},
        "email": {"parameter_type": "sender_id"},
        "contact": {"value": "contact", "parameter_type": "value"},
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/action/razorpay",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == 'Action with name "new_razorpay_action" not found'


def test_delete_razorpay_action():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/action/razorpay_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"]
    assert actual["success"]


def test_get_fields_for_integrated_actions():
    response = client.get(
        f"/api/bot/{pytest.bot}/action/fields/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["pipedrive"] == {
        "required_fields": ["name"],
        "optional_fields": ["org_name", "email", "phone"],
    }


def test_channels_params():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/params",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert "slack" in list(actual["data"].keys())
    assert [
               "bot_user_oAuth_token",
               "slack_signing_secret",
               "client_id",
               "client_secret",
           ] == actual["data"]["slack"]["required_fields"]
    assert ["slack_channel", "team", "is_primary"] == actual["data"]["slack"][
        "optional_fields"
    ]
    assert ["team", "is_primary"] == actual["data"]["slack"]["disabled_fields"]


def test_get_channel_endpoint_not_configured():
    response = client.get(
        f"/api/bot/{pytest.bot}/channels/slack/endpoint",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Channel not configured"

def test_add_instagram_channel():
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json={
            "connector_type": "instagram",
            "config": {
                "app_secret": "98730987654321",
                "page_access_token": "accessangtoken",
                "verify_token": "tokenvld",
                "static_comment_reply": "welcome"
            }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is True
    assert actual["data"]
    assert 'Channel' in actual["message"]

def test_missing_valid_config_instagram_channel():
    response = client.post(
        f"/api/bot/{pytest.bot}/channels/add",
        json={
            "connector_type": "instagram",
            "config": {
                "app_secret": "98730987654321",
                "page_access_token": "accessangtoken",
                "static_comment_reply": "welcome"
            }
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"] is False
    assert actual["data"] is None
    assert "verify_token" in actual["message"][0]["msg"]

def test_add_asset(monkeypatch):
    def __mock_file_upload(*args, **kwargs):
        return "https://kairon.s3.amazonaws.com/application/626a380d3060cf93782b52c3/actions_yml.yml"

    monkeypatch.setattr(CloudUtility, "upload_file", __mock_file_upload)
    monkeypatch.setitem(
        Utility.environment["storage"]["assets"], "allowed_extensions", [".yml"]
    )

    file = {"asset": open("tests/testing_data/valid_yml/actions.yml", "rb")}
    response = client.put(
        f"/api/bot/{pytest.bot}/assets/actions_yml",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert (
            actual["data"]["url"]
            == "https://kairon.s3.amazonaws.com/application/626a380d3060cf93782b52c3/actions_yml.yml"
    )
    assert actual["message"] == "Asset added"


def test_add_asset_failure(monkeypatch):
    def __mock_file_upload(*args, **kwargs):
        api_resp = {
            "Error": {"Code": "400", "Message": "Bad Request"},
            "ResponseMetadata": {
                "RequestId": "BQFVQHD1KSD5V6RZ",
                "HostId": "t2uudD7x2V+rRHO4dp2XBqdmAOaWwlnsII7gs1JbYcrntVKRaZSpHxNPJEww+s5dCzCQOg2uero=",
                "HTTPStatusCode": 400,
                "HTTPHeaders": {
                    "x-amz-bucket-region": "us-east-1",
                    "x-amz-request-id": "BQFVQHD1KSD5V6RZ",
                    "x-amz-id-2": "t2uudD7x2V+rRHO4dp2XBqdmAOaWwlnsII7gs1JbYcrntVKRaZSpHxNPJEww+s5dCzCQOg2uero=",
                    "content-type": "application/xml",
                    "date": "Wed, 27 Apr 2022 08:53:05 GMT",
                    "server": "AmazonS3",
                    "connection": "close",
                },
                "RetryAttempts": 3,
            },
        }
        raise ClientError(api_resp, "PutObject")

    monkeypatch.setattr(CloudUtility, "upload_file", __mock_file_upload)
    monkeypatch.setitem(
        Utility.environment["storage"]["assets"], "allowed_extensions", [".yml"]
    )

    file = {"asset": open("tests/testing_data/valid_yml/actions.yml", "rb")}
    response = client.put(
        f"/api/bot/{pytest.bot}/assets/actions_yml",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=file,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "File upload failed"


def test_list_assets():
    response = client.get(
        f"/api/bot/{pytest.bot}/assets",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["assets"] == [
        {
            "asset_type": "actions_yml",
            "url": "https://kairon.s3.amazonaws.com/application/626a380d3060cf93782b52c3/actions_yml.yml",
        }
    ]


def test_delete_asset(monkeypatch):
    def __mock_delete_file(*args, **kwargs):
        return None

    monkeypatch.setattr(CloudUtility, "delete_file", __mock_delete_file)

    response = client.delete(
        f"/api/bot/{pytest.bot}/assets/actions_yml",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Asset deleted"


def test_delete_asset_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/assets/actions_yml",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Asset does not exists"


def test_list_assets_not_exists():
    response = client.get(
        f"/api/bot/{pytest.bot}/assets",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["assets"] == []


def test_get_live_agent_config_params():
    response = client.get(
        f"/api/bot/{pytest.bot}/agents/live/params",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == Utility.system_metadata["live_agents"]


def test_get_live_agent_config_none():
    response = client.get(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["agent"] is None


@responses.activate
def test_add_live_agent_config_agent_not_supported():
    config = {
        "agent_type": "livechat",
        "config": {"account_id": "12", "api_access_token": "asdfghjklty67"},
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }

    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == [
        {
            "loc": ["body", "agent_type"],
            "msg": "Agent system not supported",
            "type": "value_error",
        }
    ]


@responses.activate
def test_add_live_agent_config_required_fields_not_exists():
    config = {
        "agent_type": "chatwoot",
        "config": {"api_access_token": "asdfghjklty67"},
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == [
        {
            "loc": ["body", "config"],
            "msg": "Missing ['api_access_token', 'account_id'] all or any in config",
            "type": "value_error",
        }
    ]

    config = {
        "agent_type": "chatwoot",
        "config": {"account_id": "12"},
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == [
        {
            "loc": ["body", "config"],
            "msg": "Missing ['api_access_token', 'account_id'] all or any in config",
            "type": "value_error",
        }
    ]


@responses.activate
def test_add_live_agent_config_invalid_credentials():
    config = {
        "agent_type": "chatwoot",
        "config": {"account_id": "12", "api_access_token": "asdfghjklty67"},
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }

    responses.add(
        "GET",
        f"https://app.chatwoot.com/public/api/v1/accounts/{config['config']['account_id']}/inboxes",
        status=404,
        body="Not found",
    )
    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == "Unable to connect. Please verify credentials."


@responses.activate
def test_add_live_agent_config_triggers_not_added():
    config = {
        "agent_type": "chatwoot",
        "config": {"account_id": "12", "api_access_token": "asdfghjklty67"},
        "override_bot": False,
    }

    add_inbox_response = open(
        "tests/testing_data/live_agent/add_inbox_response.json"
    ).read()
    add_inbox_response = json.loads(add_inbox_response)
    responses.add(
        "GET",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json={"payload": []},
    )
    responses.add(
        "POST",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json=add_inbox_response,
    )

    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == [
        {
            "loc": ["body", "override_bot"],
            "msg": "At least 1 intent or action is required to perform agent handoff",
            "type": "value_error",
        }
    ]

    config = {
        "agent_type": "chatwoot",
        "config": {"account_id": "12", "api_access_token": "asdfghjklty67"},
        "override_bot": False,
        "trigger_on_intents": [],
        "trigger_on_actions": [],
    }
    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert not actual["data"]
    assert actual["message"] == [
        {
            "loc": ["body", "override_bot"],
            "msg": "At least 1 intent or action is required to perform agent handoff",
            "type": "value_error",
        }
    ]


@responses.activate
def test_add_live_agent_config():
    config = {
        "agent_type": "chatwoot",
        "config": {"account_id": "12", "api_access_token": "asdfghjklty67"},
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }

    add_inbox_response = open(
        "tests/testing_data/live_agent/add_inbox_response.json"
    ).read()
    add_inbox_response = json.loads(add_inbox_response)
    responses.add(
        "GET",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json={"payload": []},
    )
    responses.add(
        "POST",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json=add_inbox_response,
    )

    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Live agent system added"


def test_get_live_agent_config():
    response = client.get(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    add_inbox_response = open(
        "tests/testing_data/live_agent/add_inbox_response.json"
    ).read()
    add_inbox_response = json.loads(add_inbox_response)
    assert actual["data"]["agent"]
    actual["data"]["agent"].pop("timestamp")
    assert actual["data"]["agent"] == {
        "agent_type": "chatwoot",
        "config": {
            "account_id": "***",
            "api_access_token": "asdfghjklt***",
            "inbox_identifier": add_inbox_response["inbox_identifier"],
        },
        "override_bot": False,
        "trigger_on_intents": ["greet", "enquiry"],
        "trigger_on_actions": ["action_default_fallback", "action_enquiry"],
    }


@responses.activate
def test_update_live_agent_config():
    add_inbox_response = open(
        "tests/testing_data/live_agent/add_inbox_response.json"
    ).read()
    add_inbox_response = json.loads(add_inbox_response)
    add_inbox_response["inbox_identifier"] = "sdghghj5466789fghjk"
    list_inbox_response = open(
        "tests/testing_data/live_agent/list_inboxes_response.json"
    ).read()
    list_inbox_response = json.loads(list_inbox_response)
    list_inbox_response["payload"][1]["inbox_identifier"] = add_inbox_response[
        "inbox_identifier"
    ]
    config = {
        "agent_type": "chatwoot",
        "config": {
            "account_id": "13",
            "api_access_token": "jfjdjhsk567890",
            "inbox_identifier": add_inbox_response["inbox_identifier"],
        },
        "override_bot": True,
    }
    responses.add(
        "GET",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json=list_inbox_response,
    )
    responses.add(
        "POST",
        f"https://app.chatwoot.com/api/v1/accounts/{config['config']['account_id']}/inboxes",
        json=add_inbox_response,
    )

    response = client.put(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json=config,
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Live agent system added"


def test_get_live_agent_config_after_update():
    response = client.get(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["agent"]
    actual["data"]["agent"].pop("timestamp")
    assert actual["data"]["agent"] == {
        "agent_type": "chatwoot",
        "config": {
            "account_id": "***",
            "api_access_token": "jfjdjhsk567***",
            "inbox_identifier": "sdghghj5466789fghjk",
        },
        "override_bot": True,
        "trigger_on_intents": [],
        "trigger_on_actions": [],
    }


def test_delete_live_agent_config():
    response = client.delete(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Live agent system deleted"


def test_get_live_agent_config_after_delete():
    response = client.get(
        f"/api/bot/{pytest.bot}/agents/live",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["agent"] is None


def test_get_end_user_metrics_empty():
    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/prod_chat?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["logs"] == []
    assert actual["data"]["total"] == 0


def test_add_end_user_metrics():
    log_type = "user_metrics"
    response = client.post(
        f"/api/bot/{pytest.bot}/metric/user/logs/{log_type}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": {"source": "Digite.com", "language": "English"}},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert "id" in actual["data"]


@responses.activate
def test_add_end_user_metrics_with_ip(monkeypatch):
    log_type = "user_metrics"
    ip = "192.222.100.106"
    token = "abcgd563"
    enable = True
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "token", token)
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "enable", enable)
    ip_list = [ip.strip() for ip in ip.split(",")]
    url = f"https://ipinfo.io/batch?token={token}"
    payload = json.dumps(ip_list)
    expected = {
        "140.82.201.129": {
            "ip": "140.82.201.129",
            "city": "Mumbai",
            "region": "Maharashtra",
            "country": "IN",
            "loc": "19.0728,72.8826",
            "org": "AS13150 CATO NETWORKS LTD",
            "postal": "400070",
            "timezone": "Asia/Kolkata",
        }
    }
    responses.add("POST", url, json=expected)
    response = client.post(
        f"/api/bot/{pytest.bot}/metric/user/logs/{log_type}",
        headers={
            "Authorization": pytest.token_type + " " + pytest.access_token,
            "X-Forwarded-For": "192.222.100.106",
        },
        json={"data": {"source": "Digite.com", "language": "English", "ip": ip}},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert "id" in actual["data"]


@responses.activate
def test_add_end_user_metrics_ip_request_failure(monkeypatch):
    log_type = "user_metrics"
    ip = "192.222.100.106"
    token = "abcgd563"
    enable = True
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "token", token)
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "enable", enable)
    url = f"https://ipinfo.io/{ip}?token={token}"
    responses.add("GET", url, status=500)
    response = client.post(
        f"/api/bot/{pytest.bot}/metric/user/logs/{log_type}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": {"source": "Digite.com", "language": "English"}},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert "id" in actual["data"]


def test_add_and_update_conversation_feedback(monkeypatch):
    log_type = "conversation_feedback"
    data = {
        "feedback": "",
        "rating": 1,
        "botId": "6322ebbb3c62158dab4aee71",
        "botReply": [{"text": "Hello! How are you?"}],
        "userReply": "",
        "date": "2023-07-17T06:48:02.453Z",
        "sender_id": None,
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/metric/user/logs/{log_type}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": data},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert "id" in actual["data"]
    assert actual["message"] == "Metrics added"
    id = actual["data"]["id"]

    response = client.put(
        f"/api/bot/{pytest.bot}/metric/user/logs/{log_type}/{id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        json={"data": {"feedback": "Good"}},
    )

    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Metrics updated"


@responses.activate
def test_get_end_user_metrics(monkeypatch):
    token = "abcgd563"
    enable = True
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "token", token)
    monkeypatch.setitem(Utility.environment["plugins"]["location"], "enable", enable)
    url = f"https://ipinfo.io/batch?token={token}"

    expected = {
        "140.82.201.129": {
            "ip": "140.82.201.129",
            "city": "Mumbai",
            "region": "Maharashtra",
            "country": "IN",
            "loc": "19.0728,72.8826",
            "org": "AS13150 CATO NETWORKS LTD",
            "postal": "400070",
            "timezone": "Asia/Kolkata",
        }
    }
    responses.add("POST", url, json=expected)
    for i in range(5):
        client.post(
            f"/api/bot/{pytest.bot}/metric/user/logs/{MetricType.agent_handoff}",
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
            json={"data": {"source": "Digite.com", "language": "English"}},
        )

    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/agent_handoff?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]["logs"]) == 5
    assert actual["data"]["total"] == 5

    from_date = date.today()
    to_date = from_date + timedelta(days=1)
    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/agent_handoff/search?from_date={from_date}&to_date={to_date}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    response_json = search_response.json()
    print("agent", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)
    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/user_metrics?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 5
    assert actual["data"]["total"] == 5
    actual["data"]["logs"][0].pop("timestamp")
    actual["data"]["logs"][0].pop("account")
    assert actual["data"]["logs"][0] == {
        "metric_type": "user_metrics",
        "user": "integ1@gmail.com",
        "bot": pytest.bot,
        "source": "Digite.com",
        "language": "English",
    }
    actual["data"]["logs"][1].pop("timestamp")
    actual["data"]["logs"][1].pop("account")
    actual["data"]["logs"][2].pop("timestamp")
    actual["data"]["logs"][2].pop("account")
    assert actual["data"]["logs"][1]["ip"]
    del actual["data"]["logs"][1]["ip"]
    assert actual["data"]["logs"][1] == {
        "metric_type": "user_metrics",
        "user": "integ1@gmail.com",
        "bot": pytest.bot,
        "source": "Digite.com",
        "language": "English",
        "city": "Mumbai",
        "region": "Maharashtra",
        "country": "IN",
        "loc": "19.0728,72.8826",
        "org": "AS13150 CATO NETWORKS LTD",
        "postal": "400070",
        "timezone": "Asia/Kolkata",
    }
    assert actual["data"]["logs"][2] == {
        "metric_type": "user_metrics",
        "user": "integ1@gmail.com",
        "bot": pytest.bot,
        "source": "Digite.com",
        "language": "English",
    }

    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/agent_handoff?start_idx=3",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0

    response = client.get(
        f"/api/bot/{pytest.bot}/metric/user/logs/agent_handoff?start_idx=3&page_size=1",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 5


def test_get_roles():
    response = client.get(
        f"/api/user/roles/access",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == Utility.system_metadata["roles"]


def test_generate_limited_access_temporary_token():
    response = client.get(
        f"/api/auth/{pytest.bot}/integration/token/temp",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]["access_token"]
    assert actual["data"]["token_type"]
    assert (
            actual["message"]
            == "This token will be shown only once. Please copy this somewhere safe."
               "It is your responsibility to keep the token secret. If leaked, others may have access to your system."
    )
    token = actual["data"]["access_token"]

    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config/{actual['data']['access_token']}",
        headers={"Authorization": pytest.token_type + " " + token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert isinstance(actual["data"], dict)
    assert None == actual.get("data").get("whitelist")

    response = client.get(
        f"/api/bot/{pytest.bot}/slots",
        headers={"Authorization": pytest.token_type + " " + token},
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "Access denied for this endpoint",
        "data": None,
        "error_code": 422,
    }

    response = client.post(
        f"/api/bot/{pytest.bot}/intents",
        json={"data": "happier"},
        headers={"Authorization": pytest.token_type + " " + token},
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "Access denied for this endpoint",
        "data": None,
        "error_code": 422,
    }

    response = client.post(
        "/api/account/bot",
        json={"name": "covid-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response["error_code"] == 0

    response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    bot_2 = response["data"]["account_owned"][1]["_id"]

    response = client.get(
        f"/api/bot/{bot_2}/chat/client/config/{token}",
    )
    actual = response.json()
    assert actual == {
        "success": False,
        "message": "Invalid token",
        "data": None,
        "error_code": 401,
    }


def test_get_client_config_using_uid_invalid_domains(monkeypatch):
    config_path = "./template/chat-client/default-config.json"
    config = json.load(open(config_path))
    config["headers"] = {}
    config["headers"]["X-USER"] = "kairon-user"
    config["whitelist"] = ["kairon.digite.com", "kairon-api.digite.com"]
    client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": config},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    response = client.get(
        pytest.url, headers={"HTTP_REFERER": "http://www.attackers.com"}
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 403
    assert not actual["data"]
    assert actual["message"] == "Domain not registered for kAIron client"


def test_get_client_config_using_uid_valid_domains(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    response = client.get(
        pytest.url, headers={"HTTP_REFERER": "https://kairon-api.digite.com"}
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert None == actual.get("data").get("whitelist")


def test_get_client_config_using_uid_invalid_domains_referer(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    response = client.get(pytest.url, headers={"referer": "http://www.attackers.com"})
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 403
    assert not actual["data"]
    assert actual["message"] == "Domain not registered for kAIron client"


def test_get_client_config_using_uid_valid_domains_referer(monkeypatch):
    monkeypatch.setitem(
        Utility.environment["model"]["agent"], "url", "http://localhost"
    )
    response = client.get(
        pytest.url, headers={"referer": "https://kairon-api.digite.com"}
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert None == actual.get("data").get("whitelist")


def test_save_client_config_invalid_domain_format():
    config_path = "./template/chat-client/default-config.json"
    config = json.load(open(config_path))
    config["headers"] = {}
    config["headers"]["X-USER"] = "kairon-user"
    config["whitelist"] = ["invalid_domain_format"]
    response = client.post(
        f"/api/bot/{pytest.bot}/chat/client/config",
        json={"data": config},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "One of the domain is invalid"


def get_client_config_valid_domain():
    response = client.get(
        f"/api/bot/{pytest.bot}/chat/client/config",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]
    assert actual["data"]["whitelist"] == ["kairon.digite.com", "kairon-api.digite.com"]


def test_multilingual_translate_logs_empty():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/multilingual/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["logs"] == []
    assert actual["data"]["total"] == 0


@responses.activate
def test_multilingual_translate():
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.multilingual}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
        match=[
            responses.matchers.json_params_matcher(
                {
                    "data": {
                        "bot": pytest.bot,
                        "user": "integ1@gmail.com",
                        "dest_lang": "es",
                        "translate_responses": "",
                        "translate_actions": "",
                    },
                    "cron_exp": None,
                    "timezone": None,
                    "run_at": None
                }
            )
        ],
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/multilingual/translate",
        json={
            "dest_lang": "es",
            "translate_responses": False,
            "translate_actions": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert response["success"]
    assert response["message"] == "Bot translation in progress! Check logs."
    assert response["error_code"] == 0
    MultilingualLogProcessor.add_log(
        pytest.bot, "integ1@gmail.com", event_status=EVENT_STATUS.COMPLETED.value, status=STATUSES.SUCCESS.value
    )


def test_multilingual_translate_invalid_bot_id():
    response = client.post(
        f"/api/bot/{pytest.bot + '0'}/multilingual/translate",
        json={
            "dest_lang": "es",
            "translate_responses": False,
            "translate_actions": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert not response["success"]
    assert response["message"] == "Access to bot is denied"
    assert response["error_code"] == 422


def test_multilingual_translate_no_destination_lang():
    response = client.post(
        f"/api/bot/{pytest.bot}/multilingual/translate",
        json={"translate_responses": False, "translate_actions": False},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert not response["success"]
    assert response["message"] == [
        {
            "loc": ["body", "dest_lang"],
            "msg": "field required",
            "type": "value_error.missing",
        }
    ]
    assert response["error_code"] == 422

    response = client.post(
        f"/api/bot/{pytest.bot}/multilingual/translate",
        json={
            "dest_lang": " ",
            "translate_responses": False,
            "translate_actions": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert not response["success"]
    assert response["message"] == [
        {
            "loc": ["body", "dest_lang"],
            "msg": "dest_lang cannot be empty",
            "type": "value_error",
        }
    ]
    assert response["error_code"] == 422


def test_multilingual_translate_limit_exceeded(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.multilingual_limit_per_day = 0
    bot_settings.save()

    response = client.post(
        f"/api/bot/{pytest.bot}/multilingual/translate",
        json={
            "dest_lang": "es",
            "translate_responses": False,
            "translate_actions": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert response["message"] == "Daily limit exceeded."
    assert response["error_code"] == 422
    assert not response["success"]


@responses.activate
def test_multilingual_translate_using_event_with_actions_and_responses(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.multilingual_limit_per_day = 2
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.multilingual}",
    )
    responses.add(
        responses.POST,
        event_url,
        status=200,
        json={"success": True, "message": "Event triggered successfully!"},
        match=[
            responses.matchers.json_params_matcher(
                {
                    "data": {
                        "bot": pytest.bot,
                        "user": "integ1@gmail.com",
                        "dest_lang": "es",
                        "translate_responses": "--translate-responses",
                        "translate_actions": "--translate-actions",
                    },
                    "cron_exp": None,
                    "timezone": None,
                    "run_at": None
                }
            )
        ],
    )

    response = client.post(
        f"/api/bot/{pytest.bot}/multilingual/translate",
        json={
            "dest_lang": "es",
            "translate_responses": True,
            "translate_actions": True,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert response["success"]
    assert response["error_code"] == 0
    assert response["message"] == "Bot translation in progress! Check logs."


def test_multilingual_translate_in_progress():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/multilingual/translate",
        json={
            "dest_lang": "es",
            "translate_responses": False,
            "translate_actions": False,
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    assert response["error_code"] == 422
    assert response["message"] == "Event already in progress! Check logs."
    assert not response["success"]


def test_multilingual_translate_logs():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/multilingual/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        url=f"/api/bot/{pytest.bot}/logs/multilingual?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 2
    assert actual["data"]["total"] == 2
    assert actual["data"]["logs"][0]["d_lang"] == "es"
    assert actual["data"]["logs"][0]["copy_type"] == "Translation"
    assert actual["data"]["logs"][0]["translate_responses"]
    assert actual["data"]["logs"][0]["translate_actions"]
    assert actual["data"]["logs"][0]["event_status"] == "Enqueued"
    assert actual["data"]["logs"][0]["start_timestamp"]
    assert actual["data"]["logs"][1]["d_lang"] == "es"
    assert actual["data"]["logs"][1]["copy_type"] == "Translation"
    assert actual["data"]["logs"][1]["translate_responses"] == False
    assert actual["data"]["logs"][1]["translate_actions"] == False
    assert actual["data"]["logs"][1]["event_status"] == EVENT_STATUS.COMPLETED.value
    assert actual["data"]["logs"][1]["status"] == STATUSES.SUCCESS.value
    assert actual["data"]["logs"][1]["start_timestamp"]
    assert actual["data"]["logs"][1]["end_timestamp"]

    from_date = date.today()
    to_date = from_date + timedelta(days=1)
    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/multilingual/search?from_date={from_date}&to_date={to_date}&status=Success",
        headers={"Authorization": pytest.token_type + ' ' + pytest.access_token},
    )

    response_json = search_response.json()
    print("multilingual", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)

def test_multilingual_language_support(monkeypatch):
    def _mock_supported_languages(*args, **kwargs):
        return {"ab": "Abkhaz",
                "ace": "Acehnese",
                "ach": "Acholi",
                "af": "Afrikaans",
                "sq": "Albanian",
                "alz": "Alur",
                "am": "Amharic",
                "ar": "Arabic",
                "hy": "Armenian",
                "as": "Assamese",
                "awa": "Awadhi",
                "ay": "Aymara"}

    monkeypatch.setattr(
        Translator, "get_supported_languages", _mock_supported_languages
    )

    response = client.get(
        f"/api/user/multilingual/languages",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert response["data"] == {"ab": "Abkhaz",
                                "ace": "Acehnese",
                                "ach": "Acholi",
                                "af": "Afrikaans",
                                "sq": "Albanian",
                                "alz": "Alur",
                                "am": "Amharic",
                                "ar": "Arabic",
                                "hy": "Armenian",
                                "as": "Assamese",
                                "awa": "Awadhi",
                                "ay": "Aymara"}
    assert response["success"]
    assert response["error_code"] == 0


def test_download_logs(monkeypatch):
    start_date = datetime.utcnow()
    end_date = datetime.utcnow() + timedelta(days=1)
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/download/model_training?start_date={start_date}&end_date={end_date}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response == {
        "success": False,
        "message": "Logs not found!",
        "data": None,
        "error_code": 422,
    }


def test_download_logs_with_action_logs(monkeypatch):
    import csv

    start_date = datetime.utcnow()
    end_date = datetime.utcnow() + timedelta(days=1)
    bot = pytest.bot
    request_params = {"key": "value", "key2": "value2"}
    ActionServerLogs(
        intent="intent1",
        action="http_action",
        sender="sender_id",
        timestamp="2021-04-05T07:59:08.771000",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent2",
        action="http_action",
        sender="sender_id",
        url="http://kairon-api.digite.com/api/bot",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent3",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()
    ActionServerLogs(
        intent="intent4",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
    ).save()
    ActionServerLogs(
        intent="intent5",
        action="http_action",
        sender="sender_id",
        request_params=request_params,
        api_response="Response",
        bot_response="Bot Response",
        bot=bot,
        status=STATUSES.FAIL.value,
    ).save()

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/download/action_logs?start_date={start_date}&end_date={end_date}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.content
    csv_content = response.content.decode("utf-8")
    csv_file = csv.reader(csv_content.splitlines())
    action_logs = list(csv_file)
    assert len(action_logs) == 5


def test_get_auditlog_for_user_1():
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.get(
        f"/api/user/auditlog/data",
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )

    actual = response.json()

    assert actual["data"] is not None
    assert actual["data"][0]["action"] == AuditlogActions.ACTIVITY.value
    assert actual["data"][0]["entity"] == "login"
    assert actual["data"][0]["user"] == email

    assert actual["data"][0]["action"] == AuditlogActions.ACTIVITY.value
    assert actual["data"][0]["attributes"][0]["value"] is not None


def test_get_auditlog_for_bot():
    from_date = datetime.utcnow().date() - timedelta(days=1)
    to_date = datetime.utcnow().date() + timedelta(days=1)
    response = client.get(
        f"/api/bot/{pytest.bot}/auditlog/data/{from_date}/{to_date}?start_idx=0&page_size=100",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/audit?from_date={from_date}&to_date={to_date}&start_idx=0&page_size=100",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    audit_log_data = actual["data"]["logs"]

    assert audit_log_data is not None
    actions = [d["action"] for d in audit_log_data]
    from collections import Counter

    counter = Counter(actions)
    assert counter.get(AuditlogActions.SAVE.value) > 5
    assert counter.get(AuditlogActions.SOFT_DELETE.value) >= 3
    assert counter.get(AuditlogActions.UPDATE.value) > 5

    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/audit/search"
        f"?from_date={from_date}&to_date={to_date}"
        f"&start_idx=0&page_size=10",
        headers={"Authorization": f"{pytest.token_type} {pytest.access_token}"},
    )

    response_json = search_response.json()
    print("audit", response_json)
    assert response_json["success"] is True
    assert response_json["error_code"] == 0

    data = response_json["data"]
    assert "logs" in data
    assert isinstance(data["logs"], list)


@mock.patch('kairon.shared.account.activity_log.UserActivityLogger.is_login_within_cooldown_period', autospec=True)
def test_get_auditlog_for_user_2(mock_password_reset):
    def _password_reset(*args, **kwargs):
        return

    mock_password_reset.return_value = _password_reset
    email = "integration@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login_2 = response.json()
    response = client.get(
        f"/api/user/auditlog/data?start_idx=0&page_size=100",
        headers={
            "Authorization": login_2["data"]["token_type"]
                             + " "
                             + login_2["data"]["access_token"]
        },
    )
    actual = response.json()
    audit_log_data = actual["data"]
    assert audit_log_data is not None
    actions = [d["action"] for d in audit_log_data]
    from collections import Counter

    counter = Counter(actions)
    assert counter.get(AuditlogActions.SAVE.value) > 5
    assert counter.get(AuditlogActions.SOFT_DELETE.value) >= 1
    assert counter.get(AuditlogActions.UPDATE.value) > 5

    assert audit_log_data[0]["action"] == AuditlogActions.ACTIVITY.value
    assert audit_log_data[0]["entity"] == "login"
    assert audit_log_data[0]["user"] == email


def test_add_custom_widget():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        json={
            "name": "agtech weekly trends",
            "http_url": "http://agtech.com/trends/1",
            "request_parameters": [
                {"key": "crop_type", "value": "tomato", "parameter_type": "value"},
                {"key": "org", "value": "ORG_NAME", "parameter_type": "key_vault"},
            ],
            "headers": [
                {"key": "client", "value": "kairon", "parameter_type": "value"},
                {
                    "key": "authorization",
                    "value": "AUTH_TOKEN",
                    "parameter_type": "key_vault",
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Widget config added!"
    assert actual["data"]
    pytest.widget_id = actual["data"]
    assert actual["error_code"] == 0


def test_get_custom_widget():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["widgets"] == [
        {
            "name": "agtech weekly trends",
            "http_url": "http://agtech.com/trends/1",
            "request_parameters": [
                {"key": "crop_type", "value": "tomato", "parameter_type": "value"},
                {"key": "org", "value": "ORG_NAME", "parameter_type": "key_vault"},
            ],
            "headers": [
                {"key": "client", "value": "kairon", "parameter_type": "value"},
                {
                    "key": "authorization",
                    "value": "AUTH_TOKEN",
                    "parameter_type": "key_vault",
                },
            ],
            "timeout": 5,
            "bot": pytest.bot,
            "request_method": "GET",
            "_id": pytest.widget_id,
        }
    ]
    assert actual["error_code"] == 0
    assert not actual["message"]


@responses.activate
def test_add_member_with_view_role():
    email = "test_view@demo.ai"
    response = client.post(
        "/api/account/registration",
        json={
            "email": email,
            "first_name": "Dem",
            "last_name": "User22",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": email,
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"
    assert actual["error_code"] == 0
    assert actual["success"]

    response = client.post(
        f"/api/user/{pytest.bot}/member",
        json={"email": email, "role": "view"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"]
    assert actual["error_code"] == 0
    assert actual["success"]

    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "User Authenticated"
    pytest.refresh_token_view_role = actual["data"]["refresh_token"]
    pytest.access_token_view_role = actual["data"]["access_token"]


@responses.activate
def test_trigger_widget():
    expected_query_parameters = {"crop_type": "tomato", "org": "kairon"}
    expected_query_parameters.update(
        {"start_date": "11-11-2021", "end_date": "21-11-2021"}
    )
    expected_resp = {"data": [{"1": 200, "2": 300, "3": 400, "4": 500, "5": 600}]}

    for key_vault in [
        {"key": "ORG_NAME", "value": "kairon"},
        {"key": "AUTH_TOKEN", "value": "sdfghjk456789"},
    ]:
        response = client.post(
            f"/api/bot/{pytest.bot}/secrets/add",
            headers={"Authorization": pytest.token_type + " " + pytest.access_token},
            json=key_vault,
        )
        actual = response.json()
        assert actual["error_code"] == 0
        assert actual["success"]

    responses.add(
        "GET",
        "http://agtech.com/trends/1",
        json=expected_resp,
        match=[
            responses.matchers.query_param_matcher(expected_query_parameters),
            responses.matchers.header_matcher(
                {"client": "kairon", "authorization": "sdfghjk456789"}
            ),
        ],
    )

    # Test with view role
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom/trigger/{pytest.widget_id}?start_date=11-11-2021&end_date=21-11-2021",
        headers={
            "Authorization": pytest.token_type + " " + pytest.access_token_view_role
        },
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == expected_resp
    assert not actual["message"]

    # Test with admin role
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom/trigger/{pytest.widget_id}?start_date=11-11-2021&end_date=21-11-2021",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"] == expected_resp
    assert not actual["message"]

    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom/logs/all",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]) == 2
    assert not actual["message"]


def test_get_llm_logs():
    from kairon.shared.llm.logger import LiteLLMLogger
    import litellm
    import asyncio

    loop = asyncio.new_event_loop()
    user = "test"
    litellm.callbacks = [LiteLLMLogger()]

    messages = [{"role": "user", "content": "Hi"}]
    expected = "Hi, How may i help you?"

    result = loop.run_until_complete(litellm.acompletion(messages=messages,
                                                         model="gpt-4.1-mini",
                                                         mock_response=expected,
                                                         metadata={'user': user, 'bot': pytest.bot}))
    assert result['choices'][0]['message']['content'] == expected

    time.sleep(2)

    response = client.get(
        f"/api/bot/{pytest.bot}/llm/logs?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = client.get(
        f"/api/bot/{pytest.bot}/logs/llm?start_idx=0&page_size=10",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual["data"])
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["data"]

    from_date = datetime.utcnow().date() - timedelta(days=1)
    to_date = datetime.utcnow().date() + timedelta(days=1)
    search_response = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?from_date={from_date}&to_date={to_date}&user=test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = search_response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 1
    assert actual["data"]["logs"][0]['start_time']
    assert actual["data"]["logs"][0]['end_time']
    assert actual["data"]["logs"][0]['cost']
    assert actual["data"]["logs"][0]['llm_call_id']
    assert actual["data"]["logs"][0]["llm_provider"] == "openai"
    assert not actual["data"]["logs"][0].get("model")
    assert actual["data"]["logs"][0]["model_params"] == {}
    assert actual["data"]["logs"][0]["metadata"]['bot'] == pytest.bot
    assert actual["data"]["logs"][0]["metadata"]['user'] == "test"
    assert not actual["data"]["logs"][0].get('response', {}).get("data", None)
    call_id = actual["data"]["logs"][0]['llm_call_id']

    search_with_invocation = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?from_date={from_date}&to_date={to_date}&user=test&invocation=prompt_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = search_with_invocation.json()
    print(actual)
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 0

    search_with_call_id = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?from_date={from_date}&to_date={to_date}&user=test&llm_call_id={call_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = search_with_call_id.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 1
    assert actual["data"]["logs"][0]['start_time']
    assert actual["data"]["logs"][0]['end_time']
    assert actual["data"]["logs"][0]['cost']
    assert actual["data"]["logs"][0]['llm_call_id']
    assert actual["data"]["logs"][0]["llm_provider"] == "openai"
    assert not actual["data"]["logs"][0].get("model")
    assert actual["data"]["logs"][0]["model_params"] == {}
    assert actual["data"]["logs"][0]["metadata"]['bot'] == pytest.bot
    assert actual["data"]["logs"][0]["metadata"]['user'] == "test"
    assert not actual["data"]["logs"][0].get('response', {}).get("data", None)

    llm_call_id_param = f"'{call_id}'"
    search_with_call_id = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?from_date={from_date}&to_date={to_date}&user=test&llm_call_id={llm_call_id_param}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = search_with_call_id.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 1
    assert actual["data"]["logs"][0]['start_time']
    assert actual["data"]["logs"][0]['end_time']
    assert actual["data"]["logs"][0]['cost']
    assert actual["data"]["logs"][0]['llm_call_id']
    assert actual["data"]["logs"][0]["llm_provider"] == "openai"
    assert not actual["data"]["logs"][0].get("model")
    assert actual["data"]["logs"][0]["model_params"] == {}
    assert actual["data"]["logs"][0]["metadata"]['bot'] == pytest.bot
    assert actual["data"]["logs"][0]["metadata"]['user'] == "test"
    assert not actual["data"]["logs"][0].get('response', {}).get("data", None)

    llm_call_id_param = [call_id]

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?"
        f"from_date={from_date}&to_date={to_date}&user=test&llm_call_id={llm_call_id_param}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 1

    log = actual["data"]["logs"][0]
    assert log["llm_call_id"] == call_id
    assert log["metadata"]["bot"] == pytest.bot
    assert log["metadata"]["user"] == "test"

    llm_call_id_param = f"['{call_id}']"

    response = client.get(
        f"/api/bot/{pytest.bot}/logs/llm/search?"
        f"from_date={from_date}&to_date={to_date}&user=test&llm_call_id={llm_call_id_param}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    assert len(actual["data"]["logs"]) == 1
    assert actual["data"]["total"] == 1

    log = actual["data"]["logs"][0]
    assert log["llm_call_id"] == call_id
    assert log["metadata"]["bot"] == pytest.bot
    assert log["metadata"]["user"] == "test"


def test_add_custom_widget_invalid_config():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        json={
            "name": "agtech weekly trends 1",
            "http_url": "http://agtech.com/trends/1",
            "request_parameters": [
                {"key": "crop_type", "value": "tomato", "parameter_type": "sender_id"},
                {"key": "org", "value": "ORG_NAME", "parameter_type": "key_vault"},
            ],
            "headers": [
                {"key": "client", "value": "kairon", "parameter_type": "value"},
                {
                    "key": "authorization",
                    "value": "AUTH_TOKEN",
                    "parameter_type": "key_vault",
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "ctx": {"enum_values": ["value", "key_vault"]},
            "loc": ["body", "request_parameters", 0, "parameter_type"],
            "msg": "value is not a valid enumeration member; permitted: 'value', 'key_vault'",
            "type": "type_error.enum",
        }
    ]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_add_custom_widget_already_exists():
    response = client.post(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        json={
            "name": "agtech weekly trends",
            "http_url": "http://agtech.com/trends/1",
            "request_parameters": [
                {"key": "crop_type", "value": "tomato", "parameter_type": "value"},
                {"key": "org", "value": "ORG_NAME", "parameter_type": "key_vault"},
            ],
            "headers": [
                {"key": "client", "value": "kairon", "parameter_type": "value"},
                {
                    "key": "authorization",
                    "value": "AUTH_TOKEN",
                    "parameter_type": "key_vault",
                },
            ],
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Widget with name exists!"
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_edit_custom_widget_invalid_config():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/widgets/custom/{pytest.widget_id}",
        json={"name": "agtech weekly trends 1", "http_url": None},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == [
        {
            "loc": ["body", "http_url"],
            "msg": "none is not an allowed value",
            "type": "type_error.none.not_allowed",
        }
    ]
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_edit_custom_widget():
    response = client.put(
        url=f"/api/bot/{pytest.bot}/widgets/custom/{pytest.widget_id}",
        json={
            "name": "agtech trends ",
            "http_url": "http://agtech.com/trends",
        },
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Widget config updated!"
    assert not actual["data"]
    assert actual["error_code"] == 0


def test_list_custom_widgets():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom/list",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["widgets"] == [pytest.widget_id]
    assert actual["error_code"] == 0
    assert not actual["message"]


def test_get_custom_widget_post_update():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["widgets"] == [
        {
            "name": "agtech trends ",
            "http_url": "http://agtech.com/trends",
            "timeout": 5,
            "request_method": "GET",
            "request_parameters": [],
            # "_id": pytest.bot,
            "headers": [],
            "bot": pytest.bot,
            "_id": pytest.widget_id,
        }
    ]
    assert actual["error_code"] == 0
    assert not actual["message"]


def test_delete_custom_widget():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/widgets/custom/{pytest.widget_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Widget config removed!"
    assert not actual["data"]
    assert actual["error_code"] == 0


def test_trigger_widget_failure():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom/trigger/{pytest.widget_id}",
        headers={
            "Authorization": pytest.token_type + " " + pytest.access_token_view_role
        },
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert not actual["data"]
    assert actual["message"] == "Widget does not exists!"


def test_delete_custom_widget_invalid_widget_id():
    response = client.delete(
        url=f"/api/bot/{pytest.bot}/widgets/custom/{pytest.widget_id}",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Widget does not exists!"
    assert not actual["data"]
    assert actual["error_code"] == 422


def test_list_custom_widgets_empty():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["data"]["widgets"] == []
    assert actual["error_code"] == 0
    assert not actual["message"]


def test_get_custom_widget_post_delete():
    response = client.get(
        url=f"/api/bot/{pytest.bot}/widgets/custom",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["data"]["widgets"]
    assert actual["error_code"] == 0
    assert not actual["message"]


@responses.activate
def test_upload_invalid_csv():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.faq_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    csv_file = "Questions,Answer,\nWhat is Digite?, IT Company,\nHow are you?, I am good,\nWhat day is it?, It is Thursday,\n   ,  ,\nWhat day is it?, It is Thursday,\n".encode()
    csv_file = BytesIO(csv_file).read()
    files = {"csv_file": ("config.arff", csv_file)}
    response = client.post(
        f"/api/bot/{pytest.bot}/data/faq/upload",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["data"] is None
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"] == "Invalid file type! Only csv and xlsx files are supported."
    )


@responses.activate
def test_upload_faq():
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.data_importer_limit_per_day = 10
    bot_settings.save()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.faq_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )
    csv_file = "Questions,Answer,\nWhat is Digite?, IT Company,\nHow are you?, I am good,\nWhat day is it?, It is Thursday,\n   ,  ,\nWhat day is it?, It is Thursday,\n".encode()
    csv_file = BytesIO(csv_file).read()
    files = {"csv_file": ("config.csv", csv_file)}
    response = client.post(
        f"/api/bot/{pytest.bot}/data/faq/upload?overwrite=false",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["data"] is None
    assert actual["success"]
    assert actual["error_code"] == 0


def test_download_faq(monkeypatch):
    data = [
        {
            "_id": "638dde37cfe8a7de324067fa",
            "story": "accelerator_28",
            "intent": "accelerator_28",
            "utterance": "utter_accelerator_28",
            "training_examples": [
                {
                    "text": "What is the purpose of an acceleration?",
                    "_id": "638dde36cfe8a7de32405eaa",
                },
                {
                    "text": "What is the purpose of an accelerators?",
                    "_id": "638dde36cfe8a7de32405eab",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405ada",
                    "text": {
                        "text": "\tAnything that helps project teams reduce effort, save cost"
                    },
                }
            ],
        },
        {
            "_id": "638dde37cfe8a7de324067fd",
            "story": "accelerator_subscription_mainspring_31",
            "intent": "accelerator_subscription_mainspring_31",
            "utterance": "utter_accelerator_subscription_mainspring_31",
            "training_examples": [
                {
                    "text": "\tHow do I subscribe to accelerators for my project?",
                    "_id": "638dde36cfe8a7de32405ec0",
                },
                {
                    "text": "\tHow to do accelerator subscription in mainspring",
                    "_id": "638dde36cfe8a7de32405ec1",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405b64",
                    "custom": {
                        "custom": {
                            "data": [
                                {
                                    "type": "paragraph",
                                    "children": [
                                        {
                                            "text": "Step 1 : Navigate to PM Plan >> Delivery Assets"
                                        }
                                    ],
                                },
                                {
                                    "type": "paragraph",
                                    "children": [
                                        {
                                            "text": "Step 2 : Subscribe the accelerators which are applicable"
                                        }
                                    ],
                                },
                            ]
                        }
                    },
                }
            ],
        },
        {
            "_id": "638dde37cfe8a7de324067fe",
            "story": "accelerators_auto_recommended_32",
            "intent": "accelerators_auto_recommended_32",
            "utterance": "utter_accelerators_auto_recommended_32",
            "training_examples": [
                {
                    "text": "\tOn what basis are accelerators recommended for a project?",
                    "_id": "638dde36cfe8a7de32405ec3",
                },
                {
                    "text": "\tWhat is the criteria based on which accelerators are auto recommended ?",
                    "_id": "638dde36cfe8a7de32405ec4",
                },
            ],
            "responses": [
                {
                    "_id": "638dde35cfe8a7de32405b2d",
                    "text": {
                        "text": "\tAccelerators are auto-recommended from Knowhub based on these project attributes"
                    },
                }
            ],
        },
    ]

    def __mock_qna(*args, **kwargs):
        for item in data:
            yield item

    monkeypatch.setattr(BaseQuerySet, "aggregate", __mock_qna)
    response = client.get(
        f"/api/bot/{pytest.bot}/data/faq/download",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    assert response.content


def test_add_prompt_action_with_stop_hyperparameters(monkeypatch):
    temp = Utility.get_default_llm_hyperparameters().copy()
    temp['stop'] = 'abc'
    temp['temperature'] = 1.0

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "test_add_prompt_action_with_stop_hyperparameters", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": temp
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    from kairon.shared.actions.data_objects import PromptAction

    action = PromptAction.objects(bot=pytest.bot).get(id=actual["data"]["_id"])
    assert action.hyperparameters['stop'] == 'abc'
    assert action.hyperparameters['temperature'] == 1.0


def test_add_parallel_action_missing_existing_action(monkeypatch):
    script = "bot_response='hello world'"
    request_body = {
        "name": "pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": ["pyscript_action", "prompt_action"]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 422
    assert actual["message"] == "Action with name prompt_action does not exist!"
    assert not actual["success"]
    Actions.objects(name="parallel_action_test").delete()
    Actions.objects(name="pyscript_action").delete()
    ParallelActionConfig.objects(name="parallel_action_test").delete()
    PyscriptActionConfig.objects(name="pyscript_action").delete()


def test_add_parallel_action_empty_actions_list(monkeypatch):

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": []
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"][0]['msg'] == "The 'actions' field must contain at least one action."
    assert actual["message"][0]['type'] == "value_error"
    assert not actual["success"]
    Actions.objects(name="parallel_action_test").delete()
    ParallelActionConfig.objects(name="parallel_action_test").delete()


def test_add_parallel_action_exceeds_max_actions(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.max_actions_per_parallel_action = 2
    bot_settings.save()

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": ["pyscript_action","pyscript_action","pyscript_action"]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == f"Maximum {bot_settings.max_actions_per_parallel_action} actions are allowed in a parallel action."
    assert not actual["success"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.max_actions_per_parallel_action = 5
    bot_settings.save()

    Actions.objects(name="parallel_action_test").delete()
    ParallelActionConfig.objects(name="parallel_action_test").delete()


def test_add_parallel_action_nested_parallel_action(monkeypatch):
    script = "bot_response='hello world'"
    request_body = {
        "name": "pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": ["pyscript_action"]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    parallel_action_nested_request_body = {
        "name": "parallel_action_nested_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": ["pyscript_action", "parallel_action_test"]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_nested_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"][0]['msg'] == "ParallelAction cannot include other parallel actions: ['parallel_action_test']"
    assert actual["message"][0]['type'] == "value_error"
    assert not actual["success"]
    Actions.objects(name="parallel_action_test").delete()
    Actions.objects(name="pyscript_action").delete()
    ParallelActionConfig.objects(name="parallel_action_test").delete()
    PyscriptActionConfig.objects(name="pyscript_action").delete()

def test_add_parallel_action(monkeypatch):
    script= "bot_response='hello world'"
    request_body = {
        "name": "pyscript_action",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    def _mock_get_bot_settings(*args, **kwargs):
        return BotSettings(
            bot=pytest.bot,
            user="integration@demo.ai",
            llm_settings=LLMSettings(enable_faq=True),
        )

    monkeypatch.setattr(MongoProcessor, "get_bot_settings", _mock_get_bot_settings)
    action = {
        "name": "prompt_action", 'user_question': {'type': 'from_user_message'},
        "llm_prompts": [
            {
                "name": "System Prompt",
                "data": "You are a personal assistant.",
                "type": "system",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Similarity Prompt",
                "data": "Bot_collection",
                "instructions": "Answer question based on the context above, if answer is not in the context go check previous logs.",
                "type": "user",
                "source": "bot_content",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "A programming language is a system of notation for writing computer programs.[1] Most programming languages are text-based formal languages, but they may also be graphical. They are a kind of computer language.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
            {
                "name": "Query Prompt",
                "data": "If there is no specific query, assume that user is aking about java programming.",
                "instructions": "Answer according to the context",
                "type": "query",
                "source": "static",
                "is_enabled": True,
            },
        ],
        "instructions": ["Answer in a short manner.", "Keep it simple."],
        "num_bot_responses": 5,
        "failure_message": DEFAULT_NLU_FALLBACK_RESPONSE,
        "llm_type": DEFAULT_LLM,
        "hyperparameters": Utility.get_default_llm_hyperparameters()
    }
    response = client.post(
        f"/api/bot/{pytest.bot}/action/prompt",
        json=action,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["message"] == "Action Added Successfully"
    assert actual["data"]["_id"]
    pytest.action_id = actual["data"]["_id"]
    assert actual["success"]
    assert actual["error_code"] == 0

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": False,
        "actions": ["pyscript_action", "prompt_action"]
    }

    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]


def test_update_parallel_action(monkeypatch):
    script = "bot_response='hello world'"
    request_body = {
        "name": "pyscript_action_2",
        "source_code": script,
        "dispatch_response": False,
    }
    response = client.post(
        url=f"/api/bot/{pytest.bot}/action/pyscript",
        json=request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["message"] == "Action added!"
    assert actual["success"]

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": True,
        "actions": ["pyscript_action", "prompt_action", "pyscript_action_2"]
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    print(actual)
    assert actual["error_code"] == 0
    assert actual["message"] == "Action updated!"
    assert actual["success"]

    config = ParallelActionConfig.objects(name="parallel_action_test").first()
    assert config is not None

    config = config.to_mongo().to_dict()
    assert config["actions"] == ["pyscript_action", "prompt_action", "pyscript_action_2"]
    assert config["dispatch_response_text"] is True

def test_update_parallel_action_empty_action_list(monkeypatch):
    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": True,
        "actions": []
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"][0]['msg'] == "The 'actions' field must contain at least one action."
    assert actual["message"][0]['type'] == "value_error"
    assert not actual["success"]

def test_update_parallel_action_exceeds_max_actions(monkeypatch):
    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.max_actions_per_parallel_action = 2
    bot_settings.save()

    parallel_action_request_body = {
        "name": "parallel_action_test",
        "response_text": "Parallel Action Success",
        "dispatch_response_text": True,
        "actions": ["pyscript_action","pyscript_action","pyscript_action"]
    }

    response = client.put(
        url=f"/api/bot/{pytest.bot}/action/parallel",
        json=parallel_action_request_body,
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )

    actual = response.json()
    assert actual["error_code"] == 422
    assert actual["message"] == f"Maximum {bot_settings.max_actions_per_parallel_action} actions are allowed in a parallel action."
    assert not actual["success"]

    bot_settings = BotSettings.objects(bot=pytest.bot).get()
    bot_settings.max_actions_per_parallel_action = 5
    bot_settings.save()

def test_delete_action_used_in_parallel_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/pyscript_action",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert actual["message"] == "Action 'pyscript_action' cannot be deleted because it is used in parallel actions: ['parallel_action_test']"

def test_delete_parallel_action_not_exists():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/parallel_action_test_not_existing",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 422
    assert (
            actual["message"]
            == 'Action with name "parallel_action_test_not_existing" not found'
    )

def test_delete_parallel_action():
    response = client.delete(
        f"/api/bot/{pytest.bot}/action/parallel_action_test",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Action deleted"
    parallel_action_count = ParallelActionConfig.objects(bot = pytest.bot).count()
    assert parallel_action_count == 0
    Actions.objects(name__in=["pyscript_action", "pyscript_action_2", "prompt_action"]).delete()
    PyscriptActionConfig.objects(name__in=["pyscript_action", "pyscript_action_2"]).delete()
    PromptAction.objects(name="prompt_action").delete()


@responses.activate
def test_upload_with_parallel_action():
    ValidationLogs.objects(bot = pytest.bot).delete()
    event_url = urljoin(
        Utility.environment["events"]["server_url"],
        f"/api/events/execute/{EventClass.data_importer}",
    )
    responses.add(
        "POST",
        event_url,
        json={"success": True, "message": "Event triggered successfully!"},
    )

    files = (
        (
            "training_files",
            ("nlu.yml", open("tests/testing_data/parallel_action/data/nlu.yml", "rb")),
        ),
        (
            "training_files",
            ("domain.yml", open("tests/testing_data/parallel_action/domain.yml", "rb")),
        ),
        (
            "training_files",
            ("stories.yml", open("tests/testing_data/parallel_action/data/stories.yml", "rb")),
        ),
        (
            "training_files",
            ("rules.yml", open("tests/testing_data/parallel_action/data/rules.yml", "rb")),
        ),
        (
            "training_files",
            ("multiflow_stories.yml", open("tests/testing_data/parallel_action/multiflow_stories.yml", "rb")),
        ),
        (
            "training_files",
            ("actions.yml", open("tests/testing_data/parallel_action/actions.yml", "rb")),
        ),
        (
            "training_files",
            ("config.yml", open("tests/testing_data/parallel_action/config.yml", "rb")),
        ),
        (
            "training_files",
            (
                "chat_client_config.yml",
                open("tests/testing_data/all/chat_client_config.yml", "rb"),
            ),
        ),
        (
            "training_files",
            (
                "bot_content.yml",
                open("tests/testing_data/all/bot_content.yml", "rb"),
            ),
        ),
    )
    response = client.post(
        f"/api/bot/{pytest.bot}/upload?import_data=true&overwrite=true",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
        files=files,
    )
    actual = response.json()
    assert actual["message"] == "Upload in progress! Check logs."
    assert actual["error_code"] == 0
    assert actual["data"] is None
    assert actual["success"]
    complete_end_to_end_event_execution(
        pytest.bot, "integration@demo.ai", EventClass.data_importer
    )

    Actions.objects(name__in=["api1", "api2", "py1", "py2", "parallel_action"]).delete()
    PyscriptActionConfig.objects(name__in=["py1", "py2"]).delete()
    HttpActionConfig.objects(action_name__in=["api1", "api2"]).delete()
    ParallelActionConfig.objects(name="parallel_action").delete()


def test_list_existing_actions_for_parallel_action():
    Actions.objects(bot=pytest.bot).delete()
    processor = MongoProcessor()
    user = "integration@demo.ai"
    action_1 = "http_action_1"
    action_2 = "email_action_1"
    action_3 = "jira_action_1"
    action_4 = "live_agent_action_1"
    action_5 = "parallel_action_1"

    processor.add_action(action_1, pytest.bot, user, action_type=ActionType.http_action)
    processor.add_action(action_2, pytest.bot, user, action_type=ActionType.email_action)
    processor.add_action(action_3, pytest.bot, user, action_type=ActionType.jira_action)
    processor.add_action(action_4, pytest.bot, user, action_type=ActionType.live_agent_action)
    processor.add_action(action_5, pytest.bot, user, action_type=ActionType.parallel_action)

    response = client.get(
        url=f"/api/bot/{pytest.bot}/action/parallel/actions",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = response.json()
    print(actual)

    assert actual["success"] is True
    assert actual["error_code"] == 0
    assert actual["message"] is None

    assert len(actual["data"]) == 3
    expected_actions = {action_1: ActionType.http_action.value,
                        action_2: ActionType.email_action.value,
                        action_3: ActionType.jira_action.value}
    actual_actions = {action["name"]: action["type"] for action in actual["data"]}

    for name, action_type in expected_actions.items():
        assert name in actual_actions
        assert actual_actions[name] == action_type

    assert action_4 not in actual_actions
    assert action_5 not in actual_actions

    Actions.objects(name__in=[action_1, action_2, action_3, action_4, action_5], bot=pytest.bot).delete()

@responses.activate
def test_idp_provider_fields():
    response = client.get(
        "/api/idp/provider/fields",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()
    actual_data = Utility.system_metadata["providers"]

    assert response["data"] == actual_data
    assert len(response["data"]["oidc"]["azure_oidc"]["required_fields"]) == 4


@responses.activate
def test_add_organization():
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.post(
        "/api/account/organization",
        json={"data": {"name": "sample"}},
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )
    result = response.json()
    assert result["data"]["org_id"] is not None
    assert result["message"] == "organization added"


@responses.activate
def test_get_organization():
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.get(
        "/api/account/organization",
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )
    result = response.json()
    assert result["data"] is not None
    assert result["data"]["name"] == "sample"
    assert result["data"]["user"] == "integration1234567890@demo.ai"


@responses.activate
def test_update_organization():
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.post(
        "/api/account/organization",
        json={"data": {"name": "updated_sample"}},
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )
    result = response.json()
    assert result["message"] == "organization added"


@responses.activate
def test_get_organization_after_update():
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.get(
        "/api/account/organization",
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )
    result = response.json()
    assert result["data"] is not None
    assert result["data"]["name"] == "updated_sample"
    assert result["data"]["user"] == "integration1234567890@demo.ai"


@responses.activate
def test_delete_organization(monkeypatch):
    def _delete_idp(*args, **kwargs):
        return

    monkeypatch.setattr(IDPProcessor, "delete_idp", _delete_idp)
    email = "integration1234567890@demo.ai"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login = response.json()
    response = client.delete(
        f"/api/account/organization/updated_sample",
        headers={
            "Authorization": login["data"]["token_type"]
                             + " "
                             + login["data"]["access_token"]
        },
    )
    result = response.json()
    assert result["data"] is None
    assert result["message"] == "Organization deleted"


def test_get_model_testing_logs_accuracy():
    response = client.get(
        f"/api/user/test/accuracy",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    assert response["data"] is not None
    assert response["success"] is True
    assert response["error_code"] == 0


@mock.patch('kairon.shared.account.activity_log.UserActivityLogger.is_login_within_cooldown_period', autospec=True)
def test_delete_account(mock_password_reset):
    def _password_reset(*args, **kwargs):
        return

    mock_password_reset.return_value = _password_reset
    response_log = client.post(
        "/api/auth/login",
        data={"username": "integration@demo.ai", "password": "Welcome@10"},
    )
    actual = response_log.json()
    UserEmailConfirmation(email="integration@demo.ai").save()
    UserActivityLog(
        type="user_consent",
        user="integration@demo.ai",
        message=['Privacy Policy, Terms and Conditions and AI Guidelines consent'],
        data={
            "username": "integration@demo.ai",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "terms_and_policy_version": 1.0
        }
    ).save()
    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.access_token_delete = actual["data"]["access_token"]
    pytest.token_type_delete = actual["data"]["token_type"]
    response = client.delete(
        "/api/account/delete",
        headers={
            "Authorization": pytest.token_type_delete + " " + pytest.access_token_delete
        },
    ).json()
    assert response["success"]
    assert response["message"] == "Account deleted"
    assert response["error_code"] == 0
    assert UserEmailConfirmation.objects(email="integration@demo.ai").count() == 0
    assert UserActivityLog.objects(user="integration@demo.ai", type='user_consent').count() == 0


def test_delete_account_already_deleted():
    response = client.delete(
        "/api/account/delete",
        headers={
            "Authorization": pytest.token_type_delete + " " + pytest.access_token_delete
        },
    ).json()
    assert not response["success"]
    assert response["message"] == "User does not exist!"


def test_get_responses_post_passwd_reset(monkeypatch):
    email = "active_session@demo.ai"
    regsiter_response = client.post(
        "/api/account/registration",
        json={
            "email": email,
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "integration",
            "bot": "integration",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = regsiter_response.json()
    login_response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    login_actual = login_response.json()
    pytest.access_token = login_actual["data"]["access_token"]
    pytest.token_type = login_actual["data"]["token_type"]

    response = client.post(
        "/api/account/bot",
        json={"name": "covid-bot"},
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    response = response.json()
    assert response["data"]['bot_id']
    assert response['message'] == "Bot created"

    bot_response = client.get(
        "/api/account/bot",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    ).json()

    pytest.bot = bot_response["data"]["account_owned"][0]["_id"]
    token = Authentication.create_access_token(data={"mail_id": email})

    def get_token(*args, **kwargs):
        return token

    monkeypatch.setattr(Authentication, "create_access_token", get_token)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    passwrd_change_response = client.post(
        "/api/account/password/change",
        json={
            "data": token,
            "password": "Welcome@21",
            "confirm_password": "Welcome@21",
        },
    )

    utter_response = client.get(
        f"/api/bot/{pytest.bot}/response/utter_greet",
        headers={"Authorization": pytest.token_type + " " + pytest.access_token},
    )
    actual = utter_response.json()
    message = actual["message"]
    error_code = actual['error_code']
    assert message == 'Session expired. Please login again!'
    assert error_code == 401


def test_create_access_token_with_iat():
    access_token = Authentication.create_access_token(
        data={"sub": "test@chat.com", "access-limit": ["/api/bot/.+/intent"]},
        token_type=TOKEN_TYPE.LOGIN.value,
    )
    payload = Utility.decode_limited_access_token(access_token)
    assert payload.get("iat") is not None


def test_overwrite_password_for_matching_passwords(monkeypatch):
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    response = client.post(
        "/api/account/password/change",
        json={
            "data": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtYWlsX2lkIjoiaW50ZWcxQGdtYWlsLmNvbSJ9.Ycs1ROb1w6MMsx2WTA4vFu3-jRO8LsXKCQEB3fkoU20",
            "password": "Welcome@20",
            "confirm_password": "Welcome@20",
        },
    )
    actual = response.json()
    assert actual["success"]
    assert actual["error_code"] == 0
    assert actual["message"] == "Success! Your password has been changed"
    assert actual["data"] is None


def test_login_new_password():
    response = client.post(
        "/api/auth/login",
        data={"username": "integ1@gmail.com", "password": "Welcome@20"},
    )
    actual = response.json()

    assert actual["success"]
    assert actual["error_code"] == 0
    pytest.access_token = actual["data"]["access_token"]
    pytest.token_type = actual["data"]["token_type"]


def test_login_old_password():
    response = client.post(
        "/api/auth/login",
        data={"username": "integ1@gmail.com", "password": "Welcome@10"},
    )
    actual = response.json()
    assert not actual["success"]
    assert actual["error_code"] == 401
    assert actual["message"] == "Incorrect username or password"
    assert actual["data"] is None
    value = list(AuditLogData.objects(user="integ1@gmail.com", action='activity', entity='invalid_login').order_by(
        "-timestamp"))[
        0
    ]
    assert value["entity"] == "invalid_login"
    assert value["timestamp"]
    assert value["data"] == {'message': ['Incorrect username or password'], 'username': 'integ1@gmail.com'}


def test_get_responses_change_passwd_with_same_passwrd(monkeypatch):
    email = "samepasswrd@demo.ai"
    regsiter_response = client.post(
        "/api/account/registration",
        json={
            "email": email,
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "samepasswrd",
            "bot": "samepasswrd",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    token = Authentication.create_access_token(data={"mail_id": email})

    def get_token(*args, **kwargs):
        return token

    monkeypatch.setattr(Authentication, "create_access_token", get_token)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    Utility.environment["user"]["reset_password_cooldown_period"] = 0
    passwrd_change_response = client.post(
        "/api/account/password/change",
        json={"data": token, "password": "Welcome@10", "confirm_password": "Welcome@10"},
    )
    response = passwrd_change_response.json()
    message = response.get("message")
    assert message == "You have already used this password, try another!"


def test_get_responses_change_passwd_with_same_passwrd_rechange(monkeypatch):
    Utility.environment["user"]["reset_password_cooldown_period"] = 0
    email = "samepasswrd2@demo.ai"
    regsiter_response = client.post(
        "/api/account/registration",
        json={
            "email": email,
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "samepasswrd2",
            "bot": "samepasswrd2",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    token = Authentication.create_access_token(data={"mail_id": email})

    def get_token(*args, **kwargs):
        return token

    monkeypatch.setattr(Authentication, "create_access_token", get_token)
    monkeypatch.setattr(MailUtility, "trigger_smtp", mock_smtp)
    passwrd_change_response = client.post(
        "/api/account/password/change",
        json={
            "data": token,
            "password": "Welcome@21",
            "confirm_password": "Welcome@21",
        },
    )
    passwrd_firstchange = passwrd_change_response.json()
    assert passwrd_firstchange["success"]
    assert passwrd_firstchange["error_code"] == 0
    assert passwrd_firstchange["message"] == "Success! Your password has been changed"
    assert passwrd_firstchange["data"] is None

    passwrd_rechange_response = client.post(
        "/api/account/password/change",
        json={
            "data": token,
            "password": "Welcome@21",
            "confirm_password": "Welcome@21",
        },
    )
    response = passwrd_rechange_response.json()
    message = response.get("message")
    assert message == "You have already used this password, try another!"


def test_idp_provider_fields_unauth():
    response = client.get(
        "/api/idp/provider/fields",
        headers={"Authorization": pytest.token_type + " worng_token"},
    ).json()

    assert response["error_code"] == 401


def test_allowed_origin_default():
    response = client.post(
        "/api/auth/login", data={"username": "test@demo.ai", "password": "Welcome@10"}
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "User does not exist!"
    assert response.headers == {
        "content-length": "79",
        "content-type": "application/json",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "cross-origin-embedder-policy": "require-corp",
        "cross-origin-opener-policy": "same-origin",
        "cross-origin-resource-policy": "same-origin",
        "access-control-allow-origin": "*",
    }


def test_allowed_origin(monkeypatch):
    monkeypatch.setitem(Utility.environment["cors"], "origin", "http://digite.com")

    response = client.post(
        "/api/auth/login",
        data={"username": "test@demo.ai", "password": "Welcome@10"},
        headers={"origin": "http://digite.com"},
    )
    actual = response.json()
    assert actual["error_code"] == 422
    assert not actual["success"]
    assert actual["message"] == "User does not exist!"
    assert response.headers == {
        "content-length": "79",
        "content-type": "application/json",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "cross-origin-embedder-policy": "require-corp",
        "cross-origin-opener-policy": "same-origin",
        "cross-origin-resource-policy": "same-origin",
        "access-control-allow-origin": "http://digite.com",
        "access-control-allow-credentials": "true",
        "access-control-expose-headers": "content-disposition",
    }


def test_get_client_ip():
    headers = {"X-Forwarded-For": "10.0.0.1"}
    response = client.post(
        "/api/auth/login",
        data={"username": "test@demo.ai", "password": "Welcome@10"},
        headers=headers,
    )
    assert Utility.get_client_ip(response.request) == "10.0.0.1"

    headers = {"X-Forwarded-For": "10.0.0.2, 10.0.1.1"}
    response = client.post(
        "/api/auth/login",
        data={"username": "test@demo.ai", "password": "Welcome@10"},
        headers=headers,
    )
    assert Utility.get_client_ip(response.request) == "10.0.0.2, 10.0.1.1"

    headers = {"X-Real-IP": "10.0.0.3"}
    response = client.post(
        "/api/auth/login",
        data={"username": "test@demo.ai", "password": "Welcome@10"},
        headers=headers,
    )
    assert Utility.get_client_ip(response.request) == "10.0.0.3"


def test_allow_only_sso_login(monkeypatch):
    user = "test@demo.in"
    organization = "new_test"
    feature_type = FeatureMappings.ONLY_SSO_LOGIN.value
    value = True
    OrgProcessor.upsert_user_org_mapping(
        user=user, org=organization, feature=feature_type, value=value
    )

    response = client.post(
        "/api/auth/login",
        data={"username": user, "password": "Welcome@10"},
    )
    actual = response.json()
    assert (
            actual["message"]
            == "Login with your org SSO url, Login with username/password not allowed"
    )


def test_idp_callback(monkeypatch):
    def _validate_org_settings(*args, **kwargs):
        return

    def _get_idp_token(*args, **kwargs):
        return {
            "email": "new_idp_user@demo.in",
            "given_name": "test",
            "family_name": "user",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        }

    monkeypatch.setattr(IDPProcessor, "get_idp_token", _get_idp_token)
    monkeypatch.setattr(OrgProcessor, "validate_org_settings", _validate_org_settings)

    realm_name = "test"
    response = client.get(
        f"/api/auth/login/idp/callback/{realm_name}?session_state=asikndhfnnin-jinsdn-sdnknsdn&code=kjaskjkajb-wkejhwejwe",
    )
    result = response.json()
    assert result["data"]["access_token"] is not None
    assert result["data"]["token_type"] == "bearer"
    assert result["message"] == "User Authenticated"


def test_api_login_with_SSO_only_flag():
    user = "idp_user@demo.in"
    organization = "new_test"
    feature_type = FeatureMappings.ONLY_SSO_LOGIN.value
    value = True
    OrgProcessor.upsert_user_org_mapping(
        user=user, org=organization, feature=feature_type, value=value
    )

    email = "idp_user@demo.in"
    response = client.post(
        "/api/auth/login",
        data={"username": email, "password": "Welcome@10"},
    )
    actual = response.json()
    assert (
            actual["message"]
            == "Login with your org SSO url, Login with username/password not allowed"
    )
    assert actual["error_code"] == 422
    assert actual["success"] == False


def test_list_system_metadata():
    response = client.get(url=f"/api/system/metadata", allow_redirects=False)
    actual = response.json()
    assert actual["error_code"] == 0
    assert actual["success"]
    assert len(actual["data"]) == 18

def test_leave_bot_successfully_1(monkeypatch):
    response = client.post(
        "/api/account/registration",
        json={
            "email": "mayank_owner@digite.com",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "mayank_owner",
            "bot": "mayank_owner",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    response = client.post(
        "/api/account/registration",
        json={
            "email": "mayank_tester@digite.com",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "mayank_tester",
            "bot": "mayank_tester",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    response = client.post(
        "/api/account/registration",
        json={
            "email": "mayank_admin@digite.com",
            "first_name": "Demo",
            "last_name": "User",
            "password": "Welcome@10",
            "confirm_password": "Welcome@10",
            "account": "mayank_admin",
            "bot": "mayank_admin",
            "accepted_privacy_policy": True,
            "accepted_terms": True,
            "accepted_ai_guidelines": True
        },
    )
    actual = response.json()
    assert actual["message"] == "Account Registered!"

    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_owner@digite.com", "password": "Welcome@10"},
    )

    actual = response.json()
    assert "access_token" in actual["data"]
    assert actual["success"]

    response = client.post(
        "/api/account/bot",
        json={"name": "mayank-test-bot"},
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    ).json()
    pytest.mayank_bot = response['data']['bot_id']

    response = client.post(
        f"/api/user/{pytest.mayank_bot}/member",
        json={"email": "mayank_tester@digite.com", "role": "tester"},
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    ).json()

    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_tester@digite.com", "password": "Welcome@10"},
    )
    actual = response.json()

    response = client.get(
        "/api/account/bot",
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    ).json()
    assert len(response["data"]["shared"]) == 1

    response = client.delete(
        f"/api/user/{pytest.mayank_bot}/leave",
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    ).json()
    assert response["message"] == "Successfully left the bot"
    assert response["error_code"] == 0
    assert response["success"]

def test_leave_bot_owner_forbidden():
    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_owner@digite.com", "password": "Welcome@10"},
    )
    actual = response.json()
    assert "access_token" in actual["data"]
    assert actual["success"]

    # Step 2: Attempt to leave the bot
    response = client.delete(
        f"/api/user/{pytest.mayank_bot}/leave",
        headers={
            "Authorization": f"{actual['data']['token_type']}"+ " " + f"{actual['data']['access_token']}"
        },
    ).json()

    # Step 3: Validate response
    assert response["message"] == "Owner cannot leave the bot"
    assert response["error_code"] == 422
    assert not response["success"]

def test_leave_bot_with_integration_tokens():
    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_owner@digite.com", "password": "Welcome@10"},
    )

    actual = response.json()
    assert "access_token" in actual["data"]
    assert actual["success"]

    response = client.post(
        f"/api/user/{pytest.mayank_bot}/member",
        json={"email": "mayank_admin@digite.com", "role": "admin"},
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    ).json()

    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_admin@digite.com", "password": "Welcome@10"},
    )
    actual = response.json()
    assert "access_token" in actual["data"]
    assert actual["success"]


    response = client.post(
        f"/api/auth/{pytest.mayank_bot}/integration/token",
        json={"name": "integration 100", "expiry_minutes": 1440, "role": "designer"},
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    )
    token = response.json()
    print(token)
    response = client.delete(
        f"/api/user/{pytest.mayank_bot}/leave",
        headers={
            "Authorization": actual["data"]["token_type"] + " " + actual["data"]["access_token"]
        },
    )
    actual = response.json()
    assert actual["message"] == "You must delete all your integration tokens before leaving the bot"
    assert actual["error_code"] == 422
    assert not actual["success"]

def test_leave_non_existent_bot_1():
    response = client.post(
        "/api/auth/login",
        data={"username": "mayank_tester@digite.com", "password": "Welcome@10"},
    )
    actual = response.json()
    assert "access_token" in actual["data"]
    assert actual["success"]
    response = client.delete(
        "/api/user/000000abcdefgh/leave",
        headers={
            "Authorization": f"{actual['data']['token_type']}" + " " + f"{actual['data']['access_token']}"
        },
    )
    actual = response.json()
    assert actual["message"] == "Access to bot is denied"
    assert actual["error_code"] == 422
    assert not actual["success"]



def test_redoc_headers():
    response = client.get("/redoc")
    assert response.status_code == 200
    assert response.headers == {
        "content-length": "498",
        "content-type": "text/html; charset=utf-8",
        "content-encoding": "gzip",
        "vary": "Accept-Encoding",
        "server": "Secure",
        "strict-transport-security": "includeSubDomains; preload; max-age=31536000",
        "x-frame-options": "SAMEORIGIN",
        "x-xss-protection": "0",
        "x-content-type-options": "nosniff",
        "content-security-policy": "default-src 'self'; frame-ancestors 'self'; form-action 'self'; base-uri 'self'; connect-src 'self'; frame-src 'self'; style-src 'self' https: 'unsafe-inline'; img-src 'self' https:; script-src 'self' https: 'unsafe-inline'; worker-src blob:",
        "referrer-policy": "no-referrer",
        "cache-control": "must-revalidate",
        "permissions-policy": "accelerometer=(), autoplay=(), camera=(), document-domain=(), encrypted-media=(), fullscreen=(), vibrate=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), sync-xhr=(), usb=()",
        "cross-origin-embedder-policy": "require-corp",
        "cross-origin-opener-policy": "same-origin",
        "cross-origin-resource-policy": "same-origin",
        "access-control-allow-origin": "*"
    }
